<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:type" content="website">
<meta property="og:title" content="Dev.Gao的学习笔记">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Dev.Gao的学习笔记">
<meta property="og:description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dev.Gao">
<meta property="article:tag" content="iOS,Android,Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dev.Gao的学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dev.Gao的学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">数据结构之动态数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-09-05 18:25:56" itemprop="dateCreated datePublished" datetime="2017-09-05T18:25:56+08:00">2017-09-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>数组是一种顺序存储的线性表，所有元素的内存地址是连续的。</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">◼ <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>; <span class="comment">// 元素的数量</span></span><br><span class="line">◼ <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; <span class="comment">// 是否为空</span></span><br><span class="line">◼ <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span></span>; <span class="comment">// 是否包含某个元素</span></span><br><span class="line">◼ <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span></span>; <span class="comment">// 添加元素到最后面</span></span><br><span class="line">◼ <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 返回index位置对应的元素</span></span><br><span class="line">◼ <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 设置index位置的元素</span></span><br><span class="line">◼ <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>; <span class="comment">// 往index位置添加元素</span></span><br><span class="line">◼ <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">// 删除index位置对应的元素</span></span><br><span class="line">◼ <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span></span>; <span class="comment">// 查看元素的位置</span></span><br><span class="line">◼ <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">// 清除所有元素</span></span><br></pre></td></tr></table></figure>

<h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> &lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来记录存入元素的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//用来存放元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> E elements[];</span><br><span class="line">    <span class="comment">//默认容量为10</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有找到的标识</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ELEMENT_NOT_FOUND = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> capaticy 数组的容量，如果小于默认容量，则使用默认容量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> capaticy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果容量小于默认容量，则使用默认容量</span></span><br><span class="line">        capaticy = capaticy &lt; DEFAULT_CAPACITY ? DEFAULT_CAPACITY:capaticy;</span><br><span class="line">        elements = (E[]) <span class="keyword">new</span> Object[capaticy];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 无参构造函数，默认容量为 DEFAULT_CAPACITY</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 向数组最后面添加元素</span></span><br><span class="line"><span class="comment">    * @param element 要添加的元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向数组最后添加元素，就是像数组index=size添加</span></span><br><span class="line">        add(size,element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 向数组index的位置，添加元素element</span></span><br><span class="line"><span class="comment">    * @param index</span></span><br><span class="line"><span class="comment">    * @param element</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先检查index是否合法</span></span><br><span class="line">        checkRangeForAdd(index);</span><br><span class="line">        <span class="comment">//再要确保elements的容量有size + 1;</span></span><br><span class="line">        ensureCapaticy(size + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将elements中 [index,size-1]区间内的元素依次向后移一个位置，从最后开始移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &gt; index; i--) &#123;</span><br><span class="line">            elements[i] = elements[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将element插入到index位置</span></span><br><span class="line">        elements[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 移除index处的元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先检查index是否合法</span></span><br><span class="line">        checkRange(index);</span><br><span class="line">        <span class="comment">//先获取index的元素，以便最后返回</span></span><br><span class="line">        E oldElement = elements[index];</span><br><span class="line">        <span class="comment">//将[index+1,size-1]区间的元素依次向前移动一个。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            elements[index] = elements[index + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新size</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 清空数组中所有元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历elements,置为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            elements[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先检查index是否合法</span></span><br><span class="line">        checkRange(index);</span><br><span class="line">        <span class="comment">//合法的话，先获取index的旧元素以便最后返回</span></span><br><span class="line">        E oldElement = elements[index];</span><br><span class="line">        <span class="comment">//替换新元素</span></span><br><span class="line">        elements[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldElement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 获取动态数组中元素的数量</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 判断该数组是不是为空</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 判断该数组是否包含元素 element,遍历判断</span></span><br><span class="line"><span class="comment">    * @param element 要比对的元素</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(element) != ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 根据元素返回该元素的下标</span></span><br><span class="line"><span class="comment">    * @param</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断element是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历数组，找到就返回下标i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历数组，找到就返回下标i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (element.equals(elements[i])) <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果上面都没找到，返回 ELEMENT_NOT_FOUND</span></span><br><span class="line">        <span class="keyword">return</span> ELEMENT_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 根据角标获取元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 要查询的角标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先检查角标是否越界</span></span><br><span class="line">        checkRange(index);</span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * @description 检查index是否合法</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkRange</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;index: &quot;</span>+ index +<span class="string">&quot;越界,Size=&quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description 对Add操作检查index是否合法，判断的依据为index是否大于0，是否不超过size。</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkRangeForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;index: &quot;</span>+ index +<span class="string">&quot;越界,Size=&quot;</span> + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * @description 确保element有capaticy的容量，如果不够，则进行扩容</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapaticy</span><span class="params">(<span class="keyword">int</span> capaticy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果elements长度大于等于capaticy, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (elements.length &gt;= capaticy) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果不够，先创建一个容量为elements 1.5倍的新数组，使用位运算效率要高。</span></span><br><span class="line">        E[] newElements = (E[]) <span class="keyword">new</span> Object[elements.length + (elements.length &gt;&gt; <span class="number">1</span>)];</span><br><span class="line">        <span class="comment">// 再将旧元素从elements中已入newElements中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">            newElements[i] = elements[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 用newElements替代elements</span></span><br><span class="line">        elements = newElements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;size:&quot;</span> + size).append(<span class="string">&quot;,[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            E element = elements[i];</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) stringBuilder.append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            stringBuilder.append(element.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OC实现"><a href="#OC实现" class="headerlink" title="OC实现"></a>OC实现</h2><p><strong>GLArrayList.h</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLArrayList</span> &lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>) init;</span><br><span class="line">- (<span class="keyword">instancetype</span>) initWithCapaticy:(<span class="keyword">int</span>)capaticy;</span><br><span class="line">+ (<span class="keyword">instancetype</span>) new __unavailable;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 增</span></span><br><span class="line">- (<span class="keyword">void</span>) addElement:(ObjectType)element;</span><br><span class="line">- (<span class="keyword">void</span>) addElement:(ObjectType)element atIndex:(<span class="keyword">int</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 删</span></span><br><span class="line">- (ObjectType) removeAtIndex:(<span class="keyword">int</span>)index;</span><br><span class="line">- (<span class="keyword">void</span>) clear;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 改</span></span><br><span class="line">- (ObjectType) setElement:(ObjectType)element atIndex:(<span class="keyword">int</span>)index;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 查</span></span><br><span class="line">- (<span class="keyword">int</span>) size;</span><br><span class="line">- (<span class="built_in">BOOL</span>) isEmpty;</span><br><span class="line">- (<span class="built_in">BOOL</span>) containsElement:(ObjectType)element;</span><br><span class="line">- (ObjectType) getElementAtIndex:(<span class="keyword">int</span>)index;</span><br><span class="line">- (<span class="keyword">int</span>) indexOfElement:(ObjectType)element;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>GLArrayList.m</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组默认容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> GL_ARRAY_LIST_DEFAULT_CAPATICY = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">const</span> GL_ARRAY_LIST_NOT_FOUND = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> * AnyObject;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLArrayList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来存放元素的数组</span></span><br><span class="line">    AnyObject *_array;</span><br><span class="line">    <span class="comment">//用来记录_array中元素的数量</span></span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line">    <span class="comment">//用来记录_array中的容量</span></span><br><span class="line">    <span class="keyword">int</span> _capacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLArrayList</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>) init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _array = calloc(GL_ARRAY_LIST_DEFAULT_CAPATICY, <span class="keyword">sizeof</span>(AnyObject));</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _capacity = GL_ARRAY_LIST_DEFAULT_CAPATICY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>) initWithCapaticy:(<span class="keyword">int</span>)capaticy &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _array = calloc(capaticy, <span class="keyword">sizeof</span>(AnyObject));</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">        _capacity = capaticy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 增</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将元素添加至数组最后</span></span><br><span class="line"><span class="comment">/// @param element 要添加的元素</span></span><br><span class="line">- (<span class="keyword">void</span>) addElement:(<span class="keyword">id</span>)element &#123;</span><br><span class="line">    [<span class="keyword">self</span> addElement:element atIndex:_size];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) addElement:(<span class="keyword">id</span>)element atIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="comment">//先确定index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [GLArrayIndexOutOfBoundsException exeptionWithIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首先确保有size + 1 的容量，如果没有要扩容</span></span><br><span class="line">    [<span class="keyword">self</span> ensureCapaticy:_size + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 把[index,size - 1]区间内从后开始，依次向后挪动一个单位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = _size; i &gt; index; i--) &#123;</span><br><span class="line">        _array[i] = _array[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将element插入index处</span></span><br><span class="line">    _array[index] = (__bridge_retained AnyObject)element;</span><br><span class="line">    _size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 确保_array有Capaticy的容量</span></span><br><span class="line"><span class="comment">/// @param capaticy 容量</span></span><br><span class="line">- (<span class="keyword">void</span>) ensureCapaticy:(<span class="keyword">int</span>)capaticy &#123;</span><br><span class="line">    <span class="comment">//如果当前容量大于capaticy, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (_capacity &gt;= capaticy) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//否则进行扩容，创建一个新数组，扩容为当前容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapaticy = _capacity + (_capacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    GLLog(<span class="string">@&quot;capaticy:%d -&gt; %d&quot;</span>,_capacity,newCapaticy);</span><br><span class="line">    AnyObject *newArray = calloc(newCapaticy, <span class="keyword">sizeof</span>(AnyObject));</span><br><span class="line">    <span class="comment">//将所有元素移入新数组中</span></span><br><span class="line">    AnyObject *oldArray = _array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        newArray[i] = oldArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">    _array = newArray;</span><br><span class="line">    _capacity = newCapaticy;</span><br><span class="line">    free(oldArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 删</span></span><br><span class="line">- (<span class="keyword">id</span>) removeAtIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="comment">//首先检查index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [GLArrayIndexOutOfBoundsException exeptionWithIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出要移除的元素</span></span><br><span class="line">    AnyObject elementToRemove = _array[index];</span><br><span class="line">    <span class="comment">//将[index+1,size -1]区间内的元素，从前到后依次向前移动一个单位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; _size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        _array[i] = _array[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    _size--;</span><br><span class="line">    GLLog(<span class="string">@&quot;will remove %@&quot;</span>,elementToRemove);</span><br><span class="line">    <span class="keyword">return</span> (__bridge_transfer <span class="keyword">id</span>)elementToRemove;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) clear &#123;</span><br><span class="line">    <span class="comment">//遍历释放元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="built_in">CFRelease</span>(_array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 改</span></span><br><span class="line">- (<span class="keyword">id</span>) setElement:(<span class="keyword">id</span>)element atIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="comment">//先检查index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [GLArrayIndexOutOfBoundsException exeptionWithIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出最后的元素以便返回</span></span><br><span class="line">    AnyObject oldElement = _array[index];</span><br><span class="line">    <span class="comment">//将element覆盖index的位置</span></span><br><span class="line">    _array[index] = (__bridge_retained AnyObject) element;</span><br><span class="line">    <span class="built_in">CFRelease</span>(oldElement);</span><br><span class="line">    <span class="keyword">return</span> (__bridge <span class="keyword">id</span>)oldElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - 查</span></span><br><span class="line"><span class="comment">/// 获取当前数组中元素的数量</span></span><br><span class="line">- (<span class="keyword">int</span>) size &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 数组是否为空</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) isEmpty &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>-&gt;_size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 数组中是否包含element元素</span></span><br><span class="line"><span class="comment">/// @param element 要对比的元素</span></span><br><span class="line">- (<span class="built_in">BOOL</span>) containsElement:(<span class="keyword">id</span>)element &#123;</span><br><span class="line">    <span class="comment">//遍历元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([element isEqual:(__bridge <span class="keyword">id</span>)(_array[i])]) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 获取下标为index的元素</span></span><br><span class="line"><span class="comment">/// @param index 下标</span></span><br><span class="line">- (<span class="keyword">id</span>) getElementAtIndex:(<span class="keyword">int</span>)index &#123;</span><br><span class="line">    <span class="comment">//首先检查index是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">@throw</span> [GLArrayIndexOutOfBoundsException exeptionWithIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (__bridge <span class="keyword">id</span>)_array[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取element对应的下标</span></span><br><span class="line"><span class="comment">/// @param element element</span></span><br><span class="line">- (<span class="keyword">int</span>) indexOfElement:(<span class="keyword">id</span>)element &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([element isEqual:(__bridge  <span class="keyword">id</span>)_array[i]]) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> GL_ARRAY_LIST_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *des = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [des appendFormat:<span class="string">@&quot;size=%d,[&quot;</span>,_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            [des appendString:<span class="string">@&quot;,&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [des appendFormat:<span class="string">@&quot;%@&quot;</span>,_array[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    [des appendString:<span class="string">@&quot;]&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> clear];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="post-title-link" itemprop="url">数据结构与算法之复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-08-30 14:41:06" itemprop="dateCreated datePublished" datetime="2017-08-30T14:41:06+08:00">2017-08-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>复杂度用来描述算法的好坏，一般从时间或空间两个角度去描述</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/08/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A4%8D%E6%9D%82%E5%BA%A6/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/RunLoop%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/25/RunLoop%E5%BA%94%E7%94%A8%E4%B9%8B%E7%BA%BF%E7%A8%8B%E4%BF%9D%E6%B4%BB/" class="post-title-link" itemprop="url">RunLoop应用之线程保活</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-25 06:41:05" itemprop="dateCreated datePublished" datetime="2017-06-25T06:41:05+08:00">2017-06-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RunLoop比较常见的应用之一就是用来做线程保活</p>
<p>通过一个例子来看：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="comment">//需要持有的子线程，GLThread是NSThread的子类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) GLThread *thread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.thread = [[GLThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启runLoop</span></span><br><span class="line">- (<span class="keyword">void</span>) run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s %@&quot;</span>,__func__,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s ----end----&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;self.thread isFinished: %d&quot;</span>,[<span class="keyword">self</span>.thread isFinished]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触摸屏幕后，在self.thread线程中，执行test方法</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(test) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s %@&quot;</span>, __func__, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加事件源"><a href="#添加事件源" class="headerlink" title="添加事件源"></a>添加事件源</h2><p>当项目运行起来时，可以看到控制台输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[ViewController run] &lt;GLThread: 0x6000030642c0&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">-[ViewController run] ----end----</span><br></pre></td></tr></table></figure>

<p>线程并没有在<code>-[ViewController run]</code>中跑起来，运行完直接退出了RunLoop。点击屏幕也没有任何反应。原因是：</p>
<p><strong>新开启的线程中，虽然调用了Runloop的run方法，但是因为没有事件源，Runloop直接退出了。</strong></p>
<p>解决办法是添加一个事件源:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s %@&quot;</span>,__func__,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s ----end----&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加事件源后，控制台输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[ViewController run] &lt;GLThread: 0x600003994600&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>并且没有执行<code>NSLog(@&quot;%s ----end----&quot;, __func__)</code>这一句。</p>
<p>点击屏幕控制台输出：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-[ViewController <span class="built_in">test</span>] &lt;GLThread: 0x600003994600&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>

<p>看来添加事件源后，的确解决了Runloop退出的问题。</p>
<h2 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h2><p>但是上述代码还会有一个新的问题，就是<code>viewController</code>和<code>viewController.thread</code>不会释放，导致内存泄露。</p>
<p>原因是：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ViewController强引用thread,</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) GLThread *thread; </span><br><span class="line"><span class="comment">// 在初始化thread时，又对target（即viewController）强引用。</span></span><br><span class="line"><span class="keyword">self</span>.thread = [[GLThread alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//这样导致了循环引用。二者皆无法释放。</span></span><br></pre></td></tr></table></figure>

<p>将<code>thread</code>的初始化改为block的方式，把添加事件源在block中完成：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.thread = [[GLThread alloc] initWithBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;-----begin: %@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] run];</span><br><span class="line">        </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;-----end: %@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span>.thread start];</span><br></pre></td></tr></table></figure>

<p>运行项目，发现<code>viewController</code>的确可以释放了，但是<code>viewController.thread</code>还是不能释放，导致了内存泄露</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>NSThread之所以不释放，是因为NSThread内部的Runloop还在运行没有停止。我们设计一个停止方法来终止RunLoop：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) stopAction:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>) stop &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而后就会发现即便是执行了<code>stop</code>方法，点击屏幕依旧有反应，证明没有停止RunLoop。</p>
<p>无法停止的原因在于：<code>[[NSRunLoop currentRunLoop] run]</code>这一句上。</p>
<p>官方文档对于<code>-[NSRunLoop run]</code>这个方法是这样描述的：</p>
<blockquote>
<p>it runs the receiver in the NSDefaultRunLoopMode by repeatedly invoking runMode:beforeDate:. In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers.</p>
<p>它通过重复调用 runMode:beforeDate: 在 NSDefaultRunLoopMode 中运行接收器。 换句话说，这个方法有效地开始了一个无限循环，它处理来自 run loop 的输入源和计时器的数据。</p>
</blockquote>
<p>说白了,<code>-[NSRunLoop run]</code>内部的实现大概类似于：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即便是调用了<code>CFRunLoopStop(CFRunLoopGetCurrent())</code>也只能停止一次，随后便有开启了下一次RunLoop。一旦调用了这个方法，就停不下来。</p>
<p>官方文档给了一个例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> shouldKeepRunning = <span class="literal">YES</span>; <span class="comment">// global</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *theRL = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">while</span> (shouldKeepRunning &amp;&amp; [theRL runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]]);</span><br></pre></td></tr></table></figure>

<p>设置一个条件判断是否继续运行Runloop。</p>
<p>根据这个来修改一下代码:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SecondViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) GLThread *thread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>,<span class="keyword">getter</span>=isStop) <span class="built_in">BOOL</span> stop;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SecondViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.thread = [[GLThread alloc] initWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----begin: %@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 往RunLoop里面添加Source\Timer\Observer</span></span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        <span class="comment">// 通过条件判断，是否开启下一次RunLoop。</span></span><br><span class="line">          <span class="keyword">while</span> (!weakSelf.isStop) &#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;-----end: %@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.thread start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) stopAction:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(stop) onThread:<span class="keyword">self</span>.thread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) stop &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">    <span class="keyword">self</span>.stop = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当点击停止按钮的时候，控制台输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[SecondViewController stop]</span><br><span class="line">-----end: &lt;GLThread: 0x600002365380&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">SecondViewController dealloc</span><br><span class="line">-[GLThread dealloc]</span><br></pre></td></tr></table></figure>

<p>这样看来内存泄露的问题已经解决了，解决的关键就是不要用<code>-[NSRunLoop run]</code>。现在停止<code>GLThread</code>需要调用<code>stop</code>方法。我们在<code>viewController</code>的<code>dealloc</code>方法中也调用<code>stop</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span> stopAction:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SecondViewController dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完善RunLoop开启条件"><a href="#完善RunLoop开启条件" class="headerlink" title="完善RunLoop开启条件"></a>完善RunLoop开启条件</h2><p>当进入SecondViewController的时候，不点击停止按钮，然后返回。我们会发现GLThread没有销毁。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-----begin: &lt;GLThread: 0x600003740cc0&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">-[SecondViewController stopAction:]</span><br><span class="line">SecondViewController dealloc</span><br><span class="line">-[SecondViewController stop]</span><br></pre></td></tr></table></figure>

<p>原因就在于：返回时执行了 <code>-[SecondViewController dealloc]</code>。这个方法虽然调用用了<code>stop</code>方法。但是由于控制器已经释放，会使得<code>!weakSelf.isStop == YES</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!weakSelf.isStop) &#123;</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStop) &#123;</span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样<code>GLThread</code>就可以释放了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-----begin: &lt;GLThread: 0x6000004e5c80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">-[SecondViewController stopAction:]</span><br><span class="line">SecondViewController dealloc</span><br><span class="line">-[SecondViewController stop]</span><br><span class="line">-----end: &lt;GLThread: 0x6000004e5c80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">-[GLThread dealloc]</span><br></pre></td></tr></table></figure>

<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>下面是两个封装线程的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJPermenantThreadTask)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//- (void)run;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在当前子线程执行一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结束线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">/** MJThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** MJPermenantThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) MJThread *innerThread;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isStopped) <span class="built_in">BOOL</span> stopped;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPermenantThread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stopped = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:[[<span class="built_in">NSPort</span> alloc] init] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span><br><span class="line">                [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- (void)run</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    if (!self.innerThread) return;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    [self.innerThread start];</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.stopped = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJPermenantThreadTask)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 开启线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//- (void)run;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 在当前子线程执行一个任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结束线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)stop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">/** MJThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJThread</span> : <span class="title">NSThread</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJThread</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** MJPermenantThread **/</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJPermenantThread</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) MJThread *innerThread;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJPermenantThread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - public methods</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.innerThread = [[MJThread alloc] initWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;begin----&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建上下文（要初始化一下结构体）</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建source</span></span><br><span class="line">            <span class="built_in">CFRunLoopSourceRef</span> source = <span class="built_in">CFRunLoopSourceCreate</span>(kCFAllocatorDefault, <span class="number">0</span>, &amp;context);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 往Runloop中添加source</span></span><br><span class="line">            <span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), source, kCFRunLoopDefaultMode);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 销毁source</span></span><br><span class="line">            <span class="built_in">CFRelease</span>(source);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            while (weakSelf &amp;&amp; !weakSelf.isStopped) &#123;</span></span><br><span class="line"><span class="comment">//                // 第3个参数：returnAfterSourceHandled，设置为true，代表执行完source后就会退出当前loop</span></span><br><span class="line"><span class="comment">//                CFRunLoopRunInMode(kCFRunLoopDefaultMode, 1.0e10, true);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;end----&quot;</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.innerThread start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread || !task) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__executeTask:) onThread:<span class="keyword">self</span>.innerThread withObject:task waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.innerThread) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(__stop) onThread:<span class="keyword">self</span>.innerThread withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> stop];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - private methods</span></span><br><span class="line">- (<span class="keyword">void</span>)__stop</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CFRunLoopStop</span>(<span class="built_in">CFRunLoopGetCurrent</span>());</span><br><span class="line">    <span class="keyword">self</span>.innerThread = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)__executeTask:(MJPermenantThreadTask)task</span><br><span class="line">&#123;</span><br><span class="line">    task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/RunLoop%E5%BA%94%E7%94%A8%E4%B9%8BNSTimer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/20/RunLoop%E5%BA%94%E7%94%A8%E4%B9%8BNSTimer/" class="post-title-link" itemprop="url">RunLoop应用之NSTimer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-20 06:41:05" itemprop="dateCreated datePublished" datetime="2017-06-20T06:41:05+08:00">2017-06-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NSTimer失效问题"><a href="#NSTimer失效问题" class="headerlink" title="NSTimer失效问题"></a>NSTimer失效问题</h2><p>前面一直提到Timer Source作为事件源，事实上它的上层对应就是NSTimer（其实就是CFRunloopTimerRef）这个开发者经常用到的定时器（底层基于使用<strong>mk_timer</strong>实现），甚至很多开发者接触RunLoop还是从NSTimer开始的。其实NSTimer定时器的触发正是基于RunLoop运行的，所以使用NSTimer之前必须注册到RunLoop，<strong>但是RunLoop为了节省资源并不会在非常准确的时间点调用定时器</strong>，如果一个任务执行时间较长，那么当错过一个时间点后只能等到下一个时间点执行，并不会延后执行（NSTimer提供了一个tolerance属性用于设置宽容度，如果确实想要使用NSTimer并且希望尽可能的准确，则可以设置此属性）。</p>
<p>NSTimer的创建通常有两种方式，尽管都是类方法，一种是timerWithXXX，另一种scheduedTimerWithXXX。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//timer开头的API</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                            target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">                          selector:(SEL)aSelector</span><br><span class="line">                          userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo</span><br><span class="line">                           repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                           repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                             block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scheduledTimer开头的API</span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti</span><br><span class="line">                                     target:(<span class="keyword">id</span>)aTarget</span><br><span class="line">                                   selector:(SEL)aSelector</span><br><span class="line">                                   userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo</span><br><span class="line">                                    repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                                    repeats:(<span class="built_in">BOOL</span>)repeats</span><br><span class="line">                                      block:(<span class="keyword">void</span> (^)(<span class="built_in">NSTimer</span> *timer))block;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二者最大的区别就是后者除了创建一个定时器外会自动以<strong>NSDefaultRunLoopMode</strong>Mode添加到当前线程RunLoop中，不添加到RunLoop中的NSTimer是无法正常工作的。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController1</span>()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *timer2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController1</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// timer1创建后会自动以NSDefaultRunLoopMode默认模式添加到当前RunLoop中，所以可以正常工作</span></span><br><span class="line">    <span class="keyword">self</span>.timer1 = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeInterval:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="built_in">NSTimer</span> *tempTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timeInterval:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">    <span class="comment">// 如果不把timer2添加到RunLoop中是无法正常工作的(注意如果想要在滚动UIScrollView时timer2可以正常工作可以将NSDefaultRunLoopMode改为NSRunLoopCommonModes)</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:tempTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    <span class="keyword">self</span>.timer2 = tempTimer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">true</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;ViewController1 dealloc...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timeInterval:(<span class="built_in">NSTimer</span> *)timer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer1 == timer) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;timer1...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;timer2...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面代码中UIViewController1对timer1和timer2并没有强引用，对于普通的对象而言，执行完viewDidLoad方法之后（准确的说应该是执行完viewDidLoad方法后的的一个RunLoop运行结束）二者应该会被释放，但事实上二者并没有被释放。原因是：为了确保定时器正常运转，当加入到RunLoop以后系统会对NSTimer执行一次retain操作（特别注意：timer2创建时并没直接赋值给timer2，原因是timer2是weak属性，如果直接赋值给timer2会被立即释放，因为timerWithXXX方法创建的NSTimer默认并没有加入RunLoop，只有后面加入RunLoop以后才可以将引用指向timer2）。</p>
<p>但是即使使用了弱引用，上面的代码中ViewController1也无法正常释放，原因是在创建NSTimer2时指定了target为self，这样一来造成了timer1和timer2对ViewController1有一个强引用。解决这个问题的方法通常有两种：</p>
<ul>
<li><p>一种是将target分离出来独立成一个对象（在这个对象中创建NSTimer并将对象本身作为NSTimer的target），控制器通过这个对象间接使用NSTimer；</p>
</li>
<li><p>另一种方式的思路仍然是转移target，只是可以直接增加NSTimer扩展（分类），让NSTimer自身做为target，同时可以将操作selector封装到block中。后者相对优雅，也是目前使用较多的方案（目前有大量类似的封装，例如：<a target="_blank" rel="noopener" href="https://github.com/mBrissman/NSTimer-Block">NSTimer+Block</a>）。显然Apple也认识到了这个问题，如果你可以确保代码只在iOS 10下运行就可以使用iOS 10新增的系统级block方案；</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.timer1 = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> repeats:<span class="literal">YES</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;timer1...&quot;</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>使用上面第二种方法可以解决控制器无法释放的问题，但是会发现即使控制器被释放了两个定时器仍然正常运行，要解决这个问题就需要调用NSTimer的<strong>invalidate</strong>方法（注意：无论是重复执行的定时器还是一次性的定时器只要调用invalidate方法则会变得无效，只是一次性的定时器执行完操作后会自动调用invalidate方法）。修改后的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">  [<span class="keyword">self</span>.timer1 invalidate];</span><br><span class="line">    [<span class="keyword">self</span>.timer2 invalidate];</span><br><span class="line">  [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">true</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实和定时器相关的另一个问题大家也经常碰到，那就是NSTimer不是一种实时机制，<a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Timers/Articles/timerConcepts.html">官方文档</a>明确说明在一个循环中如果RunLoop没有被识别（这个时间大概在50-100ms）或者说当前RunLoop在执行一个长的call out（例如执行某个循环操作）则NSTimer可能就会存在误差，RunLoop在下一次循环中继续检查并根据情况确定是否执行（NSTimer的执行时间总是固定在一定的时间间隔，例如1:00:00、1:00:01、1:00:02、1:00:05则跳过了第4、5次运行循环）。</p>
<p>还有几点需要说明一下：</p>
<ul>
<li>NSTimer会对Target进行强引用直到任务结束或exit之后才会释放。</li>
<li><code>performSelector:withObject:afterDelay:</code>执行的本质还是通过创建一个NSTimer然后加入到当前线程RunLoop（通而过前后两次打印RunLoop信息可以看到此方法执行之后RunLoop的timer会增加1个。类似的还有<code>performSelector:onThread:withObject:afterDelay:</code>，只是它会在另一个线程的RunLoop中创建一个Timer），所以此方法事实上在任务执行完之前会对触发对象形成引用，任务执行完进行释放（例如上面会对ViewController形成引用，注意：<code>performSelector: withObject:</code>等方法则等同于直接调用，原理与此不同，使用的是<code>objc_msgSend</code>）。</li>
</ul>
<blockquote>
<p>CADisplayLink是一个执行频率（fps）和屏幕刷新相同（可以修改preferredFramesPerSecond改变刷新频率）的定时器，它也需要加入到RunLoop才能执行。与NSTimer类似，CADisplayLink同样是基于CFRunloopTimerRef实现，底层使用mk_timer（可以比较加入到RunLoop前后RunLoop中timer的变化）。和NSTimer相比它精度更高（尽管NSTimer也可以修改精度），不过和NStimer类似的是如果遇到大任务它仍然存在丢帧现象。通常情况下CADisaplayLink用于构建帧动画，看起来相对更加流畅，而NSTimer则有更广泛的用处。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">RunLoop探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-15 06:41:05" itemprop="dateCreated datePublished" datetime="2017-06-15T06:41:05+08:00">2017-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RunLoop顾名思义就是运行循环，来保证程序一直处于程序运行状态。</p>
<p>在iOS中，RunLoop有很多应用，比如：</p>
<ul>
<li>定时器(Timer)、PerformSelector</li>
<li>GCD、Async Main Quene</li>
<li>事件响应、手势识别、界面刷新</li>
<li>网络请求</li>
<li>AutoreleasePool</li>
</ul>
<p>这些技术底层都会用到RunLoop。</p>
<p>在iOS项目汇总<code>main</code>函数中都会这样写道：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UIApplicationMain()</code>函数中内部就会为主线程创建一个RunLoop。对于iOS程序，RunLoop也是非常重要的，比如：</p>
<ul>
<li>保持程序的持续运行</li>
<li>处理App中各种事件(比如触摸事件、定时器事件)</li>
<li>节省CPU资源，提高程序性能：该处理事件时唤醒，不处理时wait。</li>
</ul>
<h2 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h2><p>iOS中有2套API可以访问和使用RunLoop</p>
<ul>
<li>Foundation: NSRunLoop</li>
<li>Core Foundation: CFRunLoopRef</li>
</ul>
<p><code>NSRunLoop</code>是基于<code>CFRunLoopRef</code>的一层OC包装</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *currentRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="comment">//获取主线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">NSRunLoop</span> *mainRunLoop = [<span class="built_in">NSRunLoop</span> mainRunLoop];</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="comment">//获取主线程的RunLoop对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop与线程"><a href="#RunLoop与线程" class="headerlink" title="RunLoop与线程"></a>RunLoop与线程</h2><p>RunLoop和线程有这密切的关系</p>
<ul>
<li>每条线程都有唯一的一个与之对应的RunLoop对象</li>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key, RunLoop作为value</li>
<li>线程刚创建时并没有RunLoop对象，RunLoop会在第一次获取它时创建</li>
<li>RunLoop会在线程结束时销毁</li>
<li>主线程的RunLoop已经自动获取（创建），子线程默认没有开启RunLoop。</li>
</ul>
<p>对于上述的这些关系，我们可以在开源的Core Foundation中窥见一二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CFRunLoop.c</span></span><br><span class="line"><span class="comment">// 代码已经简化</span></span><br><span class="line"></span><br><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    <span class="keyword">if</span> (rl) <span class="keyword">return</span> rl;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123; </span><br><span class="line">  <span class="comment">// 在全局RunLoop字典 __CFRunLoops 中，以线程作为key，获取RunLoop</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">  <span class="comment">// 如果loop为空</span></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">    <span class="comment">//则新创建loop</span></span><br><span class="line">    CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">    <span class="comment">//以线程作为key，存入全局RunLoop字典中</span></span><br><span class="line">    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">    loop = newLoop;</span><br><span class="line">    CFRelease(newLoop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RunLoop相关的类"><a href="#RunLoop相关的类" class="headerlink" title="RunLoop相关的类"></a>RunLoop相关的类</h2><p>Core Foundation中关于RunLoop的5个类</p>
<ul>
<li><code>CFRunLoopRef</code></li>
<li><code>CFRunLoopModeRef</code></li>
<li><code>CFRunLoopSourceRef</code></li>
<li><code>CFRunLoopTimerRef</code></li>
<li><code>CFRunLoopObserverRef</code></li>
</ul>
<p>其中<code>RunLoop</code>的底层结构为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">  <span class="keyword">pthread_t</span> _pthread;                             <span class="comment">//与该Runloop对应的线程</span></span><br><span class="line">  CFMutableSetRef _commonModes;            <span class="comment">//被标记为commonModes的Mode</span></span><br><span class="line">  CFMutableSetRef _commonModeItems;    <span class="comment">//被添加到commonModes的事件源</span></span><br><span class="line">  CFRunLoopModeRef _currentMode;         <span class="comment">//表示该RunLoop中正在运行的Modes</span></span><br><span class="line">  CFMutableSetRef _modes;                     <span class="comment">//CFRunLoopModeRef类型，表示该Runloop中包含的Modes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/Runloop%E7%A4%BA%E6%84%8F%E5%9B%BE.png" class="">

<h3 id="CFRunLoopModeRef"><a href="#CFRunLoopModeRef" class="headerlink" title="CFRunLoopModeRef"></a>CFRunLoopModeRef</h3><p><code>CFRunLoopModeRef</code>的底层结构为:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">  CFStringRef _name;</span><br><span class="line">  CFMutableSetRef _source0;</span><br><span class="line">  CFMutableSetRef _source1;</span><br><span class="line">  CFMutableArrayRef _observers;</span><br><span class="line">  CFMutableArrayRef _timers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>CFRunLoopModeRef代表RunLoop的运行模式</li>
<li>一个RunLoop包含若干个Mode，每个Mode有包含若干个Source0/Source1/Timer/Observer</li>
<li>RunLoop启动时只能选择其中一个Mode,作为currentMode</li>
<li>如果需要切换Mode，只能退出当Loop</li>
<li>不同Mode的Source0/Source1/Timer/Observer能分隔开，互不影响</li>
<li>如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</li>
</ul>
<h4 id="常见的2种Mode"><a href="#常见的2种Mode" class="headerlink" title="常见的2种Mode"></a>常见的2种Mode</h4><p>系统默认提供的Run Loop Modes有:</p>
<ul>
<li><p><strong>kCFRunLoopDefaultMode(NSDefaultRunLoopMode)</strong></p>
</li>
<li><p><strong>UITrackingRunLoopMode</strong></p>
</li>
</ul>
<p>需要切换到对应的Mode时只需要传入对应的名称即可。前者是系统默认的Runloop Mode，例如进入iOS程序默认不做任何操作就处于这种Mode中，此时滑动UIScrollView，主线程就切换Runloop到到UITrackingRunLoopMode，不再接受其他事件操作（除非你将其他Source/Timer设置到UITrackingRunLoopMode下）。</p>
<p>但是对于开发者而言经常用到的Mode还有一个<strong>kCFRunLoopCommonModes（NSRunLoopCommonModes）</strong>,其实这个并不是某种具体的Mode，而是一种模式组合，在iOS系统中默认包含了<strong>NSDefaultRunLoopMode</strong>和<strong>UITrackingRunLoopMode</strong></p>
<p>注意：并不是说Runloop会运行在<strong>kCFRunLoopCommonModes</strong>这种模式下，而是相当于分别注册了<strong>NSDefaultRunLoopMode</strong>和<strong>UITrackingRunLoopMode</strong>。当然你也可以通过调用<strong>CFRunLoopAddCommonMode()**方法将自定义Mode放到</strong>kCFRunLoopCommonModes**组合。</p>
<blockquote>
<p>注意：我们常常还会碰到一些系统框架自定义Mode，例如Foundation中NSConnectionReplyMode。还有一些系统私有Mode，例如：GSEventReceiveRunLoopMode接受系统事件，UIInitializationRunLoopMode App启动过程中初始化Mode。</p>
</blockquote>
<h3 id="Source0-1-amp-Timers-amp-Observer"><a href="#Source0-1-amp-Timers-amp-Observer" class="headerlink" title="Source0/1 &amp; Timers &amp; Observer"></a>Source0/1 &amp; Timers &amp; Observer</h3><ul>
<li>Source0 <ul>
<li>触摸事件的处理</li>
<li><code>performSelector:onThread:</code></li>
</ul>
</li>
<li>Source1<ul>
<li>基于Port的线程间通信</li>
<li>系统事件捕捉，比如点击事件，捕捉后封装成Source0</li>
</ul>
</li>
<li>Timers<ul>
<li>NSTimer</li>
<li><code>performSelector:withObject:aferDelay</code><ul>
<li>内部是用定时器实现</li>
</ul>
</li>
</ul>
</li>
<li>Observer<ul>
<li>用于监听RunLoop的状态</li>
<li>UI刷新(BeforeWaiting，睡眠之前)</li>
<li>Autorelease pool(BeforeWaiting，睡眠之前)</li>
</ul>
</li>
</ul>
<h3 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopObserver &#123;</span><br><span class="line">        <span class="built_in">CFRuntimeBase</span> _base;</span><br><span class="line">        pthread_mutex_t _lock;</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> _runLoop;                            <span class="comment">/* 监听的RunLoop */</span></span><br><span class="line">        <span class="built_in">CFIndex</span> _rlCount;</span><br><span class="line">        <span class="built_in">CFOptionFlags</span> _activities;                    <span class="comment">/* 监听的RunLoop状态 */</span></span><br><span class="line">        <span class="built_in">CFIndex</span> _order;                                            <span class="comment">/* 创建时传入的排序 */</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverCallBack</span> _callout;    <span class="comment">/* 回调 */</span></span><br><span class="line">        <span class="built_in">CFRunLoopObserverContext</span> _context;    <span class="comment">/* 回调参数 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>CFRunLoopObserverRef可以用来监听RunLoop的状态，RunLoop的状态分为以下几种：</p>
<img src="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/Runloop_Activity.png" class="">

<h4 id="创建自定义Observer"><a href="#创建自定义Observer" class="headerlink" title="创建自定义Observer"></a>创建自定义Observer</h4><p>创建自定义Observer有两种方式</p>
<ul>
<li><p>第一种：使用回调函数创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1. 创建observer</span></span><br><span class="line"><span class="comment">// 第一个参数：分配存储空间,使用默认的即可：kCFAllocatorDefault</span></span><br><span class="line"><span class="comment">// 第二个参数：要监听的状态（kCFRunLoopAllActivities）所有的状态</span></span><br><span class="line"><span class="comment">// 第三个参数：是否持续监听</span></span><br><span class="line"><span class="comment">// 第四个参数：优先级,填0即可</span></span><br><span class="line"><span class="comment">// 第五个参数：回调,CFRunLoopObserverCallBack类型,</span></span><br><span class="line"><span class="comment">// typedef void (*CFRunLoopObserverCallBack)(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info);</span></span><br><span class="line"><span class="comment">// 第六个参数：context,回调传参，可以NULL</span></span><br><span class="line"> <span class="built_in">CFRunLoopObserverRef</span> observerRef = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault,</span><br><span class="line">                                                            kCFRunLoopAllActivities,</span><br><span class="line">                                                            <span class="literal">YES</span>,</span><br><span class="line">                                                            <span class="number">0</span>,</span><br><span class="line">                                                            observerCallBack,</span><br><span class="line">                                                            <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 2.将observer添加到RunLoop中,</span></span><br><span class="line"><span class="comment">// kCFRunLoopCommonModes默认包括kCFRunLoopDeaultMode、UITrackingRunLoopMode</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(),</span><br><span class="line">                     observerRef,</span><br><span class="line">                     kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 3. 释放observer</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observerRef);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 回调函数</span></span><br><span class="line"><span class="comment">/// @param observer observer</span></span><br><span class="line"><span class="comment">/// @param activity Loop activity</span></span><br><span class="line"><span class="comment">/// @param info 创建observer时，传入的context</span></span><br><span class="line"><span class="keyword">void</span> observerCallBack(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity, <span class="keyword">void</span> *info) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry,即将进入Loop&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers,即将处理Timer&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources,即将处理Source&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting,即将进入Loop&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting,刚从睡眠中唤醒&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit,即将退出Loop&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二中：使用Block回调创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1. 创建observer</span></span><br><span class="line"><span class="comment">// 第一个参数：分配存储空间,使用默认的即可：kCFAllocatorDefault</span></span><br><span class="line"><span class="comment">// 第二个参数：要监听的状态（kCFRunLoopAllActivities）所有的状态</span></span><br><span class="line"><span class="comment">// 第三个参数：是否持续监听</span></span><br><span class="line"><span class="comment">// 第四个参数：优先级,填0即可</span></span><br><span class="line"><span class="comment">// 第五个参数：block回调</span></span><br><span class="line"><span class="built_in">CFRunLoopObserverRef</span> observerRef = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault,</span><br><span class="line">                                                                      kCFRunLoopAllActivities,</span><br><span class="line">                                                                      <span class="literal">YES</span>,</span><br><span class="line">                                                                      <span class="number">0</span>,</span><br><span class="line">                                                                         ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (activity) &#123;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopEntry:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopEntry,即将进入Loop&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeTimers:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeTimers,即将处理Timer&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeSources:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeSources,即将处理Source&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopBeforeWaiting:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopBeforeWaiting,即将进入Loop&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopAfterWaiting:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopAfterWaiting,刚从睡眠中唤醒&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> kCFRunLoopExit:</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;kCFRunLoopExit,即将退出Loop&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 2.将observer添加到RunLoop中,</span></span><br><span class="line"><span class="comment">// kCFRunLoopCommonModes默认包括kCFRunLoopDeaultMode、UITrackingRunLoopMode</span></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(),</span><br><span class="line">                     observerRef,</span><br><span class="line">                     kCFRunLoopCommonModes);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/// 3. 释放observer</span></span><br><span class="line"><span class="built_in">CFRelease</span>(observerRef);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="RunLoop的运行逻辑"><a href="#RunLoop的运行逻辑" class="headerlink" title="RunLoop的运行逻辑"></a>RunLoop的运行逻辑</h2><img src="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/Runloop%E6%B5%81%E7%A8%8B%E5%9B%BE.png" class="">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们可以在<code>ViewController</code>中<code>viewDidLoad</code>打一个断点，利用lldb指令：bt查看程序调用栈</p>
<img src="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/lldb_bt_demo.png" class="">

<p>可以看出，进入RunLoop逻辑的是<code>CFRunLoopRunSpecific</code>函数。下面是伪代码开始分析：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  CFRunLoopRunSpecific</span></span><br><span class="line">SInt32 <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean returnAfterSourceHandled) &#123;</span><br><span class="line">  <span class="comment">//通过Mode名称 ，获取RunLoop当前的Mode</span></span><br><span class="line">  <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">      </span><br><span class="line">  <span class="comment">//通知observer: 进入Loop</span></span><br><span class="line">  __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//具体要做的事情</span></span><br><span class="line">  result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//通知observer: 退出Loop</span></span><br><span class="line">  __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**__CFRunLoopRun()**：</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> int32_t __CFRunLoopRun(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopModeRef</span> rlm, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle, <span class="built_in">CFRunLoopModeRef</span> previousMode) &#123;</span><br><span class="line"></span><br><span class="line">  int32_t retVal = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 通知observer： 即将处理Timer</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知observer： 即将处理Sources</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知observer： 即将处理block</span></span><br><span class="line">    __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知observer: 处理Source0</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123;</span><br><span class="line">      <span class="comment">// 通知observer： 即将处理block</span></span><br><span class="line">      __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断有无Source1</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, <span class="number">0</span>, &amp;voucherState, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">      <span class="comment">//如果有就跳转到 handle_msg</span></span><br><span class="line">      <span class="keyword">goto</span> handle_msg;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知observer: 即将休眠</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">    __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//等待别的消息来唤醒当前线程，线程阻塞在这里</span></span><br><span class="line">   __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果被唤醒，继续执行</span></span><br><span class="line">    __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">    <span class="comment">// 通知observer: 结束休眠</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">handle_msg:;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 被timer唤醒 */</span>) &#123;</span><br><span class="line">      <span class="comment">//处理timer</span></span><br><span class="line">      __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 被timer唤醒 */</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理GCD</span></span><br><span class="line">      __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 被Source1唤醒 */</span></span><br><span class="line">      <span class="comment">// 处理Source1</span></span><br><span class="line">      __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置返回值</span></span><br><span class="line">    <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">      retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">      retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">      __CFRunLoopUnsetStopped(rl);</span><br><span class="line">      retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">      rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">      retVal = kCFRunLoopRunStopped;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">      retVal = kCFRunLoopRunFinished;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RunLoop-休眠"><a href="#RunLoop-休眠" class="headerlink" title="RunLoop 休眠"></a>RunLoop 休眠</h3><p>其实对于Event Loop而言RunLoop最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。RunLoop的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件Darwin中的Mach来完成的（<a target="_blank" rel="noopener" href="https://opensource.apple.com/">Darwin</a>是开源的）。</p>
<p>Mach是Darwin的核心，可以说是内核的核心，提供了进程间通信（IPC）、处理器调度等基础服务。在Mach中，进程、线程间的通信是以消息的方式来完成的，消息在两个Port之间进行传递（这也正是Source1之所以称之为Port-based Source的原因，因为它就是依靠系统发送消息到指定的Port来触发的）。消息的发送和接收使用&lt;mach/message.h&gt;中的**mach_msg()**函数（事实上苹果提供的Mach API很少，并不鼓励我们直接调用这些API）。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     *    Routine:    mach_msg</span></span><br><span class="line"><span class="comment">     *    Purpose:</span></span><br><span class="line"><span class="comment">     *        Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment">     *        is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment">     *        of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment">     *        operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    __WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line">    <span class="keyword">extern</span> mach_msg_return_t    mach_msg(</span><br><span class="line">                        mach_msg_header_t *msg,</span><br><span class="line">                        mach_msg_option_t option,</span><br><span class="line">                        mach_msg_size_t send_size,</span><br><span class="line">                        mach_msg_size_t rcv_size,</span><br><span class="line">                        mach_port_name_t rcv_name,</span><br><span class="line">                        mach_msg_timeout_t timeout,</span><br><span class="line">                        mach_port_name_t notify);</span><br></pre></td></tr></table></figure>



<p>而<strong>mach_msg()**的本质是一个调用</strong>mach_msg_trap()**,这相当于一个系统调用，会触发内核状态切换。当程序静止时，RunLoop停留在</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy)</span><br></pre></td></tr></table></figure>

<p>而这个函数内部就是调用了**mach_msg()**让程序处于休眠状态。</p>
<img src="/2017/06/15/Runloop%E6%8E%A2%E7%A9%B6/RunLoop%E4%BC%91%E7%9C%A0%E5%8E%9F%E7%90%86.png" class="">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/30/Runtime%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/30/Runtime%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">Runtime常用API总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-30 06:41:05" itemprop="dateCreated datePublished" datetime="2017-05-30T06:41:05+08:00">2017-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h2><h3 id="获取isa指向的Class"><a href="#获取isa指向的Class" class="headerlink" title="获取isa指向的Class"></a>获取isa指向的Class</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class object_getClass(<span class="keyword">id</span> obj);<span class="comment">//其本质是获取isa指针所指向的数据</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class object_getClass(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    object_getClass(id obj);其本质是获取isa指针所指向的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GLStudent *stu = [[GLStudent alloc] init];</span><br><span class="line">Class cls = object_getClass(stu); <span class="comment">//获取的是 GLStudent</span></span><br><span class="line">Class metaCls = object_getClass(cls); <span class="comment">//获取的是GLStudent的元类</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="设置isa指向的Class"><a href="#设置isa指向的Class" class="headerlink" title="设置isa指向的Class"></a>设置isa指向的Class</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls);<span class="comment">//其方法本质就是改变ISA的指向</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class object_setClass(<span class="keyword">id</span> obj, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isFuture()  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(_class_getNonMetaClass(cls, <span class="literal">nil</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> obj-&gt;changeIsa(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person is runing&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLCar</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Car is running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line">[person run]; <span class="comment">//Person is runing</span></span><br><span class="line">        </span><br><span class="line">object_setClass(person, [GLCar <span class="keyword">class</span>]);</span><br><span class="line">[person run]; <span class="comment">//Car is running</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="判断一个OC对象是否为Class"><a href="#判断一个OC对象是否为Class" class="headerlink" title="判断一个OC对象是否为Class"></a>判断一个OC对象是否为Class</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> object_isClass(<span class="keyword">id</span> obj);</span><br><span class="line"><span class="comment">//该方法的本质是判断obj的ISA指向的对象是否是metaClass</span></span><br><span class="line"><span class="comment">// 而判断是否是metaClass的依据是: class_ro_t中的flags</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">object_isClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;isClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">objc_object::isClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> ISA()-&gt;isMetaClass();<span class="comment">//判断该对象的ISA指向的对象是否是mateClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123; </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META; <span class="comment">//是否是mateClass判断的依据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="判断一个Class是否为元类"><a href="#判断一个Class是否为元类" class="headerlink" title="判断一个Class是否为元类"></a>判断一个Class是否为元类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> class_isMetaClass(Class cls);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同上，判断cls是否是元类对象，即判断ro里的flags</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;isMetaClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123; </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data()-&gt;ro-&gt;flags &amp; RO_META; <span class="comment">//是否是mateClass判断的依据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="动态创建、注册、销毁一个类"><a href="#动态创建、注册、销毁一个类" class="headerlink" title="动态创建、注册、销毁一个类"></a>动态创建、注册、销毁一个类</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line">Class objc_allocateClassPair(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t extraBytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册一个类（要在类注册之前添加成员变量）</span></span><br><span class="line"><span class="keyword">void</span> objc_registerClassPair(Class cls);</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个类</span></span><br><span class="line"><span class="keyword">void</span> objc_disposeClassPair(Class cls);</span><br></pre></td></tr></table></figure>

<p><code>OC</code>允许动态注册一个类(指定父类和类名)，Runtime API还可以为这个动态创建的类添加方法、成员变量（需要在注册类之前添加）、属性、协议等等。动态创建类后，需要调用函数注册该类，这样才可以使用。</p>
<p><strong>示例：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 创建一个类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一对类，会将这个类以及这个的元类创建出来</span></span><br><span class="line"><span class="comment"> * 第一个参数：[NSObject class]，指定父类</span></span><br><span class="line"><span class="comment"> * 第二个参数：类名，C语言字符串</span></span><br><span class="line"><span class="comment"> * 第三个参数：额外的存储空间，通常为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class GLDogCls = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;GLDog&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/// 添加成员变量</span></span><br><span class="line"><span class="comment">/// class_addIvar方法只能在 objc_allocateClassPair 之后和 objc_registerClassPair之前调用</span></span><br><span class="line"><span class="comment">/// Ivar在底层类结构中，存储在class_ro_t中，是只读的。</span></span><br><span class="line"><span class="comment">/// 新注册的类(objc_allocateClassPair)，还没有存储到class_ro_t中，</span></span><br><span class="line"><span class="comment">/// objc_registerClassPair 注册之后，class_ro_t数据成形，就不可添加了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个 int 类型的 age 变量</span></span><br><span class="line"><span class="comment"> * 第一个参数：要添加成员变量的类，不能是元类字符串</span></span><br><span class="line"><span class="comment"> * 第二个参数：成员变量的名称，C语言字符串</span></span><br><span class="line"><span class="comment"> * 第三个参数：成员变量的大小</span></span><br><span class="line"><span class="comment"> * 第四个参数：alignment 内存对齐，通常使用 log2(sizeof(point-type)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">BOOL</span> isSuccessAddForAge = class_addIvar(GLDogCls, <span class="string">&quot;_age&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)), <span class="keyword">@encode</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">BOOL</span> isSuccessAddForName = class_addIvar(GLDogCls, <span class="string">&quot;_name&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="keyword">@encode</span>(<span class="built_in">NSString</span> *));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d,%d&quot;</span>,isSuccessAddForAge,isSuccessAddForName);<span class="comment">// 1,1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 添加方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printInfo(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;my name is %@, and I am %@ years old&quot;</span>,</span><br><span class="line">          [<span class="keyword">self</span> valueForKey:<span class="string">@&quot;name&quot;</span>],</span><br><span class="line">          [<span class="keyword">self</span> valueForKey:<span class="string">@&quot;age&quot;</span>]</span><br><span class="line">          );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class_addMethod(GLDogCls, <span class="keyword">@selector</span>(printInfo), (IMP)printInfo, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/// 注册类</span></span><br><span class="line">objc_registerClassPair(GLDogCls);</span><br><span class="line">        </span><br><span class="line"><span class="comment">/// 创建实例，以及属性赋值</span></span><br><span class="line"><span class="keyword">id</span> dogInstance = [[GLDogCls alloc] init];</span><br><span class="line">[dogInstance setValue:@<span class="number">2</span> forKey:<span class="string">@&quot;age&quot;</span>];</span><br><span class="line">[dogInstance setValue:<span class="string">@&quot;Luck&quot;</span> forKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">        </span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">[dogInstance performSelector:<span class="keyword">@selector</span>(printInfo)];<span class="comment">//my name is Luck, and I am 2 years old</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当某个类确定不再使用时，可以使用 objc_disposeClassPair 释放该类</span></span><br><span class="line">objc_disposeClassPair(GLDogCls);</span><br></pre></td></tr></table></figure>

<h2 id="成员变量相关"><a href="#成员变量相关" class="headerlink" title="成员变量相关"></a>成员变量相关</h2><h3 id="获取类中某个成员变量的信息"><a href="#获取类中某个成员变量的信息" class="headerlink" title="获取类中某个成员变量的信息"></a>获取类中某个成员变量的信息</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取类中某个成员变量的信息</span></span><br><span class="line">Ivar class_getInstanceVariable(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取成员变量的相关信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v);</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中某个成员变量的信息</span></span><br><span class="line">Ivar nameIvar = class_getInstanceVariable([GLPerson <span class="keyword">class</span>], <span class="string">&quot;_name&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s %s&quot;</span>,ivar_getName(nameIvar),ivar_getTypeEncoding(nameIvar)); <span class="comment">//_name @&quot;NSString&quot;</span></span><br><span class="line"></span><br><span class="line">Ivar ageIvar = class_getInstanceVariable([GLPerson <span class="keyword">class</span>], <span class="string">&quot;_age&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%s %s&quot;</span>,ivar_getName(ageIvar),ivar_getTypeEncoding(ageIvar)); <span class="comment">//_age i</span></span><br></pre></td></tr></table></figure>

<h3 id="设置和获取成员变量的值"><a href="#设置和获取成员变量的值" class="headerlink" title="设置和获取成员变量的值"></a>设置和获取成员变量的值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置成员变量的值</span></span><br><span class="line"><span class="keyword">void</span> object_setIvar(<span class="keyword">id</span> obj, Ivar ivar, <span class="keyword">id</span> value);</span><br><span class="line"><span class="comment">// 获取成员变量的值</span></span><br><span class="line"><span class="keyword">id</span> object_getIvar(<span class="keyword">id</span> obj, Ivar ivar);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 设置和获取成员变量的值</span></span><br><span class="line">GLPerson *person =  [[GLPerson alloc] init];</span><br><span class="line"><span class="comment">// 设置name的值，不走setter方法</span></span><br><span class="line">object_setIvar(person, nameIvar, <span class="string">@&quot;小李&quot;</span>);</span><br><span class="line"><span class="comment">// 获取name的值，不走getter方法</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,object_getIvar(person, nameIvar)); <span class="comment">//小李</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 基本数据类型写法稍有不同</span></span><br><span class="line"><span class="comment">// 设置age的值</span></span><br><span class="line">object_setIvar(person, ageIvar, (__bridge <span class="keyword">id</span>)(<span class="keyword">void</span> *)<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 获取age的值</span></span><br><span class="line"><span class="keyword">void</span> * ageValue = (__bridge <span class="keyword">void</span> *)(object_getIvar(person, ageIvar));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, (<span class="keyword">int</span>)ageValue);<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝实例变量列表"><a href="#拷贝实例变量列表" class="headerlink" title="拷贝实例变量列表"></a>拷贝实例变量列表</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拷贝实例变量列表(最后需要调用free释放)</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 拷贝实例变量列表(最后需要调用free释放)</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount;</span><br><span class="line">Ivar *ivarList = class_copyIvarList([GLPerson <span class="keyword">class</span>], &amp;ivarCount);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//遍历实例变量列表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">  Ivar ivar = ivarList[i];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;%s %s&quot;</span>,ivar_getName(ivar),ivar_getTypeEncoding(ivar));</span><br><span class="line">&#125;</span><br><span class="line">free(ivarList);</span><br></pre></td></tr></table></figure>

<h2 id="方法相关"><a href="#方法相关" class="headerlink" title="方法相关"></a>方法相关</h2><h3 id="获取一个实例方法、类方法"><a href="#获取一个实例方法、类方法" class="headerlink" title="获取一个实例方法、类方法"></a>获取一个实例方法、类方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取实例方法</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)</span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)</span><br></pre></td></tr></table></figure>

<h3 id="获取方法的相关信息"><a href="#获取方法的相关信息" class="headerlink" title="获取方法的相关信息"></a>获取方法的相关信息</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带有copy的需要调用free去释放</span></span><br><span class="line">SEL method_getName(Method m);</span><br><span class="line"></span><br><span class="line">IMP method_getImplementation(Method m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *method_getTypeEncoding(Method m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments(Method m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *method_copyReturnType(Method m);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *method_copyArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index);</span><br></pre></td></tr></table></figure>

<h3 id="拷贝方法列表"><a href="#拷贝方法列表" class="headerlink" title="拷贝方法列表"></a>拷贝方法列表</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最后需要调用free释放</span></span><br><span class="line">Method *class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount);</span><br></pre></td></tr></table></figure>

<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types);</span><br></pre></td></tr></table></figure>

<h3 id="动态替换方法"><a href="#动态替换方法" class="headerlink" title="动态替换方法"></a>动态替换方法</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types);</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>) run;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>) run &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line">[person run];   <span class="comment">//-[GLPerson run]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用C语言函数替换实现</span></span><br><span class="line"><span class="keyword">void</span> myrun(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;myrun&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">class_replaceMethod([GLPerson <span class="keyword">class</span>], <span class="keyword">@selector</span>(run), (IMP)myrun, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">[person run];   <span class="comment">//myrun</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可使用block替换实现</span></span><br><span class="line">class_replaceMethod([GLPerson <span class="keyword">class</span>], <span class="keyword">@selector</span>(run), imp_implementationWithBlock(^(<span class="keyword">id</span> <span class="keyword">self</span>,SEL _cmd)&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;self is %@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;), <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">[person run]; <span class="comment">//self is &lt;GLPerson: 0x1007b85f0&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="方法操作相关"><a href="#方法操作相关" class="headerlink" title="方法操作相关"></a>方法操作相关</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取cls中,sel的实现</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name);</span><br><span class="line"><span class="comment">//设置方法新的实现</span></span><br><span class="line">IMP method_setImplementation(Method m, IMP imp);</span><br><span class="line"><span class="comment">//交换两个方法实现</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2); </span><br></pre></td></tr></table></figure>

<p>其中<code>method_exchangeImplementations()</code>交换两个方法实现在iOS框架中应用的很广。比如：</p>
<h4 id="示例1，UIButton事件点击全埋点"><a href="#示例1，UIButton事件点击全埋点" class="headerlink" title="示例1，UIButton事件点击全埋点"></a>示例1，<code>UIButton</code>事件点击全埋点</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIControl</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Method oldMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(sendAction:to:forEvent:));</span><br><span class="line">    Method newMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(gl_sendAction:to:forEvent:));</span><br><span class="line">    method_exchangeImplementations(oldMethod, newMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)gl_sendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果是按钮</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isKindOfClass:[<span class="built_in">UIButton</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//其他处理，埋点</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;action=%@,target=%@&quot;</span>,<span class="built_in">NSStringFromSelector</span>(action),target);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用系统原有的实现</span></span><br><span class="line">    [<span class="keyword">self</span> gl_sendAction:action to:target forEvent:event];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>UIButton</code>继承自<code>UIControl</code>，通过<code>addTarget-Selector</code>添加点击事件后，都会来到<code>sendAction:to:forEvent:</code>方法。所以可以通过方法交换的方式来达到<strong>hook</strong>的方式。</p>
<p>示例中，还有一个点，调用系统原有实现时，调用了<code>gl_sendAction:to:forEvent:</code>。字面上看造成了死循环其实不然，我们通过下面的图来解释。</p>
<p><strong>方法没有交换前</strong></p>
<p><code>@selector(sendAction:to:forEvent:)</code>可以找到<code>sendAction:to:forEvent:</code>的实现。</p>
<p><code>@selector(gl_sendAction:to:forEvent:)</code>可以找到<code>gl_sendAction:to:forEvent:</code>的实现。</p>
<img src="/2017/05/30/Runtime%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/before_exchange.png" class="">

<p><strong>实现交换后</strong></p>
<img src="/2017/05/30/Runtime%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93/after_exchange.png" class="">

<p>**所以系统内部调用<code>sendAction:to:forEvent:</code>时，会来到<code>gl_sendAction:to:forEvent:</code>的实现。当我们调用系统原有的实现就要调用<code>gl_sendAction:to:forEvent:</code>**。</p>
<h4 id="示例2，NSArray防止崩溃"><a href="#示例2，NSArray防止崩溃" class="headerlink" title="示例2，NSArray防止崩溃"></a>示例2，NSArray防止崩溃</h4><p>我们都知道数组是不可以添加<code>nil</code>的，否则会发生崩溃</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">NSObject</span> *obj = <span class="literal">nil</span>;</span><br><span class="line">[array addObject:obj];</span><br></pre></td></tr></table></figure>

<p>crash信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">*** Terminating app due to uncaught exception <span class="string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="string">&#x27;*** -[__NSArrayM insertObject:atIndex:]: object cannot be nil&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从这我们可以看出，<code>addObjcect:</code>方法最后调用了<code>insertObject:atIndex:</code>。NSMutableArray的类并不是我们看到的NSMutableArray,而是__NSArrayM 。这是因为<code>Foundation framewor</code>k框架下广泛使用了<strong>类簇</strong>的设计模式。它管理了一组隐藏在公共抽象父类下的具体私有子类。</p>
<p>在Cocoa中，实际上许多类都是以类簇的方式实现的，即它们是一群隐藏在通用接口之下与实现相关的类。例如创建数组时可能是<code>__NSArray0</code>,<code>__NSSingleObjectArray</code>, <code>__NSArrayI</code>，所以请不要轻易尝试创建<code>NSString</code>，<code>NSArray</code>,<code>NSDictionary</code>的子类。对类簇使用<code>isKindOfClass</code>和<code>isMemberOfClass</code>的结果可能是不正确的。因为类簇是由公共抽象类管理的一组私有类，公共抽象类并不是实例对应的真正的类，类簇中真正的类的从属关系被隐藏了。</p>
<p>所以要对<code>NSMutableArray</code>操作，选择的类是<code>__NSArrayM</code></p>
<p>这里要对<code>insertObject:atIndex:</code>添加非空判断。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableArray</span> (<span class="title">Extension</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Class cls = <span class="built_in">NSClassFromString</span>(<span class="string">@&quot;__NSArrayM&quot;</span>);</span><br><span class="line">    Method old = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(insertObject:atIndex:));</span><br><span class="line">    Method new = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(gl_insertObject:atIndex:));</span><br><span class="line">    method_exchangeImplementations(old, new);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)gl_insertObject:(<span class="keyword">id</span>)anObject atIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (!anObject) <span class="keyword">return</span>;</span><br><span class="line">    [<span class="keyword">self</span> gl_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="选择器相关"><a href="#选择器相关" class="headerlink" title="选择器相关"></a>选择器相关</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sel_getName(SEL sel)</span><br><span class="line">SEL sel_registerName(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span><br></pre></td></tr></table></figure>

<h3 id="用block作为方法实现"><a href="#用block作为方法实现" class="headerlink" title="用block作为方法实现"></a>用block作为方法实现</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">IMP imp_implementationWithBlock(<span class="keyword">id</span> block);</span><br><span class="line"><span class="keyword">id</span> imp_getBlock(IMP anImp);</span><br><span class="line"><span class="built_in">BOOL</span> imp_removeBlock(IMP anImp);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/12/Super%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/05/12/Super%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">Super探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-05-12 06:41:05" itemprop="dateCreated datePublished" datetime="2017-05-12T06:41:05+08:00">2017-05-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Super的本质"><a href="#Super的本质" class="headerlink" title="Super的本质"></a>Super的本质</h2><p><code>super</code>方法调用如果转为<code>C++</code>代码可以看到被转成了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSendSuper()方法调用。</span><br></pre></td></tr></table></figure>

<p>该方法需要两个参数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个参数：是一个objc_super的结构体。该结构体有两个成员。</span></span><br><span class="line"><span class="keyword">struct</span> objc_super &#123;</span><br><span class="line">  <span class="keyword">id</span> receiver; <span class="comment">//消息接受者</span></span><br><span class="line">  Class cls;    <span class="comment">// 消息接受者的父类，方法查找从该类开始。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个参数：是调用的方法</span></span><br><span class="line"><span class="keyword">@selector</span>(method_name);</span><br></pre></td></tr></table></figure>

<p>可以看到<code>super</code>是通过<code>objc_msgSendSuper</code>发送消息，其中消息接收者还是self。然后要发送的消息是从父类中开始查找，而不是跟往常一样从当前对象查找。</p>
<p><strong>例如：</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLStudent</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run &#123;</span><br><span class="line">    [<span class="keyword">super</span> run];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GLStudent run&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>转化为C++代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __rw_objc_super arg = &#123;</span><br><span class="line">        <span class="keyword">self</span>,<span class="comment">//消息接收者</span></span><br><span class="line">        class_getSuperclass(objc_getClass(<span class="string">&quot;GLStudent&quot;</span>))</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">objc_msgSendSuper(</span><br><span class="line">                  arg,</span><br><span class="line">                  sel_registerName(<span class="string">&quot;run&quot;</span>)</span><br><span class="line">                   );</span><br></pre></td></tr></table></figure>

<p>有些时候转换的C++代码只能作为一个参考，真正的底层调用还要从汇编的角度分析。</p>
<p>从汇编角度看，super方法调用被转换成了<code>objc_msgSendSuper2()</code>,<code>objc_msgSendSuper2()</code>由汇编实现。描述是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSendSuper2(<span class="keyword">struct</span> objc_super2 *<span class="keyword">super</span>, SEL op, ...)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">struct</span> objc_super2 &#123;</span><br><span class="line">    <span class="keyword">id</span> receiver;  <span class="comment">// 消息接收者</span></span><br><span class="line">    Class current_class;  <span class="comment">// receiverClass（消息接收者的class对象）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管第一个参数发生了变化，其实无非实在<code>objc_msgSendSuper2()</code> 内部，根据<code>current_class</code>获取了superClass。之后的逻辑与<code>objc_msgSendSuper()</code>是一样的</p>
<h2 id="self-class-与-super-class"><a href="#self-class-与-super-class" class="headerlink" title="[self class] 与 [super class]"></a>[self class] 与 [super class]</h2><p>关于Runtime有一道很经典的题目：</p>
<ul>
<li><p>打印结果是什么呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLStudent</span> : <span class="title">GLPerson</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>,[<span class="keyword">self</span> <span class="keyword">class</span>]); <span class="comment">//GLStudent</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>,[<span class="keyword">self</span> superclass]); <span class="comment">//GLPerson</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>,[<span class="keyword">super</span> <span class="keyword">class</span>]); <span class="comment">//GLStudent</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>,[<span class="keyword">super</span> superclass]); <span class="comment">//GLPerson</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>[super class]</code>输出的是<code>GLStudent</code>，</p>
<p><code>[super superClass]</code>输出的是<code>GLPerson</code>。</p>
<p>这两个方法的输出与<code>self</code>调用输出无异。根据<code>Super</code>的底层原理可知:</p>
<ul>
<li>虽然使用<code>super</code>调用，但消息接受者仍然是<code>self</code>，只不过方法查找是在父类中开始查找。</li>
<li><code>class</code>方法与<code>superClass</code>方法，都是<code>NSObject</code>中实现的。所以无论调用者是谁，最终都是在<code>NSObject</code>中找到的方法。</li>
</ul>
<p>所以<code>[self class]</code>与<code>[super class]</code>调用结果都是一样的，<code>[self superClass]</code>与<code>[super superClass]</code>也同理。</p>
<h2 id="isKindOfClass-amp-isMemberOfClass"><a href="#isKindOfClass-amp-isMemberOfClass" class="headerlink" title="isKindOfClass &amp; isMemberOfClass"></a>isKindOfClass &amp; isMemberOfClass</h2><p><code>isKindOfClass</code>与<code>isMemberOfClass</code>是两个常用的方法，又因为语义相近常常容易混淆。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>isKindOfClass</code>:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只要能通过该对象<code>superclass</code>链能找到<code>cls</code>，就会返回<code>YES</code>。反之，则返回<code>NO</code>。</strong></p>
</li>
<li><p><code>isMemberOfClass</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>直接作比较，看是否相等。</strong></p>
<p><code>isKindOfClass</code>和<code>isMemberOfClass</code>的类方法中都用到了<code>object_getClass()</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class object_getClass(<span class="keyword">id</span> obj) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出，<code>object_getClass()</code>获取的是obj的<code>isa</code>指针。实例对象获取的是类对象，类对象获取的是元类对象。</p>
<img src="/2017/05/12/Super%E6%8E%A2%E7%A9%B6/isa_%E8%B5%B0%E4%BD%8D%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="">

<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.[NSObject class]获取了基类对象，+isKindOfClass方法中，匹配时会获取[NSObject class]的isa指针获取NSObject的元类对象</span></span><br><span class="line"><span class="comment">2. NSObject的元类对象的superclass指针又指向[NSObjcet class]，故返回YES.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">BOOL</span> ret1 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]; <span class="comment">//YES</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">最终比较的是，NSObject的类对象和NSObjcet的元类对象是否相等，故返回NO</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">BOOL</span> ret2 = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]]; <span class="comment">//NO</span></span><br><span class="line"><span class="built_in">BOOL</span> ret3 = [[GLPerson <span class="keyword">class</span>] isKindOfClass:[GLPerson <span class="keyword">class</span>]]; <span class="comment">//NO</span></span><br><span class="line"><span class="built_in">BOOL</span> ret4 = [[GLPerson <span class="keyword">class</span>] isMemberOfClass:[GLPerson <span class="keyword">class</span>]]; <span class="comment">//NO</span></span><br></pre></td></tr></table></figure>

<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><img src="/2017/05/12/Super%E6%8E%A2%E7%A9%B6/super_%E9%9D%A2%E8%AF%95%E9%A2%98.png" class="">

<p>可以运行，运行的结果类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my name is &lt;ViewController: 0x7f88dbc055c0&gt;</span><br></pre></td></tr></table></figure>

<img src="/2017/05/12/Super%E6%8E%A2%E7%A9%B6/super_%E9%9D%A2%E8%AF%95%E9%A2%98_demo1.png" class="">

<img src="/2017/05/12/Super%E6%8E%A2%E7%A9%B6/super_%E9%9D%A2%E8%AF%95%E9%A2%98_demo2.png" class="">
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">msgSend探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-28 16:38:10" itemprop="dateCreated datePublished" datetime="2017-04-28T16:38:10+08:00">2017-04-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OC中的方法调用，其实都是转换为<code>objc_megSend</code>函数调用。</p>
<p><strong>objc_megSend</strong>的执行流程可以分为3大阶段</p>
<ul>
<li><strong>消息发送</strong>，如果消息发送成功，则调用相关方法。如果失败进入下一阶段。</li>
<li><strong>动态方法解析</strong>，如果成功，则调用相关方法。如果失败进入下一阶段。</li>
<li><strong>消息转发</strong>，如果失败则会”报找不到方法错误”</li>
</ul>
<h2 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h2><img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81.png" class="">

<h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90.png" class="">

<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><p>当消息发送进入动态方法解析阶段，调用<code>+resolveInstanceMethod:</code>或<code>+resolveClassMethod:</code>方法时，可以在此时动态的添加方法。</p>
<p>有两种动态添加方法的方式。</p>
<ol>
<li><p>动态其他OC方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>) abc;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLPerson</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) other &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(abc)) &#123;</span><br><span class="line">          <span class="comment">//将other方法的实现添加。Method可以理解为等价于struct method_t *</span></span><br><span class="line">        Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(other));</span><br><span class="line">        class_addMethod(<span class="keyword">self</span>,</span><br><span class="line">                        sel,</span><br><span class="line">                        method_getImplementation(method),</span><br><span class="line">                        method_getTypeEncoding(method));</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//// ===== main</span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line">        [person abc];</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序输出：</span></span><br><span class="line"><span class="comment">//xxxx[32879:4618952] abc</span></span><br><span class="line"><span class="comment">//xxxx[32879:4618952] -[GLPerson other]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>动态添加C语言函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface GLPerson : NSObject</span><br><span class="line">- (void) abc;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">#import &lt;objc&#x2F;runtime.h&gt;</span><br><span class="line">@implementation GLPerson</span><br><span class="line"></span><br><span class="line">- (void) other &#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(_cmd));</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel &#x3D;&#x3D; @selector(abc)) &#123;</span><br><span class="line">          class_addMethod(self,</span><br><span class="line">                        sel,</span><br><span class="line">                        &#x2F;* C语言的函数名就是函数地址 *&#x2F;</span><br><span class="line">                        (IMP)other,</span><br><span class="line">                        &quot;v16@0:8&quot;);</span><br><span class="line">        return  YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D; main</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        GLPerson *person &#x3D; [[GLPerson alloc] init];</span><br><span class="line">        [person abc];</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;程序输出：</span><br><span class="line">&#x2F;&#x2F;abc</span><br><span class="line">&#x2F;&#x2F;self&#x3D;&lt;GLPerson: 0x10301a950&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="消息转发流程"><a href="#消息转发流程" class="headerlink" title="消息转发流程"></a>消息转发流程</h2><p>消息转发，顾名思义就是将消息转发给别的对象。</p>
<p>当方法调用来到消息转发阶段：</p>
<img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91.png" class="">

<ul>
<li><p>会先调用<code>-forwardingTargetForSelector:</code>或者<code>+forwardingTargetForSelector:</code>方法。</p>
<ul>
<li><p>如果返回值不为<code>nil</code>，则<code>objc_msgSend(返回值,sel)</code>。</p>
</li>
<li><p>如果返回值为<code>nil</code>或者没有实现，则进入第二个步骤</p>
</li>
<li><p>实例对象调用<code>-forwardingTargetForSelector:</code>，类对象调用<code>+forwardingTargetForSelector:</code></p>
<img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/forwardingTargetForSelector_demo.png" class="">
</li>
</ul>
</li>
<li><p>如果返回值为<code>nil</code>,则会调用<code>-methodSignatureForSelector:</code>或者<code>+methodSignatureForSelector:</code>，该方法要求返回一个方法签名。</p>
<ul>
<li><p>如果返回<code>nil</code>，则会调用<code>doesNotRecognizeSelector:</code>抛出异常错误。</p>
</li>
<li><p>如果返回值不为<code>nil</code>，则进入下一步骤</p>
<img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/methodSignatureForSelector_demo.png" class="">
</li>
</ul>
</li>
<li><p><code>methodSignatureForSelector:</code>返回值不为<code>nil</code>,则调用<code>forwardInvocation:</code>，这个方法中可以进行任意操作。并且也不会导致崩溃。</p>
<img src="/2017/04/28/msgSend%E6%8E%A2%E7%A9%B6/forwardInvocation_demo.png" class="">



</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/" class="post-title-link" itemprop="url">Class结构探究</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-25 16:38:10" itemprop="dateCreated datePublished" datetime="2017-04-25T16:38:10+08:00">2017-04-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Class的结构"><a href="#Class的结构" class="headerlink" title="Class的结构"></a>Class的结构</h2><img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/class_struct.png" class="">

<p>iOS中<code>Class</code>的定义</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>Class的底层结构为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">    Class isa;</span><br><span class="line">    Class superclass;</span><br><span class="line">    chache_t cache; <span class="comment">//方法缓存</span></span><br><span class="line">    class_data_bits_t bits; <span class="comment">//用于获取具体的类信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>bits</code>可以通过<code>data()</code>方法获取到具体的类型信息：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">      class_rw_t *data() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123; </span><br><span class="line">        class_rw_t* data() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="class-rw-t"><a href="#class-rw-t" class="headerlink" title="class_rw_t"></a>class_rw_t</h2><p>其中<code>class_rw_t</code>类型一般保存中类的可读可写信息(rw):</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro; <span class="comment">//保存类的原始信息(只读信息，ro = readonly)</span></span><br><span class="line"></span><br><span class="line">    method_array_t methods; <span class="comment">//方法列表</span></span><br><span class="line">    property_array_t properties; <span class="comment">//属性类表</span></span><br><span class="line">    protocol_array_t protocols; <span class="comment">//协议列表</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>class_rw_t</code>里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p>
<img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/class_rw_t.png" class="">

<h2 id="class-ro-t"><a href="#class-ro-t" class="headerlink" title="class_ro_t"></a>class_ro_t</h2><p><code>class_ro_t</code>里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含类的初始内容。</p>
<img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/class_ro_t.png" class="">

<h2 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h2><p><strong>method_t</strong>是对方法、函数的封装</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;      <span class="comment">//函数名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;  <span class="comment">//编码（返回值类型、参数类型）</span></span><br><span class="line">    IMP imp;  <span class="comment">//指向函数的指针（函数地址）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IMP</strong>代表函数的具体实现：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> _Nullable (*IMP)(<span class="keyword">id</span> _Nonnull, SEL _Nonnull, ...); </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>SEL</strong>代表方法、函数名，一般叫做选择器，底层结构跟<code>char *</code>类似<ul>
<li>可以通过<code>@selector()</code>和<code>sel_registerName()</code>获得</li>
<li>可以通过<code>sel_getName()</code>和<code>NSStringFromSelector()</code>转成字符串</li>
<li>不同类中相同名字的方法，所对应的方法选择器是相同的</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0x1d1834e41 0x1d1834e41 地址相同,所以@selector与sel_registerName获取的都是相同的</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>,<span class="keyword">@selector</span>(test),sel_registerName(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>types</strong>包含了函数的返回值、参数编码的字符串。</p>
<img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/type_encoding.png" class="">

</li>
</ul>
<p>以比较常见的AppDelegate类来说明</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AppDelegate</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>其底层的结构数据为：</p>
<img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/appdelegate_class_rw_t_methods.png" class="">

<p>其中types为<code>B32@0:8@16@24</code></p>
<img src="/2017/04/25/Class%E7%BB%93%E6%9E%84%E6%8E%A2%E7%A9%B6/appdelegate_class_rw_t_methods_types.png" class="">

<h2 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/isa%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/08/isa%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">isa详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-08 16:38:10" itemprop="dateCreated datePublished" datetime="2017-04-08T16:38:10+08:00">2017-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>isa</code>指针是Runtime中非常重要的一个结构体，也是非常常用的一个数据结构。</p>
<p>在<strong>arm64</strong>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>Class</code>,<code>Meta-Class</code>对象的内存地址。</p>
<p>从<strong>arm64</strong>架构开始，对<code>isa</code>进行了优化，变成了一个共用体(<code>union</code>)结构，还使用位域来存储更多的信息。</p>
<h3 id="isa的结构"><a href="#isa的结构" class="headerlink" title="isa的结构"></a>isa的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">  Class cls;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><strong>nonpointer</strong>：</p>
<ul>
<li>0，代表普通指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><p><strong>has_assoc</strong>：</p>
<ul>
<li>是否<strong>设置过</strong>关联对象，如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>has_cxx_dtor</strong>：</p>
<ul>
<li>是否有C++的析构函数(.cxx_destruct),如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>shiftcls</strong>：</p>
<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
</ul>
</li>
<li><p><strong>magic</strong></p>
<ul>
<li>用于调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><p><strong>weakly_referenced</strong>：</p>
<ul>
<li>是否又被弱引用指向过，如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>deallocating</strong></p>
<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><p><strong>extra_rc</strong></p>
<ul>
<li>里面存储的值是<strong>引用计数器 - 1</strong></li>
</ul>
</li>
<li><p><strong>has_sidetable_rc</strong></p>
<ul>
<li>引用计数是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dev.Gao</p>
  <div class="site-description" itemprop="description">人类的本能是胆怯，但人类的本质是不甘心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dev.Gao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
