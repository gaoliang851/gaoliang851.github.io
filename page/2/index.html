<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:type" content="website">
<meta property="og:title" content="Dev.Gao的学习笔记">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Dev.Gao的学习笔记">
<meta property="og:description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dev.Gao">
<meta property="article:tag" content="iOS,Android,Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dev.Gao的学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dev.Gao的学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">多线程学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-05 21:11:34" itemprop="dateCreated datePublished" datetime="2021-08-05T21:11:34+08:00">2021-08-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/03/Realm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/03/Realm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Realm学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-03 14:44:57" itemprop="dateCreated datePublished" datetime="2020-08-03T14:44:57+08:00">2020-08-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">数据持久化</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>TODO：<a target="_blank" rel="noopener" href="https://realm.io/cn/docs/objc/latest/#%E6%9F%A5%E8%AF%A2">https://realm.io/cn/docs/objc/latest/#%E6%9F%A5%E8%AF%A2</a></p>
</blockquote>
<h2 id="Realm打开和配置"><a href="#Realm打开和配置" class="headerlink" title="Realm打开和配置"></a>Realm打开和配置</h2><h3 id="获取数据库实例"><a href="#获取数据库实例" class="headerlink" title="获取数据库实例"></a>获取数据库实例</h3><ul>
<li><p>默认数据库实例</p>
<p>这种方式获取的数据库实例即为默认实例，即采用的默认配置的数据库</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认数据库配置</span></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration]</span><br><span class="line"><span class="comment">//默认数据库实例</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置数据库</p>
<ul>
<li><p>用户机制，不用用户使用不用数据库</p>
<blockquote>
<p>如果配置的路径中，包含不存在的目录会报错，如果没有数据库文件则会自动创建</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过不同用户来配置不同的URL，来实现不同的用户使用不用的数据库</span></span><br><span class="line"><span class="built_in">NSString</span> *documentPath = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>,<span class="built_in">NSUserDomainMask</span>,<span class="literal">YES</span>)lastObject];</span><br><span class="line"><span class="comment">// /Documents/userName.realm</span></span><br><span class="line"><span class="built_in">NSString</span> *dbFileUrl = [[documentPath stringByAppendingPathComponent:<span class="string">@&quot;userName&quot;</span>] stringByAppendingPathExtension:<span class="string">@&quot;realm&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过配置来设置url</span></span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:dbFileUrl];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过RLMRealmConfiguration初始化Realm</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过URL初始化Realm</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithURL:[<span class="built_in">NSURL</span> fileURLWithPath:dbFileUrl]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库设置只读属性，<strong>如果对设置readOnly的数据库，提交写入事务会崩溃抛出异常</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@&quot;222&quot;</span> withExtension:<span class="string">@&quot;realm&quot;</span>];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.fileURL = url;</span><br><span class="line"></span><br><span class="line">config.readOnly = <span class="literal">YES</span>;<span class="comment">//设置只读属性</span></span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>假如获取 Bundle中的数据库：</p>
<p><code>[[NSBundle mainBundle] URLForResource:@&quot;222&quot; withExtension:@&quot;realm&quot;]</code></p>
<p>程序包的数据文件虽然是只读的，但没有设置<code>readOnly</code>属性，向数据库中添加数据，也可以添加成功并查询出结果。但是程序重启后，添加的数据就消失了。</p>
<p>猜测是：</p>
<ol>
<li>将Bundle中的数据库拷贝出来一份临时数据库文件，重启时删除这个临时文件</li>
<li>将Bundle中的数据库加载到了内存中，后续的数据修改并没有落盘。</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li><p>使用内存数据库</p>
<p>通过设置<code>RLMRealmConfiguration</code>的<code>inMemoryIdentifier</code>属性，来配置运行在内存中的数据库。<code>fileURL</code>会被置为<code>nil</code>(反之亦然)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line">config.inMemoryIdentifier = <span class="string">@&quot;MyInMemoryRealm&quot;</span>;</span><br><span class="line">RLMRealm *realm = [RLMRealm realmWithConfiguration:config error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p> 出于内部操作等因素的考量，除了正常的 <code>.realm</code> 文件之外，Realm 还会生成辅助文件。</p>
<blockquote>
<ul>
<li><code>.realm.lock</code> - 资源锁定文件；</li>
<li><code>.realm.management</code> - 存放进程锁文件的目录；</li>
<li><code>.realm.note</code> - 用于通知的命名管道。</li>
</ul>
</blockquote>
<p>应当将 Realm辅助文件连同 Realm 文件一起删除，以完全清除所有的相关文件。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里进行所有的 Realm 操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSFileManager</span> *manager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *realmFileURLs = @[</span><br><span class="line">    config.fileURL,</span><br><span class="line">    [config.fileURL URLByAppendingPathExtension:<span class="string">@&quot;lock&quot;</span>],</span><br><span class="line">    [config.fileURL URLByAppendingPathExtension:<span class="string">@&quot;note&quot;</span>],</span><br><span class="line">    [config.fileURL URLByAppendingPathExtension:<span class="string">@&quot;management&quot;</span>]</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSURL</span> *URL <span class="keyword">in</span> realmFileURLs) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    [manager removeItemAtURL:URL error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单的数据操作"><a href="#简单的数据操作" class="headerlink" title="简单的数据操作"></a>简单的数据操作</h2><h3 id="创建RLMObject对象"><a href="#创建RLMObject对象" class="headerlink" title="创建RLMObject对象"></a>创建<code>RLMObject</code>对象</h3><h4 id="如何创建一个RLMRealm模型"><a href="#如何创建一个RLMRealm模型" class="headerlink" title="如何创建一个RLMRealm模型"></a>如何创建一个<code>RLMRealm</code>模型</h4><p>创建数据模型，继承自<code>RLMObject</code>对象</p>
<ul>
<li><p>通过插件创建的<code>RLMObject</code>子对象，会自动声明<code>RLM_ARRAY_TYPE(ClassName)</code></p>
</li>
<li><p>对象的属性，<strong>不要声明</strong>内存管理属性</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span>:<span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RML_ARRAY_TYPE(Student)  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="RLMRealm对象的初始化"><a href="#RLMRealm对象的初始化" class="headerlink" title="RLMRealm对象的初始化"></a><code>RLMRealm</code>对象的初始化</h4><p>新建<code>RLMRealm</code>对象的方式一般有三种</p>
<ol>
<li><p>通过字典来创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">12</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;小王&quot;</span>&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过数组来创建，<strong>数组值的顺序要和模型中声明的顺序一致</strong>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] initWithValue:@[@<span class="number">12</span>,<span class="string">@&quot;小王&quot;</span>]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用<code>setter</code>方法来赋值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu.age = <span class="number">12</span>;</span><br><span class="line">stu.name = <span class="string">@&quot;小王&quot;</span>;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>对<code>Realm</code>数据库进行添加、移除、创建操作，都要在写入事务(<code>write transaction</code>)中进行，否则会崩溃报错。</p>
<p>添加数据的方式有3种:</p>
<p>第一种：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];<span class="comment">//获取数据库实例</span></span><br><span class="line">[realm beginWriteTransaction];<span class="comment">//开启写入事务</span></span><br><span class="line">[realm addObject:stu];<span class="comment">//添加模型对象</span></span><br><span class="line">[realm commitWriteTransaction];<span class="comment">//提交写入事务</span></span><br></pre></td></tr></table></figure>

<p>第二种：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm addObject:stu];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>第三种:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [Student createInRealm:realm withValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">12</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;小王&quot;</span>&#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p><code>Realm</code>更新数据可以通过直接更新对象的属性值来直接达到更新模型的目的</p>
<p>更新数据的方式一共有三种：</p>
<p>第一种：<strong>对于已经被<code>Realm</code>管理的对象模型，可以在事务中直接更改</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu = [[Student alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">12</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;小王&quot;</span>&#125;];</span><br><span class="line"><span class="comment">//此时，stu对象已经被realm管理，而且stu已经和磁盘上的对象进行了地址映射</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm addObject:stu];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//这里修改的模型，一定是被realm所管理的模型</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        stu.age = <span class="number">14</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>第二种：<strong>根据主键进行更新</strong></p>
<blockquote>
<p>主键（Primary key）：主关键字，作表的行的唯一标识的候选关键字，它的值用于唯一地标识表中的某一条记录</p>
</blockquote>
<blockquote>
<p>使用该方法有一个前提，模型必须实现<code>+ (NSString *)primaryKey</code> 返回主键</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Student 的主键为 age,此时Realm数据库中已经包含一条 Student[age=12,name=小王] 的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu = [[Student alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">12</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;小李&quot;</span>&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为每一条记录的主键是唯一的，[RLMRealm addOrUpdateObject:]会根据主键查询，存在就更新，不存在就添加</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">   [realm addOrUpdateObject:stu];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>第三种：<strong>根据主键进行更新，使用类方法直接在事务中<code>addOrUpdate</code></strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [Student createOrUpdateInRealm:realm withValue:@[@<span class="number">14</span>,<span class="string">@&quot;大鸡儿&quot;</span>]];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>场景1： <strong>根据主键删除一个模型</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="comment">// 1. 根据主键, 查询到这个模型(这个模型, 就是被realm数据库管理的模型)</span></span><br><span class="line">Student *stu = [Student objectForPrimaryKey:@<span class="number">12</span>];</span><br><span class="line"><span class="comment">// 2. 删除该模型</span></span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm deleteObject:stu];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>场景2: <strong>删除某一特定类型的所有模型</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用 RLMRealm.defaultRealm 查询,如果要使用具体的数据库实例可以使用</span></span><br><span class="line"><span class="comment">* RLMResults *results = [Student allObjectsInRealm:realm];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RLMResults *results = [Student allObjects];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    <span class="keyword">for</span> (Student *stu <span class="keyword">in</span> results) &#123;</span><br><span class="line">       [realm deleteObject:stu];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>场景3: <strong>删除所有模型，清空数据库</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm deleteAllObjects];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><blockquote>
<p>对于查询数据，有几点需要注意：</p>
<ol>
<li>所有的查询(包括查询和属性访问)在<code>Realm</code>中都是延迟加载的，只有当属性被访问时，才能够读取相应的数据</li>
<li>查询的结果并不是数据的拷贝，修改查询结果(在写入事务中)会直接修改硬盘上的数据</li>
<li>一旦检索执行后，<code>RLMResults</code>将随时保持更新</li>
</ol>
</blockquote>
<h4 id="查询所有结果"><a href="#查询所有结果" class="headerlink" title="查询所有结果"></a>查询所有结果</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有数据</span></span><br><span class="line">RLMResults *allStu = [Student allObjects];</span><br></pre></td></tr></table></figure>

<h4 id="根据主键获取一条数据"><a href="#根据主键获取一条数据" class="headerlink" title="根据主键获取一条数据"></a>根据主键获取一条数据</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Student的主键是@&quot;age&quot;,获取age = 15的对象实例</span></span><br><span class="line">Student *stu = [Student objectForPrimaryKey:@<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个数据库存在时，也可以指定不同的数据库</span></span><br><span class="line">RLMRealm *defaultDb = [RLMRealm defaultRealm];</span><br><span class="line">Student *stu = [Student  objectInRealm:defaultDb forPrimaryKey:@<span class="number">15</span>];</span><br></pre></td></tr></table></figure>

<p>####条件查询</p>
<blockquote>
<p>在如下的几个方法中，都是最终调用<code>[RLMObject objectsInRealm: withPredicate:predicate]</code>,来构建谓词查询</p>
</blockquote>
<ol>
<li><p>简单的条件查询</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询age &gt; 13的数据</span></span><br><span class="line">RLMResults *allStu = [Student objectsWhere:<span class="string">@&quot;age &gt; 13&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//多个数据库存在时，也可以指定不同的数据库</span></span><br><span class="line">RLMRealm *defaultDb = [RLMRealm defaultRealm];</span><br><span class="line">RLMResults *allStu = [Student objectsInRealm:defaultDb where:<span class="string">@&quot;age &gt; 13&quot;</span>];</span><br></pre></td></tr></table></figure>
</li>
<li></li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol>
<li><p>根据某个属性值排序</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealm *defaultDb = [RLMRealm defaultRealm];</span><br><span class="line">RLMResults *allStus = [Student allObjects];</span><br><span class="line"><span class="comment">//根据某一个属性值 升序排序(Asceding:升序 Descending:降序)</span></span><br><span class="line">RLMResults *sortStus = [allStus sortedResultsUsingKeyPath:<span class="string">@&quot;age&quot;</span> ascending:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个排序条件和自定义排序规则</p>
</li>
</ol>
<h4 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h4><p>链式查询的含义是：在查询结果的基础上, 进行二次查询。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有结果</span></span><br><span class="line">RLMResults *allStus = [Student allObjects];</span><br><span class="line"><span class="comment">//在所有结果中，获取名字以&#x27;小&#x27;开头的数据</span></span><br><span class="line">RLMResults *someStus =  [allStus objectsWhere:<span class="string">@&quot;name beginswith &#x27;小&#x27;&quot;</span>];</span><br><span class="line"><span class="comment">//再从剩余的结果集中获取年龄 &gt; 13的数据</span></span><br><span class="line">RLMResults *bigStus = [someStus objectsWhere:<span class="string">@&quot;age &gt; 13&quot;</span>];</span><br></pre></td></tr></table></figure>

<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><p>查询出来的结果对象是懒加载, 只有真正访问时, 才会加载相应对象, 所以, 这里的分页, 其实就是从所有集合中分页获取即可</p>
<p>在分页的场景中，我们通常只需要查询10个结果，在SQL中会用到”limit 10”这样的字眼，Realm的“懒查询”机制：Realm只有在需要用到数据才会去加载真正的数据 。这个特性，使得对于这样的limit操作不需要过多的操作，先查询出来所有的结果，然后从数组中遍历得出一部分就可以了</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMResults&lt;Student *&gt; *students = [Student allObjects];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  Student *student = students[i];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h2><p><code>Realm</code>支持的数据类型有</p>
<ul>
<li><p>布尔类型(<code>BOOL,bool</code>)</p>
</li>
<li><p>数字类型(<code>int,NSIntger,long,long long，float，double</code>)</p>
</li>
<li><p>某些对象类型(<code>NSString,NSDate,NSData,NSNumber</code>)</p>
</li>
<li><p>如果<code>RLMObject</code>中存储的属性包含不支持的数据类型会造成崩溃</p>
</li>
<li><p><strong>对于不支持的类型</strong></p>
<p>例如:<code>UIImage</code>类型，可以设置成 <code>readonly</code>属性，或者重写<code>+[RLMObject ignoredProperties]</code>忽略相关属性效果一致。</p>
<blockquote>
<p>此种的场景的解决方法，一般是将不支持的类型转成支持的数据类型，此时的<code>UIImage</code>可以用<code>NSData</code>来保存</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -----------使用 readonly 标识----------------- */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *headImage; <span class="comment">//设置成readonly后,数据库不再有此字段</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -----------重写+[RLMObject ignoredProperties]----------------- */</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span> *)ignoredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@&quot;headImage&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>Realm</code>不支持集合数据类型</strong></p>
<ol>
<li><p>对于<code>RLMObject</code>中存在<strong>一对多</strong>的关系的情况,要是用集合数据类型，比如<code>NSArray &lt;NSString *&gt;</code>,可以将其转换成<code>NSData</code>存储</p>
</li>
<li><p>也可以使用<code>RLMArray</code>,其存储的数据类型也要继承自<code>RLMObject</code>,比如如下写法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Realm/Realm.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;Dog.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">UIImage</span> *headImage;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSData</span> *imageData;</span><br><span class="line"><span class="keyword">@property</span> RLMArray &lt;Dog *&gt;&lt;Dog&gt; *dogs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// This protocol enables typed collections. i.e.:</span></span><br><span class="line"><span class="comment">// RLMArray&lt;Student *&gt;&lt;Student&gt;</span></span><br><span class="line">RLM_ARRAY_TYPE(Student) <span class="comment">//这里使用宏定义声明了一个 Student的协议</span></span><br></pre></td></tr></table></figure>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>数据的关系基本上可以分为三种:对一关系、对多关系、反向关系</p>
<h3 id="对一关系"><a href="#对一关系" class="headerlink" title="对一关系"></a>对一关系</h3></li>
</ol>
</li>
</ul>
<p>情景：当一个对象持有另外一个对象时, 比如人有一个宠物狗</p>
<p>首先定义<code>Person</code>和<code>Dog</code>类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Dog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> Dog *pet;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span>  </span><br></pre></td></tr></table></figure>

<p>添加和查询的实例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*----  添加 --------*/</span></span><br><span class="line">Dog *pet = [[Dog alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">2</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;旺财&quot;</span>&#125;];</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.age = <span class="number">10</span>;</span><br><span class="line">p.name = <span class="string">@&quot;小王&quot;</span>;</span><br><span class="line">p.pet = pet;</span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">        [realm addOrUpdateObject:p];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*----  查询 --------*/</span></span><br><span class="line">Person *p = [Person allObjects].firstObject;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">p 对应的数据结构是：</span></span><br><span class="line"><span class="comment">Person &#123;</span></span><br><span class="line"><span class="comment">    age = 10;</span></span><br><span class="line"><span class="comment">    name = 小王;</span></span><br><span class="line"><span class="comment">    pet = Dog &#123;</span></span><br><span class="line"><span class="comment">        age = 2;</span></span><br><span class="line"><span class="comment">        name = 旺财;</span></span><br><span class="line"><span class="comment">    &#125;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="对多关系"><a href="#对多关系" class="headerlink" title="对多关系"></a>对多关系</h3><p>情景：当一个对象持有另外一个对象的多个实例时, 比如人有多个宠物狗</p>
<p>首先定义<code>Person</code>和<code>Dog</code>类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">Dog</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> RLMArray &lt;Dog *&gt;&lt;Dog&gt; *pets;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog) <span class="comment">//RLM_ARRAY_TYPE 宏创建了一个协议，从而允许 RLMArray&lt;Dog&gt; 语法的使用。</span></span><br></pre></td></tr></table></figure>

<p>添加和查询的实例：</p>
<blockquote>
<p>对于<code>RLMArray</code>属性，无需对其进行初始化，直接使用<code>-[RLMArray addObject:]</code>方法即可，其内部进行了懒加载处理。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Dog *pet1 = [[Dog alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">2</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;旺财&quot;</span>&#125;];</span><br><span class="line">Dog *pet2 = [[Dog alloc] initWithValue:@&#123;<span class="string">@&quot;age&quot;</span>:@<span class="number">2</span>,<span class="string">@&quot;name&quot;</span>:<span class="string">@&quot;大黄&quot;</span>&#125;];</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.age = <span class="number">10</span>;</span><br><span class="line">p.name = <span class="string">@&quot;小王&quot;</span>;</span><br><span class="line">[p.pets addObject:pet1];</span><br><span class="line">[p.pets addObject:pet2];</span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addOrUpdateObject:p];</span><br><span class="line">&#125;];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[Person allObjects].firstObject);</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">Person &#123;</span></span><br><span class="line"><span class="comment">    age = 10;</span></span><br><span class="line"><span class="comment">    name = 小王;</span></span><br><span class="line"><span class="comment">    pets = RLMArray&lt;Dog&gt; &lt;0x60000093c780&gt; (</span></span><br><span class="line"><span class="comment">        [0] Dog &#123;</span></span><br><span class="line"><span class="comment">            age = 2;</span></span><br><span class="line"><span class="comment">            name = 旺财;</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">        [1] Dog &#123;</span></span><br><span class="line"><span class="comment">            age = 2;</span></span><br><span class="line"><span class="comment">            name = 大黄;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="反向关系"><a href="#反向关系" class="headerlink" title="反向关系"></a>反向关系</h3><p>情景：人拥有狗，狗又有相应的主人</p>
<p>分析：</p>
<p><code>Person</code>类中定义<code>dog</code>属性，或者类型为<code>Dog</code>的数组,来表明<code>Person</code>对<code>Dog</code>的拥有关系。假如<code>Dog</code>中，定义一个<code>Person</code>类型的主人属性，来指向<code>Person</code>实例，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Dog *pet1 = [[Dog alloc] init];</span><br><span class="line">pet1.age = <span class="number">2</span>;</span><br><span class="line">pet1.name = <span class="string">@&quot;旺财&quot;</span>;</span><br><span class="line">Dog *pet2 = [[Dog alloc] init];</span><br><span class="line">pet2.age = <span class="number">2</span>;</span><br><span class="line">pet2.name = <span class="string">@&quot;旺财&quot;</span>;</span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.age = <span class="number">10</span>;</span><br><span class="line">p.name = <span class="string">@&quot;小王&quot;</span>;</span><br><span class="line">[p.pets addObject:pet1];</span><br><span class="line">[p.pets addObject:pet2];</span><br><span class="line">pet1.master = p;</span><br><span class="line">pet2.master = p;</span><br><span class="line">    </span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line">[realm transactionWithBlock:^&#123;</span><br><span class="line">    [realm addOrUpdateObject:p];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这样会出现一个循环引用的问题。这种场景下，<code>Realm</code>支持定义一种反向关系，适用于这种场景：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person类中还是正常定义</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> RLMArray &lt;Dog *&gt;&lt;Dog&gt; *pets;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Person)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog类中定义  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Dog</span> : <span class="title">RLMObject</span></span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="comment">//定义反向关系，用readonly来修饰，可以起到忽视属性的作用</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RLMLinkingObjects *master;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">RLM_ARRAY_TYPE(Dog)</span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="comment">//key就是Dog类中属性的名称</span></span><br><span class="line"><span class="comment">//对应的值是RLMPropertyDescriptor关系描述器，用来指明该类中反向关系指向的是那个类的那个属性</span></span><br><span class="line">+ (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,RLMPropertyDescriptor *&gt; *)linkingObjectsProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@&quot;master&quot;</span>:[RLMPropertyDescriptor descriptorWithClass:<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;Person&quot;</span>) propertyName:<span class="string">@&quot;pets&quot;</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span>  </span><br></pre></td></tr></table></figure>

<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><h3 id="必须属性"><a href="#必须属性" class="headerlink" title="必须属性"></a>必须属性</h3><p>在默认情况下，<code>RLMObject</code>允许所有的属性都可为空。如果强制要求某个属性非空, 可以重写<code>RLMObject</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)requiredProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@&quot;property_xx&quot;</span>,<span class="string">@&quot;property_zz&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>当然，也可以为不可为空的属性设置一个默认值：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)defaultPropertyValues&#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@&quot;c&quot;</span>:<span class="string">@&quot;CValue&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果再次赋值为nil, 则会抛出异常错误</p>
</blockquote>
<h3 id="忽略属性"><a href="#忽略属性" class="headerlink" title="忽略属性"></a>忽略属性</h3><p>如果想在存储时忽略模型的某些属性，可以重写如下该方法，亦或是给该属性设置只读属性<code>(readonly)</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)ignoredProperties&#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@&quot;a&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以借助忽略属性&amp;只读属性 打造计算属性, 完成集合以及UIImage对象的存储与获取</p>
</blockquote>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>重写 <code>+[RLMObject primaryKey]</code> 可以设置模型的主键。声明主键允许对象的查询和更新更加高效，并且会强制要求每个值保持唯一性。一旦将带有主键的对象添加到 Realm 数据库，那么该对象的主键将无法更改。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)primaryKey &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@&quot;id&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引属性"><a href="#索引属性" class="headerlink" title="索引属性"></a>索引属性</h3><p>要为某个属性建立索引，那么重写 <code>+[RLMObject indexedProperties]</code> 即可。与主键类似，索引会稍微减慢写入速度，但是使用比较运算符进行查询的速度将会更快（它同样会造成 Realm 文件体积的增大，因为需要存储索引。）当您需要为某些特定情况优化读取性能的时候，那么最好添加索引。</p>
<p>Realm 支持为字符串、整型、布尔值以及 <code>NSDate</code> 属性建立索引。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSArray</span> *)indexedProperties &#123;</span><br><span class="line">    <span class="keyword">return</span> @[<span class="string">@&quot;title&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性备忘单"><a href="#属性备忘单" class="headerlink" title="属性备忘单"></a>属性备忘单</h3><p>如果<code>RLMObject</code>中，属性是基本数据类型的，即使在<code>+[RLMObject requiredProperties]</code>中声明该属性必须有值，在存储中，没有对该属性赋值的话，也不会报错，因为基本数据类型都是有默认值的。此种情景下如果要使用可空的形式可参考下表：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">非可空值形式</th>
<th align="center">可空值形式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bool</td>
<td align="center"><code>@property BOOL value;</code></td>
<td align="center"><code>@property NSNumber&lt;RLMBool&gt; *value;</code></td>
</tr>
<tr>
<td align="center">Int</td>
<td align="center"><code>@property int value;</code></td>
<td align="center"><code>@property NSNumber&lt;RLMInt&gt; *value;</code></td>
</tr>
<tr>
<td align="center">Float</td>
<td align="center"><code>@property float value;</code></td>
<td align="center"><code>@property NSNumber&lt;RLMFloat&gt; *value;</code></td>
</tr>
<tr>
<td align="center">Double</td>
<td align="center"><code>@property double value;</code></td>
<td align="center"><code>@property NSNumber&lt;RLMDouble&gt; *value;</code></td>
</tr>
<tr>
<td align="center">String</td>
<td align="center"><code>@property NSString *value;</code> 1</td>
<td align="center"><code>@property NSString *value;</code></td>
</tr>
<tr>
<td align="center">Data</td>
<td align="center"><code>@property NSData *value;</code> 1</td>
<td align="center"><code>@property NSData *value;</code></td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center"><code>@property NSDate *value;</code> 1</td>
<td align="center"><code>@property NSDate *value;</code></td>
</tr>
<tr>
<td align="center">Object</td>
<td align="center">不存在：必须是可空值</td>
<td align="center"><code>@property Object *value;</code></td>
</tr>
<tr>
<td align="center">List</td>
<td align="center"><code>@property RLMArray&lt;Class *&gt;&lt;Class&gt; *value;</code></td>
<td align="center">不存在：必须是非可空值</td>
</tr>
<tr>
<td align="center">LinkingObjects</td>
<td align="center"><code>@property (readonly) RLMLinkingObjects&lt;Object *&gt; *value;</code> 2</td>
<td align="center">不存在：必须是非可</td>
</tr>
</tbody></table>
<p><code>RLMBool</code>，<code>RLMInt</code>等等都是一些空的协议，使用这样的方式是用来判断<code>value</code>实现的协议,来确定从<code>NSNumber</code>中的取值方式 :</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> &lt;RLMInt&gt; *value = @<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ([value conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">RLMInt</span>)]) </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> getValue = [value intValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p><code>Realm</code>在每次写入事务提交后，会给其他线程上<code>Realm</code>实例发送通知</p>
<h3 id="获取通知"><a href="#获取通知" class="headerlink" title="获取通知"></a>获取通知</h3><p><strong><em>对于获取的通知令牌：<code>RLMNotificationToken</code>必须强持有，否则会造成令牌释放，通知失效</em></strong></p>
<ul>
<li><p>对于<code>RLMRealm</code>添加通知，如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) RLMNotificationToken *token;</span><br><span class="line"><span class="comment">//-----------------</span></span><br><span class="line">RLMRealm *realm = [RLMRealm defaultRealm];</span><br><span class="line"><span class="keyword">self</span>.token = [realm addNotificationBlock:^(RLMNotification  _Nonnull notification, RLMRealm * _Nonnull realm) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,notification);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于<code>RLMResults</code>添加通知，如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) RLMNotificationToken *token;</span><br><span class="line"><span class="comment">//-----------------</span></span><br><span class="line">RLMResults *result = [NoticeModel allObjects];</span><br><span class="line"><span class="keyword">self</span>.token = [result addNotificationBlock:^(RLMResults * _Nullable results, RLMCollectionChange * _Nullable change, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (change) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%@-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread],change);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>当然也可以指定回调的<code>queue</code></p>
<blockquote>
<p>根据测试，使用<code>queue</code>必须是强持有的，否则不会回调</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) RLMNotificationToken *token;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) <span class="built_in">dispatch_queue_t</span> queue;</span><br><span class="line"><span class="comment">//--------------</span></span><br><span class="line"><span class="keyword">self</span>.queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">self</span>.token = [result addNotificationBlock:^(RLMResults * _Nullable results, RLMCollectionChange * _Nullable change, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (change) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;%@-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread],change);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; queue:<span class="keyword">self</span>.queue];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="关闭通知"><a href="#关闭通知" class="headerlink" title="关闭通知"></a>关闭通知</h3><p>如果要关闭通知，可以调用<code>[self.token invalidate];</code></p>
<h2 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h2><p>对于多个版本程序，数据库模型发生了变化，一定要注意对数据库进行迁移</p>
<p><code>Realm</code>中主要通过<code>RLMRealmConfiguration</code>中的<code>schemaVersion</code>以及<code>migrationBlock</code>属性来对老版本数据进行迁移。迁移的工作<code> +[AppDelegate didFinishLaunchingWithOptions:]</code> 中进行配置。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="comment">// 设置新的架构版本。这个版本号必须高于之前所用的版本号</span></span><br><span class="line">config.schemaVersion = <span class="number">1</span>;</span><br><span class="line">config.migrationBlock = ^(RLMMigration * _Nonnull migration, uint64_t oldSchemaVersion)&#123;</span><br><span class="line">    <span class="comment">//迁移要做的工作</span></span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br><span class="line"><span class="comment">// 打开文件之后将会自动执行迁移</span></span><br><span class="line">[RLMRealm defaultRealm];</span><br></pre></td></tr></table></figure>

<p>迁移的场景中包含：数据结构的迁移，数据的迁移，属性重命名等。</p>
<h3 id="数据结构的迁移"><a href="#数据结构的迁移" class="headerlink" title="数据结构的迁移"></a>数据结构的迁移</h3><ul>
<li><p>对于某个属性是否是必须属性的变化</p>
<p><code>Realm</code>可以自己处理，不需要去干预。如果某个属性从<strong>非必须属性</strong>变为<strong>必须属性</strong>,对于之前的该属性为<code>nil</code>的数据，会自动添加上默认值，比如<code>String</code>从<code>nil</code>变为<code>&quot;&quot;</code></p>
</li>
<li><p>对于新增或删除属性的变化</p>
<p><code>Realm</code> 会自行检测新增和需要移除的属性，然后自动更新硬盘上的数据库架构</p>
</li>
</ul>
<h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><p>以<code>Person</code>对象为例：在v1版本中，包含三个属性<code>age</code>、<code>firstName</code>和<code>lastName</code>。在v2版中变为两个属性<code>age</code>和<code>fullName</code>,其中<code>fullName</code>是<code>firstName</code>+<code>lastName</code>拼接而来。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="comment">// 设置新的架构版本。这个版本号必须高于之前所用的版本号</span></span><br><span class="line">uint64_t newVersion = <span class="number">1</span>;</span><br><span class="line">config.schemaVersion = newVersion;</span><br><span class="line">config.migrationBlock = ^(RLMMigration * _Nonnull migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">     <span class="comment">//迁移要做的工作</span></span><br><span class="line">  <span class="keyword">if</span> (newVersion &gt; oldSchemaVersion) &#123;</span><br><span class="line">      [migration enumerateObjects:Person.className block:^(RLMObject * _Nullable oldObject, RLMObject * _Nullable newObject) &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">//以字典的方式访问</span></span><br><span class="line">      newObject[<span class="string">@&quot;fullName&quot;</span>] = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@&quot;</span>,oldObject[<span class="string">@&quot;firstName&quot;</span>],oldObject[<span class="string">@&quot;lastName&quot;</span>]];</span><br><span class="line">     &#125;];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure>

<h3 id="属性重命名"><a href="#属性重命名" class="headerlink" title="属性重命名"></a>属性重命名</h3><p>两种方式：</p>
<ul>
<li><p>新属性的值等于旧属性的值</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">config.migrationBlock = ^(RLMMigration * _Nonnull migration, uint64_t oldSchemaVersion) &#123;</span><br><span class="line">     <span class="comment">//迁移要做的工作</span></span><br><span class="line">  <span class="keyword">if</span> (newVersion &gt; oldSchemaVersion) &#123;</span><br><span class="line">      [migration enumerateObjects:<span class="built_in">NSStringFromClass</span>(Person.class) block:^(RLMObject * _Nullable oldObject, RLMObject * _Nullable newObject) &#123;</span><br><span class="line">        newObject[<span class="string">@&quot;newProperty&quot;</span>] = oldObject[<span class="string">@&quot;oldProperty&quot;</span>];     </span><br><span class="line">    &#125;];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>migration</code>的重命名方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];</span><br><span class="line"><span class="comment">// 设置新的架构版本。这个版本号必须高于之前所用的版本号</span></span><br><span class="line">uint64_t newVersion = <span class="number">1</span>;</span><br><span class="line">config.schemaVersion = newVersion;</span><br><span class="line">config.migrationBlock = ^(RLMMigration * _Nonnull migration, uint64_t oldSchemaVersion)&#123;</span><br><span class="line">    <span class="comment">//迁移要做的工作</span></span><br><span class="line">  <span class="keyword">if</span> (newVersion &gt; oldSchemaVersion) &#123;            </span><br><span class="line">      [migration renamePropertyForClass:Person.className oldName:<span class="string">@&quot;oldProperty&quot;</span> newName:<span class="string">@&quot;newProperty&quot;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">[RLMRealmConfiguration setDefaultConfiguration:config];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="多版本跳跃性迁移"><a href="#多版本跳跃性迁移" class="headerlink" title="多版本跳跃性迁移"></a>多版本跳跃性迁移</h3><p>对于多个版本跳跃性的迁移，要从`</p>
<ul>
<li><pre><code>RLMRealmConfiguration *config = [RLMRealmConfiguration defaultConfiguration];
// 设置新的架构版本。这个版本号必须高于之前所用的版本号
uint64_t newVersion = 1;
config.schemaVersion = newVersion;
config.migrationBlock = ^(RLMMigration * _Nonnull migration, uint64_t oldSchemaVersion)&#123;
  //迁移要做的工作
  if (newVersion &gt; oldSchemaVersion) &#123;            
    [migration renamePropertyForClass:Person.className oldName:@&quot;oldProperty&quot; newName:@&quot;newProperty&quot;];
  &#125;
&#125;;
[RLMRealmConfiguration setDefaultConfiguration:config];
&lt;!--hexoPostRenderEscape:&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 多版本跳跃性迁移&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于多个版本跳跃性的迁移，要对&amp;#96;schemVersion&amp;#96;属性进行更为细致的判断和迁移。要十分谨慎才行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 加密&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;Realm&amp;#96;支持在创建&amp;#96;Realm&amp;#96;数据库时采用64位的密钥对数据库文件进行&amp;#96;AES-256+SHA2&amp;#96;加密。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#96;&amp;#96;&amp;#96;objc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 生成随机秘钥&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableData *key &amp;#x3D; [NSMutableData dataWithLength:64];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)SecRandomCopyBytes(kSecRandomDefault, key.length, (uint8_t *)key.mutableBytes);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 打开已加密的 Realm 文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RLMRealmConfiguration *config &amp;#x3D; [RLMRealmConfiguration defaultConfiguration];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;config.encryptionKey &amp;#x3D; key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSError *error &amp;#x3D; nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RLMRealm *realm &amp;#x3D; [RLMRealm realmWithConfiguration:config error:&amp;amp;error];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!realm) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#x2F;&amp;#x2F; 如果秘钥错误，&amp;#96;error&amp;#96; 会提示数据库无法访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Error opening realm: %@&amp;quot;, error);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#x2F;&amp;#x2F; 照常使用 Realm 数据库&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RLMResults&amp;lt;Dog *&amp;gt; *dogs &amp;#x3D; [Dog objectsInRealm:realm where:@&amp;quot;name contains &amp;#39;Fido&amp;#39;&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;:hexoPostRenderEscape--&gt;
</code></pre>
</li>
</ul>
<p>样硬盘上的数据都能都采用<code>AES-256</code>来进行加密和解密，并用<code>SHA-2 HMAC</code>来进行验证。 每次您要获取一个<code>Realm</code>实例时，您都需要提供一次相同的密钥。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/09/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Swift5学习笔记之从函数式编程初探</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-09 10:16:48" itemprop="dateCreated datePublished" datetime="2019-12-09T10:16:48+08:00">2019-12-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>函数式编程(Funtional Programming，简称FP)是一种编程范式，也就是如何编写程序的方法论 </p>
<ul>
<li><p>主要思想:把计算过程尽量分解成一系列可复用函数的调用  </p>
</li>
<li><p>主要特征:函数是“第一等公民”</p>
<p> 函数与其他数据类型一样的地位，可以赋值给其他变量，也可以作为函数参数、函数返回值</p>
</li>
</ul>
<p>函数式编程最早出现在LISP语言，绝大部分的现代编程语言也对函数式编程做了不同程度的支持，比如 p Haskell、JavaScript、Python、Swift、Kotlin、Scala等</p>
<p>这里对Swift的函数编程仅做了解初试。</p>
<h2 id="预热"><a href="#预热" class="headerlink" title="预热"></a>预热</h2><p>说起函数式编程，不得不先说下Swift中几个设计的”很有意思”的Api</p>
<h3 id="Array的常见操作"><a href="#Array的常见操作" class="headerlink" title="Array的常见操作"></a>Array的常见操作</h3><h4 id="Map映射操作"><a href="#Map映射操作" class="headerlink" title="Map映射操作"></a>Map映射操作</h4><p>Array中有一个map函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br></pre></td></tr></table></figure>

<p>这个函数要求传入一个闭包：<code>(Element) -&gt; T</code>。执行的时候，会遍历Array中每个元素，依次传入这个闭包中(Element)</p>
<p>每次返回的值会组成一个新的数组。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//[2, 4, 6, 8]</span></span><br><span class="line"><span class="keyword">var</span> arr2 = arr.<span class="built_in">map</span> &#123; (i) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    i * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>lazy</code>的优化</p>
<p>Swift对于Map映射操作，都是立刻执行的。如果映射是比较耗时的操作。可以使用lazy延迟操作，在访问的时候在调用转换的闭包函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">var</span> lazyResult = arr.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; (element) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;maping:\(element)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> element * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mapped&quot;</span>,lazyResult[<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mapped&quot;</span>,lazyResult[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mapped&quot;</span>,lazyResult[<span class="number">2</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">maping:1</span></span><br><span class="line"><span class="comment">mapped 2</span></span><br><span class="line"><span class="comment">maping:2</span></span><br><span class="line"><span class="comment">mapped 4</span></span><br><span class="line"><span class="comment">maping:3</span></span><br><span class="line"><span class="comment">mapped 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="FlatMap映射操作"><a href="#FlatMap映射操作" class="headerlink" title="FlatMap映射操作"></a>FlatMap映射操作</h4><p>这个Api和<code>map</code>操作很像，但有很大的区别。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">SegmentOfResult</span>) -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">SegmentOfResult</span> : <span class="type">Sequence</span></span><br></pre></td></tr></table></figure>

<p>这个函数要求传入一个闭包。执行的时候，会遍历Array中每个元素，一次传入这个闭包中，这个闭包会返回一个数组。所有的返回的数组都将展开合并为一个数组并返回。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]</span></span><br><span class="line"><span class="keyword">var</span> numArray = arr.flatMap &#123; (i) -&gt; <span class="type">Array</span>&lt;<span class="type">Any</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="type">Array</span>.<span class="keyword">init</span>(repeating: i, <span class="built_in">count</span>: i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compactMap映射"><a href="#compactMap映射" class="headerlink" title="compactMap映射"></a>compactMap映射</h4><p>紧凑映射。相比于<code>map</code>映射，<code>compactMap</code>要求传入的闭包会返回一个可选项，对于返回的可选为不为<code>nil</code>的自动解包，并添加到返回到数组中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strings = [<span class="string">&quot;123&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="string">&quot;jack&quot;</span>,<span class="string">&quot;-30&quot;</span>]</span><br><span class="line"><span class="comment">//[Optional(123), nil, nil, Optional(-30)]</span></span><br><span class="line"><span class="keyword">var</span> numbers = strings.<span class="built_in">map</span> &#123; (str) -&gt; <span class="type">Int?</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">Int</span>(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//[123, -30]</span></span><br><span class="line"><span class="keyword">var</span> numbers2 = strings.<span class="built_in">compactMap</span> &#123; (str) -&gt; <span class="type">Int?</span> <span class="keyword">in</span></span><br><span class="line">    <span class="type">Int</span>(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filter操作"><a href="#filter操作" class="headerlink" title="filter操作"></a>filter操作</h4><p>拦截操作。这个函数要求传入一个闭包：<code>(Element) -&gt; T</code>。执行的时候，会遍历Array中每个元素，依次传入这个闭包中(Element)，返回值为布尔值，返回true，则会被添加到返回的数组中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//[2, 4]</span></span><br><span class="line"><span class="keyword">var</span> filterArray = arr.<span class="built_in">filter</span> &#123; (element) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    element % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reduce操作"><a href="#reduce操作" class="headerlink" title="reduce操作"></a>reduce操作</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result, <span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span>  -&gt; <span class="type">Result</span>) -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure>

<p>这个函数要求传入一个初始值：<code>initialResult</code>。</p>
<p><code>nextPartialResult</code>:闭包函数，Element是数组中的每一个元素遍历传入。返回一个结果。Result就是上一次返回的结果。当第一个元素传入时，Result取的是initialResult传入的参数。最后将结果返回</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">//10</span></span><br><span class="line"><span class="keyword">var</span> addResult = arr.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; (lastResult, element) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">       lastResult + element</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1234</span></span><br><span class="line"><span class="keyword">var</span> stringJoined = arr.<span class="built_in">reduce</span>(<span class="string">&quot;&quot;</span>) &#123; (lastResult, element) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    lastResult + <span class="string">&quot;\(element)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Optional的Map和flatMap"><a href="#Optional的Map和flatMap" class="headerlink" title="Optional的Map和flatMap"></a>Optional的Map和flatMap</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>在开发的时候,时常会出现判断可选项是否为<code>nil</code>的判断，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//num2:Optional(20)</span></span><br><span class="line"><span class="keyword">var</span> num2 = (num1 != <span class="literal">nil</span>) ? (num1! + <span class="number">10</span>) : <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>这样会显得很麻烦，可以使用<code>Optional</code>的<code>map</code>方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num1: <span class="type">Int?</span> = <span class="number">10</span></span><br><span class="line"><span class="comment">//num1不为nil时，会把num1解包传给i</span></span><br><span class="line"><span class="keyword">var</span> num3 = num1.<span class="built_in">map</span> &#123; (i) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(num3) <span class="comment">//Optional(20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//num1为nil时，不会调用map方法，</span></span><br><span class="line">num1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> num4 = num1.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">2</span> &#125; </span><br><span class="line"><span class="built_in">print</span>(num4) <span class="comment">//nil</span></span><br></pre></td></tr></table></figure>

<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/" class="post-title-link" itemprop="url">Swift5学习笔记之从OC迁移到Swift</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-06 10:33:41" itemprop="dateCreated datePublished" datetime="2019-12-06T10:33:41+08:00">2019-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MARK: 类似于OC中的 #pragma mark</span></span><br><span class="line"><span class="comment">//MARK: - 类似于OC中的#pragma mark -</span></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 用于标记未完成的任务</span></span><br><span class="line"><span class="comment">//<span class="doctag">FIXME:</span> 用于标记待修复的问题</span></span><br></pre></td></tr></table></figure>

<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>常用的几种条件编译的宏：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//操作系统可选值：macOS\iOS\tvOS\watchOS\Linux\Android\Windows\FreeBSD</span></span><br><span class="line">#<span class="keyword">if</span> os(macOS) || os(iOS)</span><br><span class="line"><span class="comment">//CPU架构： i386\x86_64\arm\arm64</span></span><br><span class="line">#elseif arch(i386) || arch(arm)</span><br><span class="line"><span class="comment">//swift版本</span></span><br><span class="line">#elseif swift(&lt;<span class="number">5</span>) &amp;&amp; swift(&gt;=<span class="number">3</span>)</span><br><span class="line"><span class="comment">//模拟器</span></span><br><span class="line">#elseif targetEnvironment(simulator)</span><br><span class="line"><span class="comment">//可以导入某模块</span></span><br><span class="line">#elseif canImport(<span class="type">Foundation</span>)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>另外还可以设定自定义的宏。</p>
<p>在 Build Setting -&gt; Swift Compiler - Custom Flags中，在Activie Compliation Conditions选项下，可以分别为Debug模式或者Release模式添加跟多的宏</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-111215@2x.png" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据上述截图，我们在代码中就可以这样写</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">TEST</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;TEST&quot;</span>) <span class="comment">//TEST</span></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Release&quot;</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>除了 DEBUG和Release这个宏，我们还可以在Other Swift Flags下为这个模式下添加不同的宏。不过要在宏前面加**- D**</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-111915@2x.png" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据上述截图，我们在代码中就可以这样写</span></span><br><span class="line">#<span class="keyword">if</span> <span class="type">OTHER</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> <span class="type">AAA</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AAA&quot;</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><p>我们可以参照OC中的<code>NSLog</code>来重新定义一个打印函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span>&lt;T&gt;<span class="params">(<span class="number">_</span> msg: T,</span></span></span><br><span class="line"><span class="function"><span class="params">            file: NSString = #file,</span></span></span><br><span class="line"><span class="function"><span class="params">            line: Int = #line,</span></span></span><br><span class="line"><span class="function"><span class="params">            fn: String = #function)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">prefix</span> = <span class="string">&quot;\(file.lastPathComponent)_\(line)_\(fn):&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="keyword">prefix</span>,msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&quot;Release&quot;</span>) <span class="comment">//main.swift_34_swift之从OC迁移: Release</span></span><br></pre></td></tr></table></figure>

<h2 id="系统版本检测"><a href="#系统版本检测" class="headerlink" title="系统版本检测"></a>系统版本检测</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> #available(iOS <span class="number">10</span>,macOS <span class="number">10.12</span>, *) &#123;</span><br><span class="line">    <span class="comment">//对于iOS平台，只在iOS10及以上版本执行</span></span><br><span class="line">    <span class="comment">//对于macOS平台，只在macOS 10.12及以上版本执行</span></span><br><span class="line">    <span class="comment">//最后的*, 表示在其他所有平台都执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API可用性说明"><a href="#API可用性说明" class="headerlink" title="API可用性说明"></a>API可用性说明</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在iOS10及以上版本可用</span></span><br><span class="line"><span class="comment">//在macOS 10.25及以上版本可用</span></span><br><span class="line"><span class="comment">//其他平台皆可用</span></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">10</span>, macOS <span class="number">10.25</span>, *) </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">      <span class="comment">//不可用，方法命名为study</span></span><br><span class="line">    <span class="meta">@available</span>(*, unavailable, renamed: <span class="string">&quot;study&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">learn</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">//在iOS11及以上版本方法被弃用</span></span><br><span class="line">    <span class="meta">@available</span>(iOS, deprecated: <span class="number">11</span>)</span><br><span class="line">      <span class="comment">//在macOs10.12及以上版本方法被弃用</span></span><br><span class="line">    <span class="meta">@available</span>(macOS, deprecated: <span class="number">10.12</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Student</span>()</span><br><span class="line">s.run() <span class="comment">//warn:&#x27;run()&#x27; was deprecated in macOS 10.12</span></span><br><span class="line">s.learn() <span class="comment">//error:&#x27;learn()&#x27; has been renamed to &#x27;study&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Person</span>() <span class="comment">//error:&#x27;Person&#x27; is only available in macOS 10.25 or newer</span></span><br></pre></td></tr></table></figure>

<h2 id="iOS程序的入口"><a href="#iOS程序的入口" class="headerlink" title="iOS程序的入口"></a>iOS程序的入口</h2><p>在<code>AppDelegate</code>上默认有个<code>@UIApplicationMain</code>或者<code>@mian</code>的标记，这表示编译器自动生成入口代码(main函数代码)，自动设置<code>AppDelegate</code>为App的代理</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line">@main</span><br><span class="line"><span class="comment">//@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">        <span class="keyword">self</span>.window? = <span class="type">UIWindow</span>()</span><br><span class="line">        <span class="keyword">let</span> mainVc = <span class="type">ViewController</span>()</span><br><span class="line">        <span class="keyword">self</span>.window?.rootViewController = mainVc</span><br><span class="line">        <span class="keyword">self</span>.window?.backgroundColor = <span class="type">UIColor</span>.white</span><br><span class="line">        <span class="keyword">self</span>.window?.makeKeyAndVisible()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然也可以删掉<code>@UIApplicationMain</code>，自定义入口代码：新建一个main.swift文件</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-115601@2x.png" class="" title="This is an example image">

<h2 id="Swift调用OC"><a href="#Swift调用OC" class="headerlink" title="Swift调用OC"></a>Swift调用OC</h2><p>在Swift工程中，如果想要调用OC，需要使用桥接文件。文件名格式默认为：<code>&#123;targetName&#125;-Bridging-Header.h</code>。在桥接文件中，<code>#import</code> OC需要暴露给<code>Swift</code>内容。</p>
<p>并且在Build Setting -&gt; Swift Compiler - General -&gt; Objective-C Bridging Header中填入桥接文件的地址。</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-142541@2x.png" class="" title="This is an example image">

<p>以下是OC中类的内容：</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-142844@2x.png" class="" title="This is an example image">

<p>在桥接文件中引入：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;OCPerson.h&quot;</span><br></pre></td></tr></table></figure>

<p>在Swift中调用：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="type">OCPerson</span>(age: <span class="number">10</span>, name: <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line">p.age = <span class="number">19</span></span><br><span class="line">p.name = <span class="string">&quot;Rose&quot;</span></span><br><span class="line">p.run()<span class="comment">//19 Rose -run</span></span><br><span class="line">p.eat(<span class="string">&quot;Apple&quot;</span>, other: <span class="string">&quot;Water&quot;</span>)<span class="comment">//19 Rose -eat Apple Water</span></span><br><span class="line">        </span><br><span class="line"><span class="type">OCPerson</span>.run() <span class="comment">//OCPerson + run</span></span><br><span class="line"><span class="type">OCPerson</span>.eat(<span class="string">&quot;Pizza&quot;</span>, other: <span class="string">&quot;Banana&quot;</span>)<span class="comment">//OCPerson +eat Pizza Banana</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：OC中NSInteger会转换为Swift中的Int,OC中的Int类型会转换为Swift的Int32</strong></p>
<ul>
<li><p>调用OC中的C语言函数</p>
<p>桥接文件中引入的.h文件中的C语言函数会自然暴露给Swift。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;OC文件中</span><br><span class="line">int sum(int a,int b);</span><br><span class="line">int sum(int a,int b) &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;Swift文件中</span><br><span class="line"> print(sum(32, 34)) &#x2F;&#x2F;66</span><br></pre></td></tr></table></figure>

<p><strong>如果C语言暴露给Swift的函数名跟Swift中的其他函数名冲突了，那么在调用时会优先调用Swift中的实现。可以在Swift中使用@_silgen_name修改C函数名</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(<span class="number">_</span> a: Int32,<span class="number">_</span> b: Int32)</span></span> -&gt; <span class="type">Int32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@_silgen_name(<span class="string">&quot;sum&quot;</span>) <span class="function"><span class="keyword">func</span> <span class="title">oc_sum</span><span class="params">(<span class="number">_</span> a: Int32,<span class="number">_</span> b: Int32)</span></span> -&gt; <span class="type">Int32</span></span><br><span class="line"><span class="built_in">print</span>(sum(<span class="number">32</span>, <span class="number">34</span>)) <span class="comment">//132</span></span><br><span class="line"><span class="built_in">print</span>(oc_sum(<span class="number">32</span>, <span class="number">34</span>))<span class="comment">//66</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="OC调用Swift代码"><a href="#OC调用Swift代码" class="headerlink" title="OC调用Swift代码"></a>OC调用Swift代码</h2><p>Xcode已经默认生成一个用于OC调用Swift的头文件，文件名格式是：{targetName}-Swift.h</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-145511@2x.png" class="" title="This is an example image">

<p>Swift暴露给OC需要有几个需要注意的点</p>
<ul>
<li>如果Swift暴露给OC的类需要最终继承自<code>NSObject</code></li>
<li>使用<code>@objc</code>修饰需要暴露给OC的成员</li>
<li>使用<code>@objcMembers</code>修饰类，代表默认所有成员都会暴露给OC(包括扩展中定义的成员)。不过最终是否暴露成功，还需要考虑成员自身的访问级别</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> price: <span class="type">Double</span></span><br><span class="line">    <span class="keyword">var</span> band: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(price: <span class="type">Double</span>, band: <span class="type">String</span>)&#123;</span><br><span class="line">        <span class="keyword">self</span>.price = price</span><br><span class="line">        <span class="keyword">self</span>.band = band</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(price,band,<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Car run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(price,band,<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Xcode会根据Swift代码生成对应的OC声明，写入{targetName}-Swift.h文件</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-153944@2x.png" class="" title="This is an example image">

<p>在OC中调用，需要先引入{targetName}-Swift.h文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;iOS从OC迁移到Swift-Swift.h&quot;</span><br><span class="line">Car *car &#x3D; [[Car alloc] initWithPrice:20.2 band:@&quot;banz&quot;];</span><br><span class="line">car.band &#x3D; @&quot;Bently&quot;;</span><br><span class="line">car.price &#x3D; 108.5;</span><br><span class="line">[car run];</span><br><span class="line">[car test];</span><br><span class="line">[Car run];</span><br></pre></td></tr></table></figure>

<p>可以通过<code>@objc</code>重命名Swift暴露给OC的符号名(类名、属性名、函数名等)</p>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201206-155652@2x.png" class="" title="This is an example image">

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">SwiftCar</span> *car = [[<span class="type">SwiftCar</span> alloc] initWithPrice:<span class="number">20.2</span> band:@<span class="string">&quot;banz&quot;</span>];</span><br><span class="line">car.name = @<span class="string">&quot;Bently&quot;</span>;</span><br><span class="line">car.price = <span class="number">108.5</span>;</span><br><span class="line">[car drive];</span><br><span class="line">[car exec];</span><br><span class="line">[<span class="type">SwiftCar</span> run];</span><br></pre></td></tr></table></figure>

<h2 id="一个内存问题"><a href="#一个内存问题" class="headerlink" title="一个内存问题"></a>一个内存问题</h2><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>Swift中依然可以使用选择器，使用<code>#selector(name)</code>定义一个选择器。必须是被<code>@objcMembers</code>或<code>@objc</code>修饰的方法才可以定义选择器。</p>
<p><strong>根据下面的代码，注意#selector(name)中，函数名相同，形参不同的场景</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objcMembers</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(v1: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">&quot;test1(v1:)&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(v1: Int,v2: Int)</span></span> &#123; <span class="built_in">print</span>(<span class="string">&quot;test2(v1:v2:)&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(<span class="number">_</span> v1: Double, <span class="number">_</span> v2: Double)</span></span>  &#123; <span class="built_in">print</span>(<span class="string">&quot;test2(_:_:)&quot;</span>) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        perform(#selector(test1)) <span class="comment">//可以使用方法名进行反射</span></span><br><span class="line">        perform(#selector(test1(v1:))) <span class="comment">//也可以添加形参</span></span><br><span class="line">        perform(#selector(test2(v1:v2:)))</span><br><span class="line">        perform(#selector(test2(<span class="number">_</span>:<span class="number">_</span>:)))</span><br><span class="line">        <span class="comment">//根据test2名称可以找到两个方法，使用as可以根据参数匹配到相应的方法</span></span><br><span class="line">        perform(#selector(test2 <span class="keyword">as</span> (<span class="type">Double</span>,<span class="type">Double</span>) -&gt; <span class="type">Void</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Swift的字符串类型<code>String</code>，跟OC的<code>NSString</code>,在API设计上还是有较大差异的</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//空字符串</span></span><br><span class="line"><span class="keyword">var</span> emptyStr1 = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> emptyStr2 = <span class="type">String</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1:<span class="type">String</span> = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="comment">//拼接字符串</span></span><br><span class="line">str1.append(<span class="string">&quot;_2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(str1)<span class="comment">//1_2</span></span><br><span class="line"><span class="comment">//重载运算符 +</span></span><br><span class="line">str1 = str1 + <span class="string">&quot;_3&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1)<span class="comment">//1_2_3</span></span><br><span class="line">str1 += <span class="string">&quot;_4&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1) <span class="comment">//1_2_3_4</span></span><br><span class="line"><span class="comment">//插值</span></span><br><span class="line">str1 = <span class="string">&quot;\(str1)_5&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str1) <span class="comment">//1_2_3_4_5</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="built_in">print</span>(str1.<span class="built_in">count</span>) <span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断前缀和后缀</span></span><br><span class="line"><span class="built_in">print</span>(str1.hasPrefix(<span class="string">&quot;1_2&quot;</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(str1.hasSuffix(<span class="string">&quot;4_5&quot;</span>)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="String的插入和删除"><a href="#String的插入和删除" class="headerlink" title="String的插入和删除"></a>String的插入和删除</h3><p>下标脚本语法或者它自身的属性和方法来访问和修改字符串。但说起String的插入和删除，就不得不提String.Index。Swift在字符串的API设计上，为字符串单独设计了字符串的索引类型：String.index,并不是OC中以<code>int</code>型来进行索引。</p>
<h4 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h4><p>Swift为了在字符串中兼容Unicode，不同的字符会获得不同的内存空间来储存，所以为了明确哪个 Character 在哪个特定的位置，你必须从 String的开头或结尾遍历每一个 Unicode 标量。因此，Swift 的字符串不能通过整数值索引。</p>
<p>字符串有两个重要的索引，<code>startIndex</code>和<code>endIndex</code>，其中：</p>
<ul>
<li><code>startIndex</code>:String中第一个 Character的位置</li>
<li><code>endIndex</code>:String中最后一个字符后的位置</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"><span class="built_in">print</span>(testStr[testStr.startIndex]) <span class="comment">//H</span></span><br><span class="line"><span class="keyword">var</span> beforeEndIndex = testStr.index(before: testStr.endIndex)</span><br><span class="line"><span class="built_in">print</span>(testStr[beforeEndIndex])<span class="comment">//d,testStr[testStr.endIndex]会崩溃</span></span><br></pre></td></tr></table></figure>

<p>使用<code>index(before:)</code> 和 <code>index(after:)</code> 方法来访问给定索引的前后。要访问给定索引更远的索引，你可以使用 <code>index(_:offsetBy:)</code> 方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> testStr = <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第二个字符的索引</span></span><br><span class="line"><span class="keyword">var</span> secondCharIndex = testStr.index(after: testStr.startIndex)</span><br><span class="line"><span class="built_in">print</span>(testStr[secondCharIndex])<span class="comment">//e</span></span><br><span class="line"><span class="comment">//获取第五个字符的索引，startIndex向后偏移4个单位</span></span><br><span class="line"><span class="keyword">var</span> foursCharIndex = testStr.index(testStr.startIndex, offsetBy: <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(testStr[foursCharIndex])<span class="comment">//o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最后一个字符</span></span><br><span class="line"><span class="keyword">var</span> lastCharIndex = testStr.index(before: testStr.endIndex)</span><br><span class="line"><span class="built_in">print</span>(testStr[lastCharIndex])<span class="comment">//d</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>indices</code>属性来访问字符串中每个字符的索引。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> testStr.<span class="built_in">indices</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(testStr[index])&quot;</span>)</span><br><span class="line">&#125;<span class="comment">//H e l l o  w o r ldee</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串插入"><a href="#字符串插入" class="headerlink" title="字符串插入"></a>字符串插入</h4><p>弄明白字符串索引，那么就可以通过字符串索引来进行插入删除操作了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//------插入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1_2&quot;</span></span><br><span class="line"><span class="comment">//向索引位置插入一个字符,1_2_</span></span><br><span class="line">str.insert(<span class="string">&quot;_&quot;</span>, at: str.endIndex)</span><br><span class="line"><span class="comment">//向索引位置插入另外一个字符串，1_2_3_4</span></span><br><span class="line">str.insert(contentsOf: <span class="string">&quot;3_4&quot;</span>, at: str.endIndex)</span><br><span class="line"><span class="comment">//向第一个字符后插入另外一个字符串,1666_2_3_4</span></span><br><span class="line">str.insert(contentsOf: <span class="string">&quot;666&quot;</span>, at: str.index(after: str.startIndex))</span><br><span class="line"><span class="comment">//向最后一个字符前面一个位置,1666_2_3_8884</span></span><br><span class="line">str.insert(contentsOf: <span class="string">&quot;888&quot;</span>, at: str.index(before: str.endIndex))</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fisrtCharOneIndex 是String.Index?类型，</span></span><br><span class="line"><span class="keyword">var</span> fisrtCharOneIndex = str.firstIndex(of: <span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> firstrIndex = fisrtCharOneIndex &#123;</span><br><span class="line">    str.remove(at: firstrIndex)<span class="comment">//666_2_3_8884</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeAll后边是一个尾随闭包，这个方法会遍历字符串中的每个char，闭包中返回Bool来表示是否要删除这个char</span></span><br><span class="line"><span class="comment">//也可以简写为：</span></span><br><span class="line"><span class="comment">//str.removeAll &#123; $0 == &quot;6&quot;&#125;</span></span><br><span class="line">str.removeAll &#123; (char) -&gt; <span class="type">Bool</span> <span class="keyword">in</span></span><br><span class="line">    char == <span class="string">&quot;6&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str: _2_3_8884</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> range = str.index(str.endIndex, offsetBy: -<span class="number">4</span>)..&lt;str.index(before: str.endIndex)</span><br><span class="line">str.removeSubrange(range)<span class="comment">//2_3_4</span></span><br></pre></td></tr></table></figure>

<h3 id="SubString"><a href="#SubString" class="headerlink" title="SubString"></a>SubString</h3><p>String可以通过下标、<code>prefix</code>、<code>suffix</code>等截取子串，子串的类型不是String，而是SubString。</p>
<blockquote>
<p>注意：</p>
<p>String 和 Substring 都遵循<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/stringprotocol"> StringProtocol</a> 协议，也就是说它基本上能很方便地兼容所有接受 StringProtocol 值的字符串操作函数。你可以无差别使用 String 或 Substring 值来调用这些函数。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aString = <span class="string">&quot;1_2_3_4_5&quot;</span></span><br><span class="line"><span class="comment">//1_2</span></span><br><span class="line"><span class="keyword">var</span> substr1 = aString.<span class="keyword">prefix</span>(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//4_5</span></span><br><span class="line"><span class="keyword">var</span> substr2 = aString.suffix(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> subRange = str.startIndex..&lt;str.index(str.startIndex, offsetBy: <span class="number">3</span>)</span><br><span class="line"><span class="comment">//1_2</span></span><br><span class="line"><span class="keyword">var</span> substr3 = aString[subRange]</span><br><span class="line"><span class="comment">//最初的String,1_2_3_4_5</span></span><br><span class="line"><span class="built_in">print</span>(substr3.base)</span><br><span class="line"><span class="comment">//Substring -&gt; String, 1_2</span></span><br><span class="line"><span class="keyword">var</span> subString = <span class="type">String</span>(substr3)</span><br></pre></td></tr></table></figure>

<ul>
<li>Swift处于性能优化，SubString和它的base共享字符串数据，共享一块内存。</li>
<li>当SubString发生修改或者转为String时，会分配新的内存存储字符串数据。</li>
</ul>
<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/stringSubstring_2x.png" class="" title="This is an example image">

<h3 id="String与Character"><a href="#String与Character" class="headerlink" title="String与Character"></a>String与Character</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="string">&quot;Hello world&quot;</span> &#123; <span class="comment">//c是Character类型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">c</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> theString = <span class="string">&quot;java&quot;</span></span><br><span class="line"><span class="comment">//c是Character类型</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = theString[theString.startIndex]</span><br></pre></td></tr></table></figure>

<h3 id="String相关的协议"><a href="#String相关的协议" class="headerlink" title="String相关的协议"></a>String相关的协议</h3><ul>
<li><p><code>BidirectionalCollection</code>协议包含的部分内容</p>
<ul>
<li><code>startIndex</code>，<code>endIndex</code>属性、<code>index</code>方法</li>
<li><code>String</code>、<code>Array</code>都遵守这个协议</li>
</ul>
</li>
<li><p><code>RangeReplaceableCollection</code>协议包含的部分内容</p>
<ul>
<li><code>append</code>、<code>insert</code>、<code>remove</code>方法</li>
<li><code>String</code>、<code>Array</code>都遵守这个协议</li>
</ul>
</li>
</ul>
<p><code>Dictionary</code>、<code>Set</code>也有实现上述协议中声明的一些方法，只是并没有遵守上述协议</p>
<h3 id="多行String"><a href="#多行String" class="headerlink" title="多行String"></a>多行String</h3><p>如果要表示多行<code>String</code>,可以用三引号</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mutilString = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Escaping the first quote \&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Escaping two quotes \&quot;\&quot;&quot;</span></span><br><span class="line"><span class="string">Escaping all three quotes \&quot;\&quot;\&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(mutilString)</span><br></pre></td></tr></table></figure>

<h3 id="String-与-NSString"><a href="#String-与-NSString" class="headerlink" title="String 与 NSString"></a>String 与 NSString</h3><p><strong>String与NSString之间可以随时随地的桥接转换。</strong>如果觉得String的API过于复杂难用，可以考虑将String转为NSString</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1: <span class="type">String</span> = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">var</span> str2: <span class="type">NSString</span> = <span class="string">&quot;rose&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3 = str1 <span class="keyword">as</span> <span class="type">NSString</span></span><br><span class="line"><span class="keyword">var</span> str4 = str2 <span class="keyword">as</span> <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str5 = str3.substring(with: <span class="type">NSRange</span>(location: <span class="number">0</span>, length: <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(str5)<span class="comment">//ja</span></span><br></pre></td></tr></table></figure>

<p>在比较字符串内容是否等价：</p>
<ul>
<li><code>String</code>使用<code>==</code>运算符</li>
<li><code>NSString</code>使用<code>isEqual</code>方法，也可以使用<code>==</code>运算符(本质还是调用了<code>isEqual</code>方法)</li>
</ul>
<h2 id="Swift、OC桥接转换表"><a href="#Swift、OC桥接转换表" class="headerlink" title="Swift、OC桥接转换表"></a>Swift、OC桥接转换表</h2><img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201207-155945.png" class="" title="This is an example image">

<h2 id="实现可选协议"><a href="#实现可选协议" class="headerlink" title="实现可选协议"></a>实现可选协议</h2><p>继承自<code>AnyObject</code>和<code>class</code>、被<code>@objc</code>修饰的协议是<strong>只能被class继承的协议</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable1</span>: <span class="title">AnyObject</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable2</span>: <span class="title">class</span> </span>&#123; &#125;</span><br><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Runnable3</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p>被<code>@objc</code>修饰的协议，还可以暴露给OC去遵守实现。如果想要实现可选协议，方式有两种：</p>
<p>第一种：使用<code>@objc optional</code>修饰的方法名，不用必须实现</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">run2</span><span class="params">()</span></span> <span class="comment">//run2为可选方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run3</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run3</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种：给协议添加扩展,在扩展中给可选方法一个空实现，来间接实现可选协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run1</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run2</span><span class="params">()</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run3</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run1</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run3</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="objc-dynamic"><a href="#objc-dynamic" class="headerlink" title="@objc dynamic"></a>@objc dynamic</h2><p>在Swift中，可以给属性，方法等使用<code>@objc dynamic</code>修饰来，使其调用和访问是以objective-c的方式进行。被<code>@objc dynamic</code>修饰的内容会具有动态性。</p>
<ul>
<li><p>修饰方法，方法在调用时会走Runtime那一套流程。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不论类是否继承自NSObject,使用@objc dynamic修饰方法都会调用objc_msgSend</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="type">Dog</span>()</span><br><span class="line">d.test1() <span class="comment">//底层会走objc_msgSend()</span></span><br><span class="line">d.test2() <span class="comment">//底层会走Swift虚表调用方法</span></span><br></pre></td></tr></table></figure>

<img src="/2019/12/06/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%BB%8EOC%E8%BF%81%E7%A7%BB%E5%88%B0Swift/WX20201207-222303@2x.png" class="" title="This is an example image">
</li>
<li><p>修饰属性，支持KVC/KVO。但是有条件：</p>
<ul>
<li>属性所在的类、监听器最终继承自<code>NSobject</code></li>
<li>用<code>@objc dynamic</code>修饰对应的属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="keyword">self</span>.addObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">&quot;age&quot;</span>, options: .new, context: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(keyPath!,change![.newKey]!)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.removeObserver(<span class="keyword">self</span>, forKeyPath: <span class="string">&quot;age&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Person</span>()</span><br><span class="line">p.age = <span class="number">10</span><span class="comment">//age 10</span></span><br><span class="line">p.setValue(<span class="number">25</span>, forKey: <span class="string">&quot;age&quot;</span>)<span class="comment">//age 25</span></span><br></pre></td></tr></table></figure>

<p>当然Swift还支持block的方式进行KVO</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation?</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        <span class="comment">//keyPath这里要用 &quot;\&quot; + keyPath 的方式</span></span><br><span class="line">        observation = observe(\<span class="type">Person</span>.age, options: .new, changeHandler: &#123;</span><br><span class="line">            (person, change) <span class="keyword">in</span></span><br><span class="line">            <span class="built_in">print</span>(change.newValue <span class="keyword">as</span> <span class="type">Any</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Person</span>()</span><br><span class="line">p.age = <span class="number">10</span><span class="comment">//Optional(10)</span></span><br><span class="line">p.setValue(<span class="number">20</span>, forKey: <span class="string">&quot;age&quot;</span>)<span class="comment">//Optional(20)</span></span><br></pre></td></tr></table></figure>
<h2 id="关联对象"><a href="#关联对象" class="headerlink" title="关联对象"></a>关联对象</h2><p>在OC中，我们常用关联对象(Associated Object)来给扩展增加属性。在Swift中，class依然可以使用关联对象。</p>
<p><strong>默认情况下，extension不可以增加存储属性。但借助关联对象，可以实现类似extension为class增加存储属性的效果。</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">AGE_KEY</span>: <span class="type">Void?</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            (objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">Self</span>.<span class="type">AGE_KEY</span>) <span class="keyword">as</span>? <span class="type">Int</span>) ?? <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">Self</span>.<span class="type">AGE_KEY</span>, newValue, .<span class="type">OBJC_ASSOCIATION_ASSIGN</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="type">Student</span>()</span><br><span class="line">s.age = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(s.age)<span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<h2 id="多线程开发"><a href="#多线程开发" class="headerlink" title="多线程开发"></a>多线程开发</h2><p>iOS开发中自然是少不了多线程开发的了，说到多线程又不得不提GCD。Swift对于GCD也提供了支持。</p>
</li>
</ul>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>可以直接使用 <code>DispatchQueue.async</code>来执行</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以直接使用 .async + 尾随闭包的方式</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以将要做的操作封装成<code>DispatchWorkItem</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//也可以将尾随闭包封装成DispatchWorkItem</span></span><br><span class="line"><span class="keyword">let</span> todoItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步执行todoItem</span></span><br><span class="line"><span class="type">DispatchQueue</span>.global().async(execute: todoItem)</span><br><span class="line"><span class="comment">//todoItem执行完成后，再次回调主线程执行操作</span></span><br><span class="line">todoItem.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4&quot;</span>,<span class="type">Thread</span>.current)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>Swift中，DispatchQueue也提供了延迟执行函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.0秒后执行</span></span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">2.0</span>,execute: todoItem)</span><br></pre></td></tr></table></figure>

<h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p><code>dispatch_once</code>在Swift中已经被废弃，取而代之。可以使用<strong>类型属性</strong>或者<strong>全局变量\常量</strong>，这两个默认自带<strong>lazy + dispatch_once</strong>的效果</p>
<p>第一种：使用类型属性</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedHelper : <span class="type">Helper</span> = &#123;</span><br><span class="line">        <span class="type">Helper</span>()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Helper</span>.sharedHelper.address = <span class="string">&quot;adfdasf&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="type">Helper</span>.sharedHelper.address!) <span class="comment">//adfdasf</span></span><br></pre></td></tr></table></figure>

<p>第二种：使用全局变量或常量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sharedHelper : <span class="type">Helper</span> = &#123;</span><br><span class="line">    <span class="type">Helper</span>()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> address: <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sharedHelper.address = <span class="string">&quot;adfdasf&quot;</span></span><br><span class="line"><span class="built_in">print</span>(sharedHelper.address!) <span class="comment">//adfdasf</span></span><br></pre></td></tr></table></figure>

<h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><ul>
<li><p>GCD信号量</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> data = [<span class="type">String</span>:<span class="type">Any</span>]()</span><br><span class="line">    <span class="comment">//最多允许多个线程同时访问，value就填几</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> lock = <span class="type">DispatchSemaphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> key:String,<span class="number">_</span> value: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        lock.wait()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.signal() &#125;</span><br><span class="line">        data[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Foundation</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> data = [<span class="type">String</span>:<span class="type">Any</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> lock = <span class="type">NSLock</span>()</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> key:String,<span class="number">_</span> value: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        data[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> data = [<span class="type">String</span>:<span class="type">Any</span>]()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> lock = <span class="type">NSRecursiveLock</span>()</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">set</span><span class="params">(<span class="number">_</span> key:String,<span class="number">_</span> value: <span class="keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        lock.lock()</span><br><span class="line">        <span class="keyword">defer</span> &#123; lock.unlock() &#125;</span><br><span class="line">        data[key] = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E9%9D%A2%E9%87%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/13/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E9%9D%A2%E9%87%8F/" class="post-title-link" itemprop="url">Swift5学习笔记之字面量</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 15:06:22" itemprop="dateCreated datePublished" datetime="2019-11-13T15:06:22+08:00">2019-11-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> isRed = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>10</code>、<code>fasle</code>、<code>Jack</code>就是字面量</p>
</blockquote>
<p>Swift自带的绝大部分类型，都支持直接通过字面量进行初始化，比如<code>Bool</code>，<code>Int</code>，<code>Float</code>，<code>Double</code>，<code>String</code>，<code>Array</code>，<code>Dictionary</code>，<code>Set</code>，<code>Optional</code>等</p>
<p>常见的字面量的默认类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">IntegerLiteralType</span> = <span class="type">Int</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">FloatLiteralType</span> = <span class="type">Double</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">BooleanLiteralType</span> = <span class="type">Bool</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">StringLiteralType</span> = <span class="type">String</span></span><br></pre></td></tr></table></figure>

<p>这也就是为什么，在使用浮点数的时候，<code>swift</code>会推断成<code>Doulbe</code>类型，而不是<code>Float</code>类型。当然也可以通过<code>typealias</code>修改字面量的默认类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">FloatLiteralType</span> = <span class="type">Float</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">1.68</span> <span class="comment">//Float</span></span><br></pre></td></tr></table></figure>

<h2 id="字面量协议"><a href="#字面量协议" class="headerlink" title="字面量协议"></a>字面量协议</h2><p><code>swift</code>自带类型之所以能够通过字面量初始化，是因为它们遵守了对应的协议。这些协议通常只包含一个构造函数，构造函数的参数即为字面量。</p>
<p><code>swift</code>常见的自带类型中遵守的协议：</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">遵守的字面量协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Bool</td>
<td align="center">ExpressibleByBooleanLiteral</td>
</tr>
<tr>
<td align="center">Int</td>
<td align="center">ExpressibleByIntegerLiteral</td>
</tr>
<tr>
<td align="center">Float、Double</td>
<td align="center">ExpressibleByIntegerLiteral、ExpressibleByFloatLiteral</td>
</tr>
<tr>
<td align="center">Dictionary</td>
<td align="center">ExpressibleByDictionaryLiteral</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">ExpressibleByStringLiteral</td>
</tr>
<tr>
<td align="center">Array，Set</td>
<td align="center">ExpressibleByArrayLiteral</td>
</tr>
<tr>
<td align="center">Optional</td>
<td align="center">ExpressibleByNilLiteral</td>
</tr>
</tbody></table>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr: <span class="type">Array</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span>: <span class="type">Set</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="字面量协议的应用"><a href="#字面量协议的应用" class="headerlink" title="字面量协议的应用"></a>字面量协议的应用</h2><p>在<code>swift</code>中，可以让类型遵守相关协议，实现相应的构造函数，来达到通过字面量值初始化变量的目的。有点类似于C++中的转换构造函数。</p>
<p>举几个🌰：</p>
<p>1 允许<code>Int</code>类型可以使用布尔类型复制，<code>true</code> 为1，<code>false</code>为0</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> : <span class="title">ExpressibleByBooleanLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(booleanLiteral value: <span class="type">Bool</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span> = value ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age: <span class="type">Int</span> = <span class="literal">true</span></span><br><span class="line"><span class="built_in">print</span>(age) <span class="comment">//1</span></span><br><span class="line">age = <span class="literal">false</span></span><br><span class="line"><span class="built_in">print</span>(age) <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>2 允许<code>Student</code>类，通过整数，浮点型和字符串初始化</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">ExpressibleByFloatLiteral</span>,<span class="title">ExpressibleByIntegerLiteral</span>,<span class="title">ExpressibleByStringLiteral</span>,<span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(floatLiteral value: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.score = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(integerLiteral value: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.score = <span class="type">Double</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;name=\(name),score=\(score)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu:<span class="type">Student</span> = <span class="number">90</span></span><br><span class="line"><span class="built_in">print</span>(stu) <span class="comment">//name=,score=90.0</span></span><br><span class="line">stu = <span class="number">98.5</span></span><br><span class="line"><span class="built_in">print</span>(stu) <span class="comment">//name=,score=98.5</span></span><br><span class="line">stu = <span class="string">&quot;Kaka&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu) <span class="comment">//name=Kaka,score=0.0</span></span><br></pre></td></tr></table></figure>

<p>3 允许<code>Point</code>结构体，通过数组和字典来初始化</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> : <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="string">&quot;x=\(x),y=\(y)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">ExpressibleByArrayLiteral</span>, <span class="title">ExpressibleByDictionaryLiteral</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(arrayLiteral elements: <span class="type">Double</span>...) &#123;</span><br><span class="line">        <span class="keyword">guard</span> elements.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.x = elements[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">guard</span> elements.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">self</span>.y = elements[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">String</span>, <span class="type">Double</span>)...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (k,v) <span class="keyword">in</span> elements &#123;</span><br><span class="line">            <span class="keyword">if</span> k == <span class="string">&quot;x&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.x = v</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> k == <span class="string">&quot;y&quot;</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.y = v</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point: <span class="type">Point</span> = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(point) <span class="comment">//x=1.0,y=2.0</span></span><br><span class="line">point = [<span class="string">&quot;x&quot;</span>: <span class="number">11</span>, <span class="string">&quot;y&quot;</span>: <span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(point) <span class="comment">//x=11.0,y=22.0</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/13/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/" class="post-title-link" itemprop="url">Swift5学习笔记之模式匹配</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-13 15:06:22" itemprop="dateCreated datePublished" datetime="2019-11-13T15:06:22+08:00">2019-11-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><code>Swfit</code>中，模式是用于匹配的规则。比如,<code>switch</code>的<code>case</code>、捕捉错误的<code>catch</code>、<code>if</code>、<code>guard</code>、<code>while</code>、<code>for</code>语句的条件等。</p>
<p><code>Swift</code>中的模式有：</p>
<ul>
<li>通配符模式(Wildcard Pattern)</li>
<li>标识符模式(Identifier Pattern)</li>
<li>值绑定模式(Value-Binding Pattern)</li>
<li>元组模式(Tuple Pattern)</li>
<li>枚举Case模式(Enumeration Case Pattern)</li>
<li>可选模式(Optional Pattern)</li>
<li>类型转换模式(Type-Casting Pattern)</li>
<li>表达式模式(Expression Pattern)</li>
</ul>
<h2 id="通配符模式"><a href="#通配符模式" class="headerlink" title="通配符模式"></a>通配符模式</h2><p><code>Swift</code>中有很多使用<code>_</code>和<code>_?</code>。</p>
<p><code>_</code> ：匹配任何值，不管是否为<code>nil</code></p>
<p><code>_?</code> ：匹配非<code>nil</code>值</p>
<p>举个栗子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Life</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> human(name: <span class="type">String</span>, age: <span class="type">Int?</span>)</span><br><span class="line">    <span class="keyword">case</span> animal(name: <span class="type">String</span>, age: <span class="type">Int?</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chcek</span><span class="params">(<span class="number">_</span> life: Life)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> life &#123;</span><br><span class="line">    <span class="keyword">case</span> .human(<span class="keyword">let</span> name, <span class="number">_</span>): <span class="comment">//匹配 .human,并把关联的name值复制给let name</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;human:&quot;</span>, name)</span><br><span class="line">    <span class="keyword">case</span> .animal(<span class="keyword">let</span> name, <span class="number">_</span>?): <span class="comment">//匹配 .animal并且age值不为nil,并把关联的name值复制给let name</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;animal:&quot;</span>,name)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">chcek(<span class="type">Life</span>.animal(name: <span class="string">&quot;aidi&quot;</span>, age: <span class="literal">nil</span>)) <span class="comment">//other</span></span><br><span class="line">chcek(<span class="type">Life</span>.human(name: <span class="string">&quot;Jock&quot;</span>, age: <span class="literal">nil</span>))   <span class="comment">//human: Jock</span></span><br><span class="line">chcek(<span class="type">Life</span>.animal(name: <span class="string">&quot;Lili&quot;</span>, age: <span class="number">30</span>))   <span class="comment">//animal: Lili</span></span><br></pre></td></tr></table></figure>

<p>并且<code>?</code>在可选项模式中，很多时候都代表非空，比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v: <span class="type">Int?</span> = <span class="number">29</span></span><br><span class="line"><span class="keyword">switch</span> v &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> v?: <span class="comment">//非空时匹配，并且将值赋值给v</span></span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line"><span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">//为nil时匹配</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="标识符模式"><a href="#标识符模式" class="headerlink" title="标识符模式"></a>标识符模式</h2><p>给对应的变量、常量名赋值，就是常见的标识符模式</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">20</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Jack&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="值绑定模式"><a href="#值绑定模式" class="headerlink" title="值绑定模式"></a>值绑定模式</h2><p>值绑定模式就类似于下列</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> point = (<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> point &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span>(x,y): <span class="comment">//将point.0 赋值给x,将point.1赋值给y</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This point at \(x) ,\(y)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="元组模式"><a href="#元组模式" class="headerlink" title="元组模式"></a>元组模式</h2><p><strong>元组模式</strong>是逗号分隔的列表，包含一个或多个模式，并包含在一对圆括号中。<strong>元组模式</strong>匹配相应元组类型的值。也可以使用类型注释来限制一个<strong>元组模式</strong>来匹配某种元组类型。</p>
<p>举几个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//points 数组中存储的就是 (Int,Int)类型的元组</span></span><br><span class="line"><span class="keyword">let</span> points = [(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">2</span>,<span class="number">0</span>)]</span><br><span class="line"><span class="keyword">for</span> (x,<span class="number">_</span>) <span class="keyword">in</span> points &#123; <span class="comment">//遍历是将元组的第一个值赋值给x，忽略第二个值</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="type">String?</span> = <span class="string">&quot;jack&quot;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">var</span> info: <span class="type">Any</span> = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">switch</span> (name, age, info) &#123; <span class="comment">//将name,age,info组成一个元组</span></span><br><span class="line"><span class="keyword">case</span> (<span class="number">_</span>?, <span class="number">_</span>, <span class="number">_</span> <span class="keyword">as</span> <span class="type">String</span>): <span class="comment">//匹配 第一个值为非nil值，第二个任意，第三个可以强转成String类型</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;case&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = [<span class="string">&quot;jack&quot;</span>: <span class="number">98</span>, <span class="string">&quot;rose&quot;</span>: <span class="number">100</span>, <span class="string">&quot;kate&quot;</span>: <span class="number">86</span>]</span><br><span class="line"><span class="comment">//forin循环scores字典，一般都是 for Dictionary.Element in scores</span></span><br><span class="line"><span class="comment">//这里将Dictionary.Element中的key赋值给name</span></span><br><span class="line"><span class="comment">//这里将Dictionary.Element中的Value赋值给score</span></span><br><span class="line"><span class="keyword">for</span> (name, score) <span class="keyword">in</span> scores &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\(name) : \(score)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举Case模式"><a href="#枚举Case模式" class="headerlink" title="枚举Case模式"></a>枚举Case模式</h2><h3 id="if-case"><a href="#if-case" class="headerlink" title="if case"></a>if case</h3><p><code>if case</code>语句等价于只有1个<code>case</code>的<code>switch</code>语句</p>
<p>我们以一个整型常量为例</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>以往判断<code>number</code>的值的范围，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> number &gt;= <span class="number">0</span> &amp;&amp; number &lt;= <span class="number">9</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[0 , 9]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用<code>if case</code>来匹配判断：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="number">0</span>...<span class="number">9</span> = number &#123; <span class="comment">//使用case 0...9 匹配等号右边的值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[0 , 9]&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">switch</span> number &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>...<span class="number">9</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;[0, 9]&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然<code>guard</code>同样可以使用<code>Case</code>模式来匹配，<code>guard case</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">case</span> <span class="number">0</span>...<span class="number">9</span> = number <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;[0, 9]&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="for-in-中的case匹配"><a href="#for-in-中的case匹配" class="headerlink" title="for-in 中的case匹配"></a>for-in 中的case匹配</h3><p><code>Swift</code>中使用<code>for-in</code>遍历的时候，对于遍历的每一项也可以使用<code>case</code>来匹配</p>
<p>举几个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ages: [<span class="type">Int?</span>] = [<span class="number">2</span>,<span class="number">3</span>,<span class="literal">nil</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">//for-in 来遍历ages中的每一项</span></span><br><span class="line"><span class="comment">// 使用 case nil 来匹配 ages[i]</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="literal">nil</span> <span class="keyword">in</span> ages &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;有nil值&quot;</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pointArray = [(<span class="number">1</span>,<span class="number">0</span>), (<span class="number">2</span>,<span class="number">1</span>), (<span class="number">3</span>, <span class="number">0</span>)]</span><br><span class="line"><span class="comment">//for-in 来遍历pointArray中的每一项</span></span><br><span class="line"><span class="comment">//使用 case let (x,0)  来匹配,第二个值为0,并且使用值绑定将第一个值赋值给x</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">0</span>) <span class="keyword">in</span> pointArray &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;x = \(x)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> pointArray &#123;</span><br><span class="line">    <span class="keyword">switch</span> temp &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> (x, <span class="number">0</span>):</span><br><span class="line">        <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可选模式"><a href="#可选模式" class="headerlink" title="可选模式"></a>可选模式</h2><p>在<code>Swift</code>中，可选项本身也是使用枚举实现的。如果匹配可选项可以使用<code>.some(let x)</code>或<code>let x?</code>匹配非空值，<code>.none</code>或<code>nil</code>匹配空值。</p>
<p>另外，<code>_?</code> ：匹配非<code>nil</code>值</p>
<p><code>_</code> ：匹配任何值，不管是否为<code>nil</code></p>
<p>举几个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aNumber: <span class="type">Int?</span> = <span class="number">42</span></span><br><span class="line"><span class="comment">//case .some(let x)，匹配非空值，并且使用值绑定赋值给x</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> .some(<span class="keyword">let</span> x) = aNumber &#123; <span class="built_in">print</span>(x) &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers: [<span class="type">Int?</span>] = [<span class="literal">nil</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="literal">nil</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">//使用 let number?，匹配非空值，并且使用值绑定赋值给number</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">let</span> number? <span class="keyword">in</span> numbers &#123;</span><br><span class="line">    <span class="built_in">print</span>(number) <span class="comment">//2 3 5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> aNumber = number &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;:&quot;</span>,aNumber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(<span class="number">_</span> num: Int?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> num &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>?:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>?:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>?:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;6&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span>?:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;other&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">_</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;nil&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">check(<span class="number">4</span>)<span class="comment">//4</span></span><br><span class="line">check(<span class="number">8</span>)<span class="comment">//other</span></span><br><span class="line">check(<span class="literal">nil</span>)<span class="comment">//nil</span></span><br></pre></td></tr></table></figure>

<h2 id="类型转换模式"><a href="#类型转换模式" class="headerlink" title="类型转换模式"></a>类型转换模式</h2><p>在<code>Swift</code>中，可以使用<code>is Type</code>来判断变量的类型，但不会转换类的类型。如果要转换类型可以使用<code>as Type</code></p>
<p>举几个例子：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num:<span class="type">Any</span> = <span class="number">6.0</span></span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Int</span>: <span class="comment">//使用is Int来判断num是否为Int类型，但编译器并不会改变num的类型，依旧是Any</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;is Int&quot;</span>,num) </span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> n <span class="keyword">as</span> <span class="type">Double</span>:<span class="comment">//如果num可以强转成Double，使用as Double来强转，并赋值给n,</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;as Double&quot;</span>,n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="function"><span class="keyword">func</span> <span class="title">eat</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(type(of: <span class="keyword">self</span>), <span class="string">&quot;eat&quot;</span>) &#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="built_in">print</span>(type(of: <span class="keyword">self</span>),<span class="string">&quot;run&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>: <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="built_in">print</span>(type(of: <span class="keyword">self</span>),<span class="string">&quot;jump&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(<span class="number">_</span> animal: Animal)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> animal &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> dog <span class="keyword">as</span> <span class="type">Dog</span>: <span class="comment">//这里进行了强转，类似于 let dog = (Dog)animal</span></span><br><span class="line">        dog.eat()</span><br><span class="line">        dog.run()</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">is</span> <span class="type">Cat</span>:</span><br><span class="line">        animal.eat()</span><br><span class="line">    <span class="keyword">default</span>:<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="表达式模式"><a href="#表达式模式" class="headerlink" title="表达式模式"></a>表达式模式</h2><p>表达式模式用在<code>case</code>中，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aPoint = (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">switch</span> aPoint &#123;</span><br><span class="line"><span class="keyword">case</span> (<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(0,0) is at the origin&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> (-<span class="number">2</span>...<span class="number">2</span>,-<span class="number">2</span>...<span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(\(aPoint.0),\(aPoint.1)) is near origin&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The point is at (\(aPoint.0),\(aPoint.1)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义表达式模式"><a href="#自定义表达式模式" class="headerlink" title="自定义表达式模式"></a>自定义表达式模式</h3><p>运行后可以看到<code>case (-2...2,-2...2):</code>匹配成功，那么为啥这样写可以匹配成功呢。通过分析汇编可以看到<code>Swift</code>底层调用了<code>~=</code>运算符。这就说明，如果对某个类型重载运算符<code>~=</code>，就可以自定义表达式模式的匹配规则。</p>
<p>比如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ~= <span class="params">(pattern: Int, value: Student)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        value.score &gt;= pattern</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ~= <span class="params">(pattern: ClosedRange&lt;Int&gt;, value: Student)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        pattern.<span class="built_in">contains</span>(value.score)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ~= <span class="params">(pattern: Range&lt;Int&gt;, value: Student)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        pattern.<span class="built_in">contains</span>(value.score)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="type">Student</span>(score: <span class="number">75</span>, name: <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> stu &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">100</span>: <span class="built_in">print</span>(<span class="string">&quot;&gt;=100&quot;</span>) <span class="comment">//根据case后面值不同的类型调用 ~=：pattern: Int</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">90</span>: <span class="built_in">print</span>(<span class="string">&quot;&gt;=90&quot;</span>) <span class="comment">//pattern: Int</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">80</span>..&lt;<span class="number">90</span>: <span class="built_in">print</span>(<span class="string">&quot;[80,90)&quot;</span>) <span class="comment">//pattern: Range&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">60</span>...<span class="number">79</span>: <span class="built_in">print</span>(<span class="string">&quot;[60,79]&quot;</span>) <span class="comment">//pattern: ClosedRange&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">print</span>(<span class="string">&quot;&gt;=0&quot;</span>) <span class="comment">//pattern: Int</span></span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125; <span class="comment">//[60,79]</span></span><br></pre></td></tr></table></figure>

<p>可以看出如果想要自定义表达式模式，重载运算符<code>~=</code>,并且参数为<code>pattern</code>与<code>value</code>，返回一个<code>Bool</code>值。其中<code>pattern</code>为<code>case</code>后面的值，<code>value</code>为<code>switch</code>的值。返回值为<code>true</code>的话，则<code>case</code>匹配成功。当然这种方式也适用于<code>if case</code>或者<code>case let</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">case</span> <span class="number">60</span> = stu &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;=60&quot;</span>)</span><br><span class="line">&#125; <span class="comment">//&gt;=60</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> infoGroup = (<span class="type">Student</span>(score: <span class="number">70</span>, name: <span class="string">&quot;Jack&quot;</span>),<span class="string">&quot;及格&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> infoGroup &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (<span class="number">60</span>,text): <span class="comment">//Student(score: 70, name: &quot;Jack&quot;) 与 60匹配，并且将&quot;及格&quot;赋值给text</span></span><br><span class="line">    <span class="built_in">print</span>(text)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;  <span class="comment">//及格</span></span><br></pre></td></tr></table></figure>

<p>当然，<code>pattern</code>的类型也可以是函数。即，<code>case</code>后面使用函数进行匹配。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ~=<span class="params">(pattern: <span class="params">(String)</span></span></span> -&gt; <span class="type">Bool</span>, value: <span class="type">String</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        pattern(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPrefix</span><span class="params">(<span class="number">_</span> <span class="keyword">prefix</span>: String)</span></span> -&gt; ((<span class="type">String</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">//这个in就是为了分开函数的参数和函数体的一个固定语法，这个语法只在回调函数中使用。</span></span><br><span class="line">        <span class="comment">//因为返回值的类型是确定的，(String) -&gt; Bool,所以str是String类型</span></span><br><span class="line">        <span class="comment">//当然也可以不写这个In来声明形参，直接使用$0来代表第一个参数</span></span><br><span class="line">         str <span class="keyword">in</span></span><br><span class="line">            str.hasPrefix(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的函数可以简写为如下：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPrefixShort</span><span class="params">(<span class="number">_</span> <span class="keyword">prefix</span>: String)</span></span> -&gt; ((<span class="type">String</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        $<span class="number">0</span>.hasPrefix(<span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasSuffix</span><span class="params">(<span class="number">_</span> suffix: String)</span></span> -&gt; ((<span class="type">String</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        aString <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> aString.hasSuffix(suffix)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面的函数可以简写为：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasSuffixShort</span><span class="params">(<span class="number">_</span> suffix: String)</span></span> -&gt; ((<span class="type">String</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    &#123; $<span class="number">0</span>.hasSuffix(suffix) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherString = <span class="string">&quot;Jack&quot;</span></span><br><span class="line"><span class="keyword">switch</span> otherString &#123;</span><br><span class="line"><span class="keyword">case</span> hasSuffix(<span class="string">&quot;k&quot;</span>),hasPrefix(<span class="string">&quot;J&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;以k结尾或以J开头&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125;  <span class="comment">//以k结尾或以J开头</span></span><br></pre></td></tr></table></figure>

<p>再例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ~= <span class="params">(pattern: <span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>, value: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        pattern(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> otherNumber = <span class="number">9</span></span><br><span class="line"><span class="keyword">switch</span> otherNumber &#123;</span><br><span class="line"><span class="keyword">case</span> isEven: <span class="comment">//这i1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是偶数&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> isOdd:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;是奇数&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125; <span class="comment">//是奇数</span></span><br></pre></td></tr></table></figure>

<p>甚至，<code>case</code>也可以匹配自定义表达式符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&gt;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&gt;=</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&lt;</span><br><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> ~&lt;=</span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ~&gt;<span class="params">(<span class="number">_</span> i: Int)</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        number <span class="keyword">in</span></span><br><span class="line">            number &gt; i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ~&gt;=<span class="params">(<span class="number">_</span> i: Int)</span></span> -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    &#123; $<span class="number">0</span> &gt;= i &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ~&lt;(_ i: Int) -&gt; <span class="params">(<span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    &#123; $<span class="number">0</span> &lt; i &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ~&lt;=(_ i: Int) -&gt; <span class="params">(<span class="params">(Int)</span></span></span> -&gt; <span class="type">Bool</span>) &#123;</span><br><span class="line">    &#123; $<span class="number">0</span> &lt;= i &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> number2 = <span class="number">6</span></span><br><span class="line"><span class="keyword">switch</span> number2 &#123;</span><br><span class="line"><span class="keyword">case</span> ~&gt;=<span class="number">0</span>: <span class="built_in">print</span>(<span class="string">&quot;大于等于0&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> ~&gt;<span class="number">10</span>: <span class="built_in">print</span>(<span class="string">&quot;大于10&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125; <span class="comment">//大于等于0</span></span><br></pre></td></tr></table></figure>

<h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><p>可以使用<code>where</code>为模式匹配增加匹配条件，通常用在以下几个地方：</p>
<ul>
<li><p>使用<code>case</code>匹配时</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = (<span class="number">10</span>,<span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> data &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (age, <span class="number">_</span>) <span class="keyword">where</span> age &gt; <span class="number">10</span>:</span><br><span class="line">    <span class="built_in">print</span>(data.<span class="number">1</span>, <span class="string">&quot;age&gt;10&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> (age, <span class="number">_</span>) <span class="keyword">where</span> age &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(data.<span class="number">1</span>, <span class="string">&quot;age&gt;0&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="keyword">break</span></span><br><span class="line">&#125;<span class="comment">// Jack age&gt;0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>for</code>循环的时候</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> theNumbers = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">44</span>,<span class="number">23</span>,<span class="number">55</span>]</span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> theNumbers <span class="keyword">where</span> number &gt; <span class="number">30</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(number)</span><br><span class="line">&#125;<span class="comment">//44 55</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用关联类型的时候，对关联的类型加以限制</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Stackable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Element</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Stack</span>: <span class="type">Stackable</span> <span class="keyword">where</span> <span class="type">Stack</span>.<span class="type">Element</span>: <span class="type">Equatable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在方法声明中使用泛型，对泛型的类型加以限制</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">equal</span>&lt;S1: Stackable,S2: Stackable&gt;<span class="params">(<span class="number">_</span> s1: S1,<span class="number">_</span> s2: S2)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="keyword">where</span> <span class="type">S1</span>.<span class="type">Element</span> == <span class="type">S2</span>.<span class="type">Element</span>, <span class="type">S1</span>.<span class="type">Element</span>: <span class="type">Hashable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对有关联类型中的协议进行扩展时，对关联类型加以限制</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Container</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">Stack</span>.<span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/22/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/22/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Swift5学习笔记之内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-22 11:04:06" itemprop="dateCreated datePublished" datetime="2019-10-22T11:04:06+08:00">2019-10-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>跟<code>OC</code>一样，<code>Swfit</code>也是采取基于引用计数的ARC内存管理方案(针对堆空间)</li>
<li><code>Swfit</code>的ARC中有3种引用<ul>
<li>强引用(strong reference): 默认情况下，引用都是强引用</li>
<li>弱引用(weak refierence): 通过<code>weak</code>定义弱引用<ul>
<li>弱引用必须是可选类型的<code>var</code>，因为实例销毁后，ARC会自动将弱引用设置为<code>nil</code></li>
<li>ARC自动给弱引用设置<code>nil</code>时，不会触发属性观察器</li>
</ul>
</li>
<li>无主引用(unowend reference)：通过<code>unowned</code>定义无主引用<ul>
<li>不会产生强引用，实例销毁后仍然存储着实例的内存地址(类似于OC中的<code>unsafe_unretained</code>)</li>
<li>试图在实例销毁后访问无主引用，会产生运行时错误(野指针)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="weak、unowned的使用限制"><a href="#weak、unowned的使用限制" class="headerlink" title="weak、unowned的使用限制"></a>weak、unowned的使用限制</h2><ul>
<li><p><code>weak</code>，<code>unowned</code>只能用在类实例上面</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AnyObject代表只能用类实现该实例</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Liveable</span>: <span class="title">AnyObject</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p0: <span class="type">Person?</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p1: <span class="type">AnyObject?</span></span><br><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> p2: <span class="type">Liveable?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p10: <span class="type">Person?</span></span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">let</span> p11: <span class="type">Person</span></span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p12: <span class="type">AnyObject</span></span><br><span class="line"><span class="keyword">unowned</span> <span class="keyword">var</span> p13: <span class="type">Liveable</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Autoreleasepool"><a href="#Autoreleasepool" class="headerlink" title="Autoreleasepool"></a>Autoreleasepool</h2><p><code>Swift</code>中也保留了<code>Autoreleasepool</code>。<code>Autoreleasepool</code>是一个全局函数，</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autoreleasepool的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">autoreleasepool</span>&lt;Result&gt;<span class="params">(invoking body: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure>

<p>在使用上，调用<code>autoreleasepool</code>函数，传入一个尾随闭包即可。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">autoreleasepool &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="type">Person</span>()</span><br><span class="line">    p.run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环引用-Reference-Cycle"><a href="#循环引用-Reference-Cycle" class="headerlink" title="循环引用(Reference Cycle)"></a>循环引用(Reference Cycle)</h2><p><code>weak</code>、<code>unowned</code>都能解决循环引用的问题，<code>unowned</code>要比<code>weak</code>少一些性能消耗(因为<code>unowned</code>不需要置为<code>nil</code>)</p>
<ul>
<li>在生命周期中可能会变为<code>nil</code>的使用<code>weak</code></li>
<li>初始化赋值后再也不会变为<code>nil</code>的使用<code>unowned</code></li>
</ul>
<h2 id="闭包的循环引用"><a href="#闭包的循环引用" class="headerlink" title="闭包的循环引用"></a>闭包的循环引用</h2><p>闭包表达式默认会对用到的外层对象产生额外的强引用(对外层对象进行<code>retain</code>操作)</p>
<p><em>下面代码会产生循环引用，导致<code>Person</code>对象无法释放</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn: (() -&gt; ())?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="type">Person</span>()</span><br><span class="line">    p.fn = &#123; p.run() &#125;</span><br><span class="line">    <span class="comment">//p.fn?()</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>在闭包表达式的<strong>捕获列表</strong>声明<code>weak</code>或<code>unowened</code>引用，解决循环引用问题。使用<code>weak</code>要使用可选项，<code>unowened</code>不用</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn: (() -&gt; ())?</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="type">Person</span>()</span><br><span class="line">    p.fn = &#123;</span><br><span class="line">      [<span class="keyword">weak</span> p] <span class="keyword">in</span> </span><br><span class="line">      p?.run()</span><br><span class="line">    &#125;</span><br><span class="line">  p.fn = &#123;</span><br><span class="line">    [<span class="keyword">weak</span> weakP = p] <span class="keyword">in</span></span><br><span class="line">    weakP?.run()</span><br><span class="line">  &#125;</span><br><span class="line">  p.fn = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> p] <span class="keyword">in</span></span><br><span class="line">      p.run()</span><br><span class="line">  &#125;</span><br><span class="line">  p.fn = &#123;</span><br><span class="line">    [<span class="keyword">weak</span> wp = p, <span class="keyword">unowned</span> up = p, a = <span class="number">10</span> + <span class="number">20</span>] <span class="keyword">in</span></span><br><span class="line">    wp?.run()</span><br><span class="line">    up.run()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>

<p>如果想在定义闭包属性的同时引用<code>self</code>，这个闭包必须是<code>lazy</code>的(因为在实例初始化完毕之后才能引用<code>self</code>)。闭包函数内如果用的实例成员(属性、方法)，编译器会强制要求明确写出<code>self</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> fn: (() -&gt; ()) = &#123;</span><br><span class="line">        [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.run()  <span class="comment">//编译器要求强制写明self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; <span class="built_in">print</span>(<span class="string">&quot;run&quot;</span>) &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;Student run&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>lazy</code>属性是闭包调用的结果，那么不用考虑循环引用的问题(因为闭包调用后，闭包的生命周期就结束了)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wirtor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> getAge: <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">self</span>.age </span><br><span class="line">    &#125;()  <span class="comment">//这个加了 (),代表这个闭包表达式运行返回结果。</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">&quot;wirtor deinit&quot;</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逃逸闭包与非逃逸闭包"><a href="#逃逸闭包与非逃逸闭包" class="headerlink" title="逃逸闭包与非逃逸闭包"></a>逃逸闭包与非逃逸闭包</h2><p>逃逸闭包、非逃逸闭包，一般都是当做参数传递给函数</p>
<p><strong>非逃逸闭包</strong>：闭包调用发生在函数结束前，闭包调用在函数作用域内</p>
<p><strong>逃逸闭包</strong>：闭包有可能在函数结束后调用，闭包调用逃离了函数的作用域，需要通过<code>@eacaping</code>声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fn是非逃逸闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(<span class="number">_</span> fn: Fn)</span></span> &#123; fn() &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fn是逃逸闭包</span></span><br><span class="line"><span class="keyword">var</span> gFn: <span class="type">Fn?</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(<span class="number">_</span> fn: @escaping Fn)</span></span> &#123;</span><br><span class="line">    gFn = fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fn是逃逸闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">(<span class="number">_</span> fn: @escaping Fn)</span></span> &#123;</span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">        fn()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逃逸闭包内如果访问实例的成员（属性、方法），编译器会强制要求写明<code>self</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn: <span class="type">Fn</span></span><br><span class="line">    <span class="comment">//fn是一个逃逸闭包</span></span><br><span class="line">    <span class="keyword">init</span>(fn: @escaping <span class="type">Fn</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//DispatchQueue.global().async 也是一个逃逸闭包</span></span><br><span class="line">        <span class="comment">//它用到了实例成员(属性，方法)，编译器会要强制写明self</span></span><br><span class="line">        <span class="comment">//写明self的作用</span></span><br><span class="line">        <span class="comment">//1：逃逸闭包会对实例产生强引用，不至于等到逃逸闭包执行时，实例被销毁了</span></span><br><span class="line">        <span class="comment">//2：提醒开发者在逃逸闭包访问实例时，是不是要使用weak</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">            <span class="keyword">self</span>.fn()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<strong>逃逸闭包不能捕获<code>inout</code>参数</strong>，因为逃逸闭包执行时机不确定，而通过<code>inout</code>传入的内存地址存在，无法保证在逃逸闭包执行时还是有效的。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Fn</span> = () -&gt; ()</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other1</span><span class="params">(<span class="number">_</span> fn: Fn)</span></span> &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">other2</span><span class="params">(<span class="number">_</span> fn: @escaping Fn)</span></span> &#123;</span><br><span class="line">    fn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testInout</span><span class="params">(value: <span class="keyword">inout</span> Int)</span></span> -&gt; <span class="type">Fn</span> &#123;</span><br><span class="line">    other1 &#123;</span><br><span class="line">        value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    other2 &#123; <span class="comment">//Error: Escaping closure captures &#x27;inout&#x27; parameter &#x27;value&#x27;</span></span><br><span class="line">        value += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">plus</span><span class="params">()</span></span> &#123;</span><br><span class="line">        value += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plus <span class="comment">//Error: Escaping closure captures &#x27;inout&#x27; parameter &#x27;value&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存访问冲突"><a href="#内存访问冲突" class="headerlink" title="内存访问冲突"></a>内存访问冲突</h2><p>这里说的内存访问冲突，并非是在多线程的的情况，当两个访问满足下列条件时就会发生：</p>
<ol>
<li>至少是一个写入操作</li>
<li>他们访问的是同一块内存</li>
<li>他们的访问时间重叠(比如在同一个函数内)</li>
</ol>
<p>这种操作在其他语言也许是可以的，但<code>swift</code>中，编译器检测出这种操作就会报错，即便没有检测出也会在运行时报错。举几个🌰来说明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> step = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(<span class="number">_</span> num: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果传入的参数就是step,</span></span><br><span class="line">    <span class="comment">//那么这里对step即进行了读取，也进行了写入的操作</span></span><br><span class="line">    num = num + step</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存在访问冲突</span></span><br><span class="line"><span class="comment">//Simultaneous accesses to 0x10000c8c8,but modification requires exclusive access</span></span><br><span class="line">increment(&amp;step)</span><br></pre></td></tr></table></figure>

<p>再例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">balance</span><span class="params">(<span class="number">_</span> x: <span class="keyword">inout</span> Int, <span class="number">_</span> y: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = x + y</span><br><span class="line">    x =  sum / <span class="number">2</span></span><br><span class="line">    y = sum - x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">30</span></span><br><span class="line">balance(&amp;num1, &amp;num2) <span class="comment">//OK</span></span><br><span class="line"><span class="comment">//balance(&amp;num1, &amp;num1) //Error</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> health: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> energy: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">shareHealth</span><span class="params">(with teammate: <span class="keyword">inout</span> Player)</span></span> &#123;</span><br><span class="line">        balance(&amp;teammate.health, &amp;health)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> oscar = <span class="type">Player</span>(name: <span class="string">&quot;Oscar&quot;</span>, health: <span class="number">10</span>, energy: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> maris = <span class="type">Player</span>(name: <span class="string">&quot;Maria&quot;</span>, health: <span class="number">5</span>, energy: <span class="number">10</span>)</span><br><span class="line">oscar.shareHealth(with: &amp;maris) <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//oscar.shareHealth(with: &amp;oscar) //Error</span></span><br><span class="line"><span class="keyword">var</span> tulpe = (health: <span class="number">10</span>,energy: <span class="number">20</span>)</span><br><span class="line"><span class="comment">//Error:Thread 1: Simultaneous accesses to 0x10000c928, but modification requires exclusive access</span></span><br><span class="line">balance(&amp;tulpe.health, &amp;tulpe.energy) </span><br></pre></td></tr></table></figure>

<p>如果下面的条件可以满足，就说明重叠访问结构体的属性是安全的</p>
<ul>
<li>只访问实例存储属性，不是计算属性或者类属性</li>
<li>结构体是局部变量而非全局变量</li>
<li>结构体要么没有被闭包捕获要么只被非逃逸闭包捕获</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">balance</span><span class="params">(<span class="number">_</span> x: <span class="keyword">inout</span> Int, <span class="number">_</span> y: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = x + y</span><br><span class="line">    x =  sum / <span class="number">2</span></span><br><span class="line">    y = sum - x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">accessCoTest</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tulpe = (health: <span class="number">10</span>,energy: <span class="number">20</span>)</span><br><span class="line">    balance(&amp;tulpe.health, &amp;tulpe.energy)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> holly = (name: <span class="string">&quot;Hello&quot;</span>,health: <span class="number">10</span>, energy: <span class="number">20</span>)</span><br><span class="line">    balance(&amp;holly.health, &amp;holly.energy)</span><br><span class="line">&#125;</span><br><span class="line">accessCoTest()</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="常见的四种指针类型"><a href="#常见的四种指针类型" class="headerlink" title="常见的四种指针类型"></a>常见的四种指针类型</h3><p><code>Swfit</code>中也有专门的指针类型，这些都被定义为”Unsafe”(不安全的),常见的有以下四种类型</p>
<ul>
<li><code>UnsafePointer&lt;Pointee&gt;</code> 类似于 <code>const Pointee *</code>。只读，类型确定，不能更改内存数据</li>
<li><code>UnsafeMutablePointer&lt;Pointee&gt;</code>类似于<code>Pointee *</code>。类型确定，内存数据可读可写。</li>
<li><code>UnsafeRowPointer</code> 类似于 <code>const void *</code>。只读，类型不确定，不能更改内存数据。</li>
<li><code>UnsafeMutableRowPointer</code> 类似于 <code>void *</code>。类型不确定，内存数据可读可写。</li>
</ul>
<p><strong>对于<code>UnsafePointer</code></strong></p>
<p><code>UnsafePointer</code>在使用时，必须指定泛型类型，否则会编译报错。通过<code>UnsafePointer.pointee</code>也可以读取到内存中存储的数据。当函数中参数是<code>UnsafePointer</code>时，传参时需要使用<code>&amp;</code>,例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merroyTest1</span><span class="params">(<span class="number">_</span> ptr: UnsafePointer&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//通过pointee属性获取该内存的值</span></span><br><span class="line">    <span class="built_in">print</span>(ptr.pointee) <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line">merroyTest1(&amp;age) </span><br></pre></td></tr></table></figure>

<p><strong>对于<code>UnsafeMutablePointer</code></strong></p>
<p><code>UnsafeMutablePointer</code>与<code>UnsafePointer</code>在使用时大体相同，不过<code>UnsafeMutablePointer</code>是可读写的，允许对内存中的数据进行读写,例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merroyTest2</span><span class="params">(<span class="number">_</span> ptr: UnsafeMutablePointer&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">    ptr.pointee += <span class="number">10</span> <span class="comment">//UnsafeMutablePointer.pointee,可读写</span></span><br><span class="line">    <span class="built_in">print</span>(ptr.pointee) <span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line">merroyTest2(&amp;age)</span><br><span class="line"><span class="built_in">print</span>(age) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p><strong>对于<code>UnsafeRawPointer</code></strong></p>
<p><code>UnsafeRawPointer</code>类型是不确定内存中数据类型的，但可以使用<code>load</code>方法进行类型转换，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merroyTest3</span><span class="params">(<span class="number">_</span> ptr: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(ptr.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">&#125;</span><br><span class="line">merroyTest3(&amp;age)<span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><strong>对于<code>UnsafeMutableRawPointer</code></strong></p>
<p>相比于<code>UnsafeRawPointer</code>，<code>UnsafeMutableRawPointer</code>可以使用<code>storeBytes</code>方法以指定的类型向内存中写入数据，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merroyTest4</span><span class="params">(<span class="number">_</span> ptr: UnsafeMutableRawPointer)</span></span> &#123;</span><br><span class="line">    ptr.storeBytes(of: <span class="number">20</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br><span class="line">merroyTest4(&amp;age)</span><br><span class="line"><span class="built_in">print</span>(age) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<h3 id="获得指向某个变量的指针"><a href="#获得指向某个变量的指针" class="headerlink" title="获得指向某个变量的指针"></a>获得指向某个变量的指针</h3><p><code>Swift</code>中提供了两个函数来获取变量的指针,下面是这两个函数的原型。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafeMutablePointer</span>&lt;T, Result&gt;<span class="params">(to value: <span class="keyword">inout</span> T, <span class="number">_</span> body: <span class="params">(UnsafeMutablePointer&lt;T&gt;)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br><span class="line"></span><br><span class="line">@inlinable <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">withUnsafePointer</span>&lt;T, Result&gt;<span class="params">(to value: <span class="keyword">inout</span> T, <span class="number">_</span> body: <span class="params">(UnsafePointer&lt;T&gt;)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure>

<p>这个两个函数从名字可以看出，一个是返回不可变指针的，一个是返回可变指针的。调用这两个函数第一个参数传入要获取指针的变量，第二个参数传入一个闭包表达式，这个闭包表达式，接受的参数就是第一个参数的地址值，并且这个闭包的返回值类型就是函数的返回值类型。函数的使用如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> ptr = <span class="built_in">withUnsafePointer</span>(to: &amp;age) &#123; (agePtr) -&gt; <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="comment">//使用形参agePtr来接收age的指针，并返回。</span></span><br><span class="line">       <span class="keyword">return</span> agePtr</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ptr的类型就是UnsafePointer&lt;Int&gt;</span></span><br><span class="line"><span class="built_in">print</span>(ptr) <span class="comment">//0x000000010000c9b0</span></span><br><span class="line"><span class="built_in">print</span>(ptr.pointee) <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以直接简写为一个尾随闭包</span></span><br><span class="line"><span class="keyword">var</span> agePtr = <span class="built_in">withUnsafePointer</span>(to: &amp;age) &#123; $<span class="number">0</span> &#125; <span class="comment">//$0代表第一个参数，直接返回</span></span><br><span class="line"><span class="built_in">print</span>(agePtr) <span class="comment">//0x000000010000c9b0</span></span><br><span class="line"><span class="built_in">print</span>(agePtr.pointee) <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p>还可以将变量的指针包装成<code>UnsafeMuatableRawPointer</code>和<code>UnsafeRawPointer</code>类型，来隐藏类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aNumber = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> ptr4 = <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;aNumber) &#123;</span><br><span class="line">    <span class="comment">//UnsafeMutableRawPointer的构造函数</span></span><br><span class="line">    <span class="type">UnsafeMutableRawPointer</span>($<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ptr4:&quot;</span>,ptr4.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)) <span class="comment">//ptr4: 20</span></span><br><span class="line">ptr4.storeBytes(of: <span class="number">2</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr3 = <span class="built_in">withUnsafePointer</span>(to: &amp;aNumber) &#123;</span><br><span class="line">    <span class="comment">//UnsafeRawPointer的构造函数</span></span><br><span class="line">    <span class="type">UnsafeRawPointer</span>($<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ptr3:&quot;</span>,ptr3.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))<span class="comment">//ptr3: 2</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用<strong>这个函数获取引用类型的地址值，但获取的并不是该引用类型在堆空间的地址值，而是获取引用类型变量的地址值</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Person4</span>()</span><br><span class="line"><span class="keyword">var</span> pptr = <span class="built_in">withUnsafePointer</span>(to: &amp;p) &#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="comment">//pptr 是 变量p的地址值</span></span><br><span class="line"><span class="built_in">print</span>(pptr) <span class="comment">//0x000000010000cb40</span></span><br><span class="line"><span class="built_in">print</span>(pptr.pointee.age) <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h3 id="获取指向堆空间实例的指针"><a href="#获取指向堆空间实例的指针" class="headerlink" title="获取指向堆空间实例的指针"></a>获取指向堆空间实例的指针</h3><p>在上一节中，使用<code>withUnsafePointer</code>函数**获取了引用类型变量本身的指针，并不是引用类型在堆空间的地址值。若要获取引用类型变型中保存的指向堆空间的地址值则需要通过<code>UnsafeRawPointer(bitPattern: )</code>**。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="type">Person4</span>()</span><br><span class="line"><span class="keyword">var</span> pptr = <span class="built_in">withUnsafePointer</span>(to: &amp;p) &#123; <span class="type">UnsafeRawPointer</span>($<span class="number">0</span>) &#125;</span><br><span class="line"><span class="comment">//pptr 是 变量p的地址值</span></span><br><span class="line"><span class="built_in">print</span>(pptr) <span class="comment">//0x0000000100010b60</span></span><br><span class="line"><span class="built_in">print</span>(pptr.load(<span class="keyword">as</span>: <span class="type">Person4</span>.<span class="keyword">self</span>)) <span class="comment">//Person4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> heapPtr = <span class="type">UnsafeRawPointer</span>(bitPattern: pptr.load(<span class="keyword">as</span>: <span class="type">UInt</span>.<span class="keyword">self</span>))</span><br><span class="line"><span class="built_in">print</span>(heapPtr!) <span class="comment">//0x0000000102155a80 堆空间地址值</span></span><br><span class="line"><span class="built_in">print</span>(heapPtr?.load(<span class="keyword">as</span>: <span class="type">Person4</span>.<span class="keyword">self</span>) <span class="keyword">as</span> <span class="type">Any</span>) <span class="comment">//Optional(Person4)</span></span><br></pre></td></tr></table></figure>

<p>也可以使用<code>unsafeBitCast</code>函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p4ptr = <span class="built_in">unsafeBitCast</span>(p, to: <span class="type">UnsafeRawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(p4ptr) <span class="comment">//0x0000000102155a80</span></span><br></pre></td></tr></table></figure>

<h3 id="创建指针"><a href="#创建指针" class="headerlink" title="创建指针"></a>创建指针</h3><p>上面讲的是已有一个在堆空间的变量，获取指向这个变量的指针。那么是否能直接向堆空间申请一段内存呢。答案是肯定的，<code>Swfit</code>同样也支持这样的操作，并且在<code>HandyJson</code>这个库中大量的使用了指针的代码。</p>
<h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p>引入<code>Foundtion</code>框架，使用<code>malloc</code>函数。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建，</span></span><br><span class="line"><span class="comment">//向堆空间申请16个字节的内存，</span></span><br><span class="line"><span class="comment">//返回 UnsafeMutableRawPointer? 类型的变量（可读写）</span></span><br><span class="line"><span class="keyword">var</span> myPtr = malloc(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//存</span></span><br><span class="line"><span class="comment">//默认从第一个字节开始存储，以Int型（8个字节），存入数据 11</span></span><br><span class="line">myPtr?.storeBytes(of: <span class="number">11</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="comment">//但是 myPtr 有16个自己，前面占用了8个，</span></span><br><span class="line"><span class="comment">//如果想操作后面的内存可以使用偏移量</span></span><br><span class="line"><span class="comment">//偏移8个字节，再以Int型（8个字节）存入数据22</span></span><br><span class="line">myPtr?.storeBytes(of: <span class="number">22</span>, toByteOffset: <span class="number">8</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//取</span></span><br><span class="line"><span class="comment">//以Int型（读取前8个字节）,获取指针中的数据,默认从第一个字节开始读取</span></span><br><span class="line"><span class="built_in">print</span>((myPtr?.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))!) <span class="comment">//11</span></span><br><span class="line"><span class="comment">//如果想从具体的某个字节数开始读，开始通过设置偏移量来完成</span></span><br><span class="line"><span class="comment">//偏移8个字节,再以Int(读取8个字节)型读取数据</span></span><br><span class="line"><span class="built_in">print</span>((myPtr?.load(fromByteOffset: <span class="number">8</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))!) <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后不要忘记销毁指针</span></span><br><span class="line">free(myPtr)</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p>使用<code>UnsafeMutalbeRawPointer.allocate</code>函数</p>
<blockquote>
<p>函数原型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// - Parameters:</span></span><br><span class="line"><span class="comment">///   - byteCount: 要分配的字节数，不能为负数</span></span><br><span class="line"><span class="comment">///   - alignment: 已分配内存的新区域的对齐方式，以字节为单位，一般填1就可以</span></span><br><span class="line"><span class="comment">/// - Returns: 指向新分配的内存区域的指针。内存已分配，但未初始化。</span></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allocate</span><span class="params">(byteCount: Int, alignment: Int)</span></span> -&gt; <span class="type">UnsafeMutableRawPointer</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请一个16字节内存空间,对齐方式一般填1</span></span><br><span class="line"><span class="keyword">var</span> myPtr2 = <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">8</span>, alignment: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//向前八个字节存入Int型整数:8</span></span><br><span class="line">myPtr2.storeBytes(of: <span class="number">8</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//偏移字节除了可以用  UnsafeMutableRawPointer.storeBytes(of: T, toByteOffset: Int, as: T.Type)，也可以用advanced方法</span></span><br><span class="line"><span class="comment">//获取 myPtr2偏移8个字节后的内存指针,存入数据</span></span><br><span class="line"><span class="keyword">var</span> offset8Mem = myPtr2.advanced(by: <span class="number">8</span>)</span><br><span class="line">offset8Mem.storeBytes(of: <span class="number">30</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myPtr2.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">print</span>(myPtr2.advanced(by: <span class="number">8</span>).load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)) <span class="comment">//30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁,除了可以使用free函数，也可以使用 UnsafeMutableRawPointer.deallocat()</span></span><br><span class="line">myPtr2.deallocate()</span><br></pre></td></tr></table></figure>

<h4 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h4><p>使用<code>UnsafeMutablePointer&lt;T&gt;.allocte(capacity: Int)</code>来申请内存</p>
<p>这种方式可以指定申请内存的类型，传入的容量即为多少个该类型的内存空间</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//申请3个Int型内存空间,一个Int型占8个字节,说白了就是24个字节</span></span><br><span class="line"><span class="keyword">var</span> myPtr3 = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>同时，可以使用<code>initalize(to: T)</code>来初始化，如果没有初始化，读到的数据就是内存中原始的数据了。另外，因为在初始化的时候，申请的内存容量不一定是1，可能有多个指定类型的内存容量单位，可以通过<code>successor()</code>函数来访问下一个类型起始位置。</p>
<p><strong>说白了就是，在定义指针时指定的泛型T，调用每调用一次<code>successor()</code>，就返回当前指针向后偏移一个T类型变量所占内存大小的偏移量。</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">myPtr3.initialize(to: <span class="number">1</span>) <span class="comment">//第一个Int内存（前八个字节）初始化为1</span></span><br><span class="line">myPtr3.successor().initialize(to: <span class="number">20</span>) <span class="comment">// 第二个Int(中间八个字节)内存地址初始化为20</span></span><br><span class="line">myPtr3.successor().successor().initialize(to: <span class="number">33</span>) <span class="comment">//第三个Int内存（最后八个字节）初始化为33</span></span><br></pre></td></tr></table></figure>

<p>除了使用<code>successor()</code>获取偏移后的指针，可以使用下标和加法。</p>
<blockquote>
<p>泛型指针中（UnsafePointer和UnsafeMutablePointer），指针变量  “ +n”,偏移n个泛型类型的变量的内存字节数</p>
<p>原生指针中(UnsafeRawPointer和UnsaeMutableRawPointer) ，指针变量  “ + n”,偏移n个内存字节数</p>
<p>var ptrT = UnsafeMutablePointer<Int>.allocate(capacity: 3);   ptrT + 1 //偏移一个Int型变量的内存字节(8个字节)</p>
<p>var  rowPtr = UnsafeMutableRawPointer(byteCount: 3 alignment: 1); rowPtr + 1 // 偏移1个字节</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用下标来偏移指针</span></span><br><span class="line">myPtr3[<span class="number">0</span>] = <span class="number">5</span> <span class="comment">//第一个Int内存（前八个字节）初始化为5</span></span><br><span class="line">myPtr3[<span class="number">1</span>] = <span class="number">21</span> <span class="comment">//第二个Int(中间八个字节)内存地址初始化为21</span></span><br><span class="line">myPtr3[<span class="number">2</span>] = <span class="number">25</span> <span class="comment">//第三个Int内存（最后八个字节）初始化为25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myPtr3[<span class="number">0</span>]) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">print</span>(myPtr3[<span class="number">1</span>]) <span class="comment">//21</span></span><br><span class="line"><span class="built_in">print</span>(myPtr3[<span class="number">2</span>]) <span class="comment">//25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 ”+“ 来偏移指针</span></span><br><span class="line">myPtr3.pointee = <span class="number">5</span> <span class="comment">//第一个Int内存（前八个字节）初始化为5</span></span><br><span class="line">(myPtr3 + <span class="number">1</span>).pointee = <span class="number">21</span> <span class="comment">//第二个Int(中间八个字节)内存地址初始化为21</span></span><br><span class="line">(myPtr3 + <span class="number">2</span>).pointee = <span class="number">25</span> <span class="comment">//第三个Int内存（最后八个字节）初始化为25</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(myPtr3.pointee) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">print</span>((myPtr3 + <span class="number">1</span>).pointee) <span class="comment">//21</span></span><br><span class="line"><span class="built_in">print</span>((myPtr3 + <span class="number">2</span>).pointee) <span class="comment">//25</span></span><br></pre></td></tr></table></figure>

<p>使用完后，要对指针进行反初始化或销毁</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反初始化，如果不进行这一步会造成内存泄露。</span></span><br><span class="line"><span class="comment">//如果存储的是对象,即使调用了指针的deallcate()，对象依然不会销毁</span></span><br><span class="line">myPtr3.deinitialize(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line">myPtr3.deallocate()</span><br></pre></td></tr></table></figure>

<h3 id="指针之间的转换"><a href="#指针之间的转换" class="headerlink" title="指针之间的转换"></a>指针之间的转换</h3><ul>
<li><p><code>UnsafeMutableRawPointer</code> to <code>UnsafeMutablePointer&lt;T&gt;</code></p>
<ul>
<li><p>assumingMemoryBound</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rawPtr = <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// assumingMemoryBound: 假设内存绑定</span></span><br><span class="line"><span class="comment">// rawPtr指针假设为 Int型来读取 (获取前八个字节),返回一个 Int泛型的UnsafeMutablePointer</span></span><br><span class="line"><span class="comment">//top8Ptr的类型是 UnsafeMutablePointer&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">var</span> top8Ptr = rawPtr.assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">top8Ptr.pointee = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将rawPtr偏移8个字节后，获取到后8个字节</span></span><br><span class="line"><span class="comment">//将后8个字节内存假设为Double行,写入 2.0</span></span><br><span class="line">(rawPtr + <span class="number">8</span>).assumingMemoryBound(to: <span class="type">Double</span>.<span class="keyword">self</span>).pointee = <span class="number">2.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>unsafeBitCast</p>
<p>方法原型：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">unsafeBitCast</span>&lt;T, U&gt;<span class="params">(<span class="number">_</span> x: T, to type: U.<span class="keyword">Type</span>)</span></span> -&gt; <span class="type">U</span></span><br></pre></td></tr></table></figure>

<p><code>unsafeBitCast</code>是忽略数据类型的强制转换，不会因为数据类型的变化而改变原来的内存数据(类似于C++中的reinterpret_cast)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr1 : <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt; = <span class="built_in">unsafeBitCast</span>(rawPtr, to: <span class="type">UnsafePointer</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(ptr1.pointee) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ptr2 : <span class="type">UnsafePointer</span>&lt;<span class="type">Double</span>&gt; = <span class="built_in">unsafeBitCast</span>(rawPtr + <span class="number">8</span>, to: <span class="type">UnsafePointer</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(ptr2.pointee) <span class="comment">// 2.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>unsafePointer</code> to <code>unsafeRawPointer</code></p>
<ul>
<li><p>使用<code>unsafeBitCast</code>方法</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pointerPtr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rawptr = <span class="built_in">unsafeBitCast</span>(pointerPtr, to: <span class="type">UnsafeMutableRawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line">rawptr.storeBytes(of: <span class="number">2.0</span>, <span class="keyword">as</span>: <span class="type">Double</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pointerPtr.pointee) <span class="comment">//4611686018427387904</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>UnsafeRawPointer</code>或者<code>UnsafeMutableRawPointer</code>的构造函数</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pointerPtr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rawptr = <span class="built_in">unsafeBitCast</span>(pointerPtr, to: <span class="type">UnsafeMutableRawPointer</span>.<span class="keyword">self</span>)</span><br><span class="line">rawptr.storeBytes(of: <span class="number">2.0</span>, <span class="keyword">as</span>: <span class="type">Double</span>.<span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pointerPtr.pointee) <span class="comment">//4611686018427387904</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherRawPointer = <span class="type">UnsafeRawPointer</span>(pointerPtr)</span><br><span class="line"><span class="built_in">print</span>(otherRawPointer.load(<span class="keyword">as</span>: <span class="type">Double</span>.<span class="keyword">self</span>)) <span class="comment">// 2.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherMutableRawPointer = <span class="type">UnsafeMutableRawPointer</span>(pointerPtr)</span><br><span class="line">otherMutableRawPointer.storeBytes(of: <span class="number">4</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(pointerPtr.pointee) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/18/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/18/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">Swift5学习笔记之访问控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-18 11:04:06" itemprop="dateCreated datePublished" datetime="2019-10-18T11:04:06+08:00">2019-10-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Swift</code>提供了5个不同的访问级别(以下是从高到低排列，实体指被访问借呗修饰的内容)</p>
<p>**<code>open</code>**：允许在定义实体的模块、其他模块中访问，允许其他模块进行继承、重写(<code>open</code>只能用在类、类成员上)</p>
<p>**<code>public</code>**：允许在定义实体的模块、其他模块中访问，不允许其他模块进行继承、重写。</p>
<p>**<code>internal</code>**：只允许在定义实体的模块中访问，不允许其他模块中访问。</p>
<p>**<code>fileprivate</code>**：只允许在定义实体的源文件中访问</p>
<p>**<code>private</code>**：只允许在定义实体的封闭声明中访问</p>
<ul>
<li>绝大部分实体默认都是<code>internal</code>级别</li>
</ul>
<h2 id="访问级别使用准则"><a href="#访问级别使用准则" class="headerlink" title="访问级别使用准则"></a>访问级别使用准则</h2><p><strong>一个实体不可以被被访问级别的实体定义</strong>，例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> p = <span class="type">Person</span>() <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>代码中，<code>Person</code>类的访问权限是 <code>fileprivate</code>的，而使用<code>Person</code>定义的变量<code>p</code>的访问权限却是<code>internal</code>。这就使得在实体模块内可以访问变量<code>P</code>,但是<code>p</code>的类型信息无法访问，所以报错。</p>
<p>同理的还有：</p>
<ul>
<li>变量\常量类型 &gt;= 变量常量</li>
<li>参数类型、返回值类型 &gt;= 函数</li>
<li>父类 &gt;= 子类</li>
<li>父协议 &gt;= 子协议</li>
<li>原类型 &gt;= <code>typealias</code></li>
<li>原始值类型、关联性类型 &gt;= 枚举类型</li>
<li>定义类型A时用到的其他类型 &gt;= 类型A</li>
</ul>
<h2 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h2><p>元组类型的访问级别是所有成员类型最低的那个。</p>
<p>例如：<code>Dog</code>的访问级别是<code>internal</code>，<code>Person</code>的访问级别是<code>fileprivate</code>。所以元组类型<code>(Dog,fileprivate)</code>的访问级别是<code>fileprivate</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(Dog,Person)的访问级别是fileprivate</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用元组类型(Dog,fileprivate)定义的变量data1 ，data1的访问级别是fileprivate,与类型相等，编译通过</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> data1: (<span class="type">Dog</span>,<span class="type">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用元组类型(Dog,fileprivate)定义的变量data3，data3的访问级别是private,小于元组类型的访问级别，编译通过。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> data3: (<span class="type">Dog</span>,<span class="type">Person</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用元组类型(Dog,fileprivate)定义的变量data2,data2的访问级别是internal大于元组类型的访问级别，报错</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> data2: (<span class="type">Dog</span>,<span class="type">Person</span>) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>泛型类型的访问级别是<strong>类型的访问级别</strong>以及<strong>所有泛型类型参数的访问级别</strong>中最低的那个</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T1</span>,<span class="title">T2</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person&lt;Car,Dog&gt; 的访问级别是 Person,Dog,Car中访问级别中最低的：fileprivate</span></span><br><span class="line"><span class="comment">//类型的访问级别 要 &gt;= 变量的 ，所以编译成功</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="keyword">var</span> p = <span class="type">Person</span>&lt;<span class="type">Car</span>,<span class="type">Dog</span>&gt;()</span><br></pre></td></tr></table></figure>

<h2 id="成员、嵌套类型"><a href="#成员、嵌套类型" class="headerlink" title="成员、嵌套类型"></a>成员、嵌套类型</h2><p> 类型的访问级别会影响成员(属性、方法、初始化器、下标)、嵌套类型的默认访问级别。</p>
<blockquote>
<p>当然成员的访问级别可以比类型的访问级别更高(通过编译)，但是这种做法意义不大。因为类型都访问不到的话，类型的访问级别就没有意义了。</p>
</blockquote>
<ul>
<li>一般情况下，类型为<code>private</code>或<code>fileprivate</code>，那么成员\嵌套类型默认也是<code>private</code>或<code>fileprivate</code></li>
<li>一般情况下，类型为<code>internal</code>或<code>public</code>，那么成员\嵌套类型默认是<code>internal</code></li>
<li>直接在全局作用域下定义的<code>private</code>等价于<code>fileprivate</code></li>
</ul>
<p><em>全局作用域下的<code>private</code>和<code>fileprivate</code>:</em></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局作用域下 private == fileprivate ,所以编译通过</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如下代码可以正常编译通过，虽然<code>Dog</code>的访问级别是<code>private</code>,但在全局作用域下，等价于<code>fileprivate</code>。<code>Dog</code>内的<code>age</code>属性和<code>run()</code>方法也可以此源文件中访问，所以<code>Person</code>可以访问,编译通过。</p>
<p>如果<code>Dog</code>中<code>age</code>和<code>run</code>显式加上<code>private</code>,就只能在<code>Dog</code>结构体内访问，外部就无法访问了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//如果显式加上 private,在 Person.walk() 中是无法调用和访问的</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125; <span class="comment">//如果显式加上 private,在 Person.walk() 中是无法调用和访问的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dog: <span class="type">Dog</span> = <span class="type">Dog</span>()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">        dog.run() <span class="comment">//</span></span><br><span class="line">        dog.age = <span class="number">1</span> <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再如下代码：局部作用域下的定义的私有实体，实体内的成员访问级别和实体访问级别相同，也可以在作用域内访问</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">0</span> <span class="comment">//默认访问级别：private,但这个private和Dog的private相同，访问级别相同</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125; <span class="comment">//默认访问级别：private,但这个private和Dog的private相同，访问级别相同</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dog: <span class="type">Dog</span> = <span class="type">Dog</span>()</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">            dog.age = <span class="number">1</span> <span class="comment">//age的访问级别和Dog相同，也可以在Test实体内访问</span></span><br><span class="line">            dog.run() <span class="comment">//run的访问级别和Dog相同，也可以在Test实体内访问</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="成员的重写"><a href="#成员的重写" class="headerlink" title="成员的重写"></a>成员的重写</h2><ul>
<li><p>子类重写成员的访问级别必须 &gt;= 子类的访问级别，或者 &gt;= 父类被重写成员的访问级别 (子类重写成员的访问级别必须必须比子类的访问级别和父类被重写成员的访问级别中最低的那个高)</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Persons</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Students</span>: <span class="title">Persons</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类的成员不能被成员作用域定义外的子类重写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Student2</span>: <span class="title">Person2</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Person2内部定义的子类可以重写private方法,</span></span><br><span class="line">        <span class="comment">//因为 Student2类 和 Person.run 在同一作用域</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2</span>: <span class="title">Person2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为 Student2类 和 Person.walk 在同一作用域</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="getter、setter"><a href="#getter、setter" class="headerlink" title="getter、setter"></a>getter、setter</h2><p><code>getter</code>、<code>setter</code>默认自动接收它们所属环境的访问级别</p>
<p>可以给<code>setter</code>单独设置一个比<code>getter</code>更低的访问级别，用以限制写的权限。反之不可以。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局变量num get是public级别的，set是fileprivate</span></span><br><span class="line"><span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> num = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> age = <span class="number">0</span> <span class="comment">//外部可以访问(internal)，但只能在内部修改</span></span><br><span class="line">    <span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">var</span> weight: <span class="type">Int</span> &#123; <span class="comment">//外部可以访问(public)，但只能在文件内修改</span></span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="number">10</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下标方法get是public访问级别，set是internal级别的</span></span><br><span class="line">    <span class="keyword">internal</span>(<span class="keyword">set</span>) <span class="keyword">public</span> <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; index &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><ul>
<li><p>如果一个<code>public</code>类想在另外一个模块调用编译生成的默认无参初始化器，必须显示提供<code>public</code>的无参初始化器</p>
<ul>
<li>因为<code>public</code>类的默认初始化器是<code>internal</code>级别</li>
</ul>
</li>
<li><p><code>required</code>初始化器 &gt;= 它的默认访问级别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">required</span> <span class="keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// required init 默认访问级别是 internal,如果使用级别低于internal的修饰，编译不通过</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果结构体有<code>private</code>或<code>fileprivate</code>的存储实例属性，那么它的成员初始化器也是<code>private</code>或<code>fileprivate</code>。否则默认就是<code>internal</code></p>
</li>
</ul>
<h2 id="枚举类型的case"><a href="#枚举类型的case" class="headerlink" title="枚举类型的case"></a>枚举类型的case</h2><p>不能给<code>enum</code>的每个<code>case</code>单独设置访问级别，每个<code>case</code>自动接收<code>enum</code>的访问级别。</p>
<p><code>public enum</code>定义的<code>case</code>也是<code>public</code></p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><ul>
<li><p>协议中要求实现的方法自动接收协议的访问级别，不能单独设置访问级别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Runnable是fileprivate访问级别的，那么run方法也是fileprivate访问级别的</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Runnalbe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遵守协议的实体中，实现协议的方法的访问级别 &gt;= 实体的访问级别，或者 &gt;= 协议的访问级别。通俗一点讲：协议中方法的实现的访问级别不能小于实体和协议中最低的访问级别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// - Person.run() 方法的访问级别，不能小于Runnable和Person中访问级别最低的</span></span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Runnalbe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Runnalbe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">  <span class="comment">// private func run() &#123;&#125;  //private小于 fileprivate 和 public ，编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul>
<li><p>如果有显示设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">fileprivate</span> <span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125; <span class="comment">//run方法也是fileprivate访问级别</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="type">Student</span>()</span><br><span class="line">stu.run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有显示设置扩展的访问级别，扩展添加的成员的默认访问级别，跟直接在类型中定义的成员一样</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123;  &#125; <span class="comment">//run方法是internal访问级别的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="type">Student</span>()</span><br><span class="line">stu.run()</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以单独给扩展添加的成员设置访问级别</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> &#123; &#125; <span class="comment">// 只能在 Student内访问</span></span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">walk</span><span class="params">()</span></span> &#123; <span class="comment">//只能在声明的源文件内访问</span></span><br><span class="line">        run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu = <span class="type">Student</span>()</span><br><span class="line">stu.walk() </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果扩展遵守了协议，那么就不能给扩展<strong>显式</strong>设置扩展的访问级别。这是语法糖，因为协议的访问级别受到了实体和协议本身的访问级别影响。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Student</span> : <span class="title">CustomDebugStringConvertible</span> </span>&#123; <span class="comment">//显示添加访问级别报错</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> debugDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="string">&quot;Student&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同一文件中的扩展，可以写成类似多个部分的类型声明</p>
<ul>
<li>在原本的声明中声明一个私有成员，可以在同一文件的扩展中访问它</li>
<li>在扩展的声明一个私有成员，可以在同一文件的其他扩展中、原本声明访问它</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在同一个文件中，原本的声明和扩展可以看成是一个声明拆分，私有变量(private)可以互相访问。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">learn</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">go</span><span class="params">()</span></span> &#123;</span><br><span class="line">        test2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">        learn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">()</span></span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">abc</span><span class="params">()</span></span> &#123;</span><br><span class="line">        test2()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/30/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">Swift5学习笔记之扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-30 13:22:32" itemprop="dateCreated datePublished" datetime="2019-09-30T13:22:32+08:00">2019-09-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>Swift</code>中的扩展<code>Extension</code>有点类似于<code>OC</code>中的分类<code>Category</code></p>
<p>扩展可以为枚举、结构体、类、协议添加新功能。比如，方法，<strong>计算</strong>属性，小标，(便捷)初始化器，套嵌类型，协议等。但是协议不能办到的事情：</p>
<ul>
<li>不能覆盖原有的功能</li>
<li>不能添加存储属性，不能向已有的属性添加属性观察器。(因为存储属性会改变原有类型的内存结构)</li>
<li>不能添加父类。(添加父类也可能会改变原有类型的内存结构)</li>
<li>不能添加指定初始化器，不能添加反初始化器。等等</li>
</ul>
<h2 id="添加计算属性"><a href="#添加计算属性" class="headerlink" title="添加计算属性"></a>添加计算属性</h2><p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Double</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> km: <span class="type">Double</span> &#123; <span class="keyword">self</span> / <span class="number">1_000.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> m: <span class="type">Double</span> &#123; <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> dm: <span class="type">Double</span> &#123; <span class="keyword">self</span> * <span class="number">10.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> cm: <span class="type">Double</span> &#123; <span class="keyword">self</span> * <span class="number">100.0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> mm: <span class="type">Double</span> &#123; <span class="keyword">self</span> * <span class="number">1_000.0</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10.0</span></span><br><span class="line"><span class="built_in">print</span>(a.km) <span class="comment">//0.01</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">15.4</span>.cm) <span class="comment">//1540.0</span></span><br></pre></td></tr></table></figure>

<h2 id="添加下标"><a href="#添加下标" class="headerlink" title="添加下标"></a>添加下标</h2><p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    <span class="keyword">subscript</span>(nullable idx: <span class="type">Int</span>) -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">          <span class="comment">// startIndex 是Array的一个属性，起始索引</span></span><br><span class="line">          <span class="comment">// endIndex 也是Array的一个属性，== Array.count</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex ..&lt; endIndex).<span class="built_in">contains</span>(idx) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[idx]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line"><span class="built_in">print</span>(array[nullable: <span class="number">5</span>] <span class="keyword">as</span> <span class="type">Any</span>) <span class="comment">//nil</span></span><br><span class="line"><span class="built_in">print</span>(array[nullable: <span class="number">2</span>] <span class="keyword">as</span> <span class="type">Any</span>) <span class="comment">//Optional(30)</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，扩展中可以使用原有类型的泛型,比如<code>Array</code>中的<code>Element</code>。</p>
<h2 id="添加方法和嵌套类型"><a href="#添加方法和嵌套类型" class="headerlink" title="添加方法和嵌套类型"></a>添加方法和嵌套类型</h2><p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重复执行task函数</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">repetitions</span><span class="params">(task: <span class="params">()</span></span></span> -&gt; () ) &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="keyword">self</span> &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求平方</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> = <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 增加套嵌类型 */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">kind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> nagative, zero, positive</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> kind: kind &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .zero</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> x <span class="keyword">where</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> .positive</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> .nagative</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.repetitions &#123; <span class="comment">// 执行 print 4遍</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;aa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">4</span></span><br><span class="line"><span class="built_in">print</span>(b.square()) <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="number">20</span>.kind) <span class="comment">//positive</span></span><br><span class="line"><span class="built_in">print</span>((-<span class="number">20</span>).kind) <span class="comment">//nagative</span></span><br></pre></td></tr></table></figure>

<h2 id="添加协议、初始化器"><a href="#添加协议、初始化器" class="headerlink" title="添加协议、初始化器"></a>添加协议、初始化器</h2><p>扩展可以为类添加<strong>协议</strong>和<strong>便捷初始化器</strong>，不能添加指定初始化器，<code>required</code>初始化器也不能写在扩展中，只能写在类的本体中。</p>
<p>但是在结构体中，没有便捷初始化器的概念，在结构体的扩展实现自定义的初始化器不会影响编译器生成默认初始化器。所以<strong>如果希望自定义初始化的同时，编译器也能够生成默认初始化器</strong>。</p>
<p>在类中扩展协议和便捷初始化器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(age: <span class="type">Int</span>, name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(<span class="keyword">left</span>: Person, <span class="keyword">right</span>: Person)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">left</span>.age == <span class="keyword">right</span>.age &amp;&amp; <span class="keyword">left</span>.name == <span class="keyword">right</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(age: <span class="number">0</span>,name: <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为结构体添加自定义结构体：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> point: <span class="type">Point</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(x: point.x, y: point.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>() <span class="comment">//不影响编译器生成的默认构造器</span></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="type">Point</span>(x: <span class="number">10</span>) <span class="comment">//不影响编译器生成的默认构造器</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="type">Point</span>(y: <span class="number">20</span>) <span class="comment">//不影响编译器生成的默认构造器</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="type">Point</span>(x: <span class="number">20</span>, y: <span class="number">30</span>) <span class="comment">//不影响编译器生成的默认构造器</span></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="type">Point</span>(p4)</span><br></pre></td></tr></table></figure>

<h2 id="扩展协议-amp-可选协议"><a href="#扩展协议-amp-可选协议" class="headerlink" title="扩展协议&amp;可选协议"></a>扩展协议&amp;可选协议</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/22/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/22/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/" class="post-title-link" itemprop="url">Swift5学习笔记之高级运算符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-22 13:22:32" itemprop="dateCreated datePublished" datetime="2019-09-22T13:22:32+08:00">2019-09-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index"><span itemprop="name">Swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="溢出运算符"><a href="#溢出运算符" class="headerlink" title="溢出运算符"></a>溢出运算符</h2><p><code>Swift</code>的算数运算符出现溢出时会抛出运行时错误，但可以使用溢出运算符来支持溢出运算。</p>
<p><code>&amp;+</code>：溢出加，<code>&amp;-</code>：溢出减，<code>&amp;*</code>：溢出乘。</p>
<p>溢出运算的原理在于，结果的长度超过了类型的限制，高位的结果舍去，还是以原有类型读取剩余位数的数值。</p>
<img src="/2019/09/22/Swift5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%AB%98%E7%BA%A7%E8%BF%90%E7%AE%97%E7%AC%A6/WX20200921-135050@2x.png" class="">

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">min</span> = <span class="type">UInt8</span>.<span class="built_in">min</span> <span class="comment">//0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span> &amp;- <span class="number">1</span>) <span class="comment">//255</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> <span class="built_in">max</span> = <span class="type">UInt8</span>.<span class="built_in">max</span> <span class="comment">//255</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span> &amp;+ <span class="number">1</span>) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span> &amp;* <span class="number">2</span>) <span class="comment">//254</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>类、结构体、枚举可以为现有运算符提供自定义的实现，这个操作叫做：运算符重载。</p>
<p>在写法上，则是以运算符为方法名进行，以函数的形式实现。通常运算符的重载实现一般在重载相关的数据结构内。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">0</span>, y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> + <span class="params">( p1:Point, p2: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">            <span class="type">Point</span>(x: p1.x + p2.x, y: p1.y + p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> - <span class="params">(p1: Point, p2: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="type">Point</span>(x: p1.x - p2.x, y: p1.y - p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(p1: Point, p2: Point)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        (p1.x == p2.x ) &amp;&amp; (p2.y == p2.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="type">Point</span>(x: <span class="number">20</span>, y: <span class="number">19</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="type">Point</span>(x: <span class="number">15</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(p1 + p2) <span class="comment">//Point(x: 35, y: 29)</span></span><br><span class="line"><span class="built_in">print</span>(p1 - p2) <span class="comment">//Point(x: 5, y: 9)</span></span><br><span class="line"><span class="built_in">print</span>(p1 == p2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>上述运算符重载，重载的是中缀运算符，重载前缀或后缀运算符要使用关键字<code>prefix</code>和<code>postfix</code>。对于要修改自身的值的重载也可以使用<code>inout</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> - <span class="params">(p1: Point)</span></span> -&gt; <span class="type">Point</span> &#123; <span class="comment">//前缀运算符修改</span></span><br><span class="line">        <span class="type">Point</span>(x: -p1.x , y: -p1.y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> += <span class="params">(p1: <span class="keyword">inout</span> Point,p2: Point)</span></span> &#123;</span><br><span class="line">       p1 = p1 + p2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> ++ <span class="params">(p: <span class="keyword">inout</span> Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">       p += <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">postfix</span> <span class="function"><span class="keyword">func</span> ++ <span class="params">(p: <span class="keyword">inout</span> Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = p</span><br><span class="line">    p += <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(-p1) <span class="comment">//Point(x: -20, y: -19)</span></span><br><span class="line">p1 += p2</span><br><span class="line"><span class="built_in">print</span>(p1) <span class="comment">//Point(x: 35, y: 29)</span></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(++p3) <span class="comment">//Point(x: 11, y: 11)</span></span><br><span class="line"><span class="keyword">var</span> p4 = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(p4++)<span class="comment">//Point(x: 10, y: 10)</span></span><br></pre></td></tr></table></figure>

<h2 id="Equatable协议"><a href="#Equatable协议" class="headerlink" title="Equatable协议"></a><code>Equatable</code>协议</h2><p>要想得知2个实例是否等价，一般做法是遵守<code>Equatable</code>协议，重载<code>==</code>运算符，与此同时，等价于重载<code>!=</code>运算符。</p>
<p>在<code>Swift</code>中，<code>Equatable</code>协议就是一个<code>==</code>运算符重载的方法。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Equatable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Returns a Boolean value indicating whether two values are equal.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Equality is the inverse of inequality. For any values `a` and `b`,</span></span><br><span class="line">    <span class="comment">/// `a == b` implies that `a != b` is `false`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// - Parameters:</span></span><br><span class="line">    <span class="comment">///   - lhs: A value to compare.</span></span><br><span class="line">    <span class="comment">///   - rhs: Another value to compare.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.age == rhs.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="type">Person</span>(age: <span class="number">10</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="type">Person</span>(age: <span class="number">25</span>)</span><br><span class="line"><span class="built_in">print</span>(person1 == person2) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">print</span>(person1 != person2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><code>Swfit</code>中为以下类型提供默认的<code>Equatable</code>实现：</p>
<ul>
<li><p>没有关联类型的枚举</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Answer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> wrong</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> answer1 = <span class="type">Answer</span>.wrong</span><br><span class="line"><span class="keyword">var</span> answer2 = <span class="type">Answer</span>.wrong</span><br><span class="line"><span class="built_in">print</span>(answer1 == answer2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果枚举中含有关联类型，关联类型也遵守<code>Equatable</code>协议，<code>Swift</code>也会自动生成<code>Equatable</code>实现。此时，枚举此时要显示写明遵守<code>Equatable</code>协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Answer2</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> wrong(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="type">Answer2</span>.wrong(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="type">Answer2</span>.<span class="keyword">right</span></span><br><span class="line"><span class="built_in">print</span>(a1 == a2) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Answer3</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> wrong(<span class="type">Int</span>,<span class="type">String</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">right</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anw1 = <span class="type">Answer3</span>.wrong(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> anw2 = <span class="type">Answer3</span>.wrong(<span class="number">10</span>,<span class="string">&quot;ddd&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(anw1 == anw2) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果结构体中所有类型的属性，都遵守<code>Equatable</code>协议，那么这个结构体遵守<code>Equatable</code>协议后，<code>Swift</code>也会自动生成<code>Equatable</code>实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> : <span class="title">Equatable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(age: <span class="type">Int</span>,name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="type">Student</span>(age: <span class="number">20</span>, name: <span class="string">&quot;Jack&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="type">Student</span>(age: <span class="number">30</span>, name: <span class="string">&quot;Peck&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(stu1 == stu2) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">stu1.age = <span class="number">30</span></span><br><span class="line">stu1.name = <span class="string">&quot;Peck&quot;</span></span><br><span class="line"><span class="built_in">print</span>(stu1 == stu2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="比较引用类型的地址值"><a href="#比较引用类型的地址值" class="headerlink" title="比较引用类型的地址值"></a>比较引用类型的地址值</h3><p><strong>引用类型</strong>比较存储的地址值是否相等(是否引用着同一个对象)，使用恒等运算符<code>===</code>、<code>!==</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">init</span>(age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Person, rhs: Person)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        lhs.age == rhs.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person_1 = <span class="type">Person</span>(age: <span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> person_2 = <span class="type">Person</span>(age: <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(person_1 === person_2) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">person_1 = person_2</span><br><span class="line"><span class="built_in">print</span>(person_1 === person_2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="Comparable协议"><a href="#Comparable协议" class="headerlink" title="Comparable协议"></a><code>Comparable</code>协议</h2><p>要想比较2个实例的大小，一般的做法是：遵守<code>Comparable</code>协议，重载相应的运算符</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Comparable</span> : <span class="title">Equatable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &lt;= (lhs: Self, rhs: Self) -&gt; <span class="title">Bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">static</span> <span class="title">func</span> &gt;= <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: <span class="keyword">Self</span>, rhs: <span class="keyword">Self</span>)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//score大的比较大，若score相等，age小的比较大</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Teacher</span> : <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> score: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Teacher, rhs: Teacher) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        (lhs.score &lt; rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age &gt; rhs.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt; <span class="params">(lhs: Teacher, rhs: Teacher)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        (lhs.score &gt; rhs.score) || (lhs.score == rhs.score &amp;&amp; lhs.age &lt; rhs.age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt;= (lhs: Teacher, rhs: Teacher) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        !(lhs &gt; rhs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &gt;= <span class="params">(lhs: Teacher, rhs: Teacher)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        !(lhs &lt; rhs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> t1 = <span class="type">Teacher</span>(age: <span class="number">20</span>, score: <span class="number">100</span>)</span><br><span class="line"><span class="keyword">var</span> t2 = <span class="type">Teacher</span>(age: <span class="number">18</span>, score: <span class="number">98</span>)</span><br><span class="line"><span class="keyword">var</span> t3 = <span class="type">Teacher</span>(age: <span class="number">20</span>, score: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(t1 &gt; t2)  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">print</span>(t1 &gt;= t2) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">print</span>(t1 &lt; t3) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义运算符"><a href="#自定义运算符" class="headerlink" title="自定义运算符"></a>自定义运算符</h2><p><code>Swift</code>允许使用<code>operator</code>关键词在全局声明新的自定义运算符。包括：前缀运算符，后缀运算符，中缀运算符</p>
<h3 id="前缀运算符"><a href="#前缀运算符" class="headerlink" title="前缀运算符"></a>前缀运算符</h3><ul>
<li><p>定义前缀运算符使用：<code>prefix operator 前缀运算符</code>，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">prefix</span> <span class="keyword">operator</span> +++</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PrefixOperatorStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">prefix</span> <span class="function"><span class="keyword">func</span> +++ <span class="params">(p: <span class="keyword">inout</span> PrefixOperatorStruct)</span></span> &#123;</span><br><span class="line">        p.value += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="type">PrefixOperatorStruct</span>(value: <span class="number">10</span>)</span><br><span class="line">+++p</span><br><span class="line"><span class="built_in">print</span>(p) <span class="comment">//PrefixOperatorStruct(value: 12)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="后缀运算符"><a href="#后缀运算符" class="headerlink" title="后缀运算符"></a>后缀运算符</h3><ul>
<li><p>定义后缀运算符使用：<code>postfix operator 后缀运算符</code>，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">postfix</span> <span class="keyword">operator</span> --!</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PostfixOperatorSturct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">postfix</span> <span class="function"><span class="keyword">func</span> --! <span class="params">(p: <span class="keyword">inout</span> PostfixOperatorSturct)</span></span> &#123;</span><br><span class="line">        p.value /= <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> po = <span class="type">PostfixOperatorSturct</span>(value: <span class="number">8</span>)</span><br><span class="line">po--!</span><br><span class="line"><span class="built_in">print</span>(po) <span class="comment">//PostfixOperatorSturct(value: 2)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="中缀运算符"><a href="#中缀运算符" class="headerlink" title="中缀运算符"></a>中缀运算符</h3><ul>
<li><p>定义中缀运算符使用：<code>infix operator 中缀运算符</code>，因为中缀运算符涉及到两个参数，对中缀运算符的计算设计也要多一点，包括：优先组（结合性，优先级，可选项优先级）</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> 中缀运算符 : 优先级组</span><br><span class="line">precedencegroup 优先级组 &#123;</span><br><span class="line">      <span class="keyword">associativity</span>: 结合性(<span class="keyword">left</span>\<span class="keyword">right</span>\<span class="keyword">none</span>)</span><br><span class="line">      higherThan: 比谁优先级高</span><br><span class="line">      lowerThan: 比谁优先级低</span><br><span class="line">      assignment: <span class="literal">true</span> <span class="comment">//代表在可选链操作中拥有跟赋值运算符一样的优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>associativity</code>代表结合性：可选值为<code>left</code>，<code>right</code>，<code>none</code>。</p>
<blockquote>
<p>解释一下结合性：</p>
<p>像加法中： a + b + c  = ( a + b ) + c = a + ( b + c )</p>
<p>如果不具备结合性(<code>none</code>)，代表表达式是不可以三个参数一起运算的。<code>left</code>或<code>right</code>代表是三个参数一起运算时，优先左边运算还是右边运算。</p>
</blockquote>
<p>其中<code>higherThan</code>和<code>lowerThan</code>用来定义优先级别，具体可选值可以参靠：<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations">https://developer.apple.com/documentation/swift/swift_standard_library/operator_declarations</a>，<a target="_blank" rel="noopener" href="https://docs.swift.org/swift-book/ReferenceManual/Declarations.html">https://docs.swift.org/swift-book/ReferenceManual/Declarations.html</a></p>
<p>其中，<code>assignment</code>代表在可选链操作中拥有跟赋值运算符一样的优先级，</p>
<p>例如，在如下代码中，当<code>per</code>为<code>nil</code>时，<code>age</code>的赋值操作是不执行的。当<code>assignment</code>为<code>true</code>时，也会在可选链为<code>nil</code>时，不执行操作。如果<code>assignment</code>为<code>false</code>时，可选链是否为<code>nil</code>时，都会执行，所以为了避免崩溃要在函数内做处理。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> per: <span class="type">Person?</span> = <span class="type">Person</span>()</span><br><span class="line">per?.age = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>当<code>assignment = true</code>时，例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +-: <span class="type">PlusMinusPrecedence</span></span><br><span class="line">precedencegroup <span class="type">PlusMinusPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">none</span></span><br><span class="line">    higherThan: <span class="type">AdditionPrecedence</span></span><br><span class="line">    lowerThan: <span class="type">MultiplicationPrecedence</span></span><br><span class="line">    assignment: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span>,y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Point, <span class="keyword">right</span>: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;+-&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ?? ： 空和运算符, 给nil的值一个默认值 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Point?, <span class="keyword">right</span>: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;+-?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: <span class="keyword">left</span>?.x ?? <span class="number">0</span> + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>?.y ?? <span class="number">0</span> - <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point: <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当可选链中有nil, 则 +- 操作不执行 (assignment = true)</span></span><br><span class="line"><span class="keyword">var</span> aStu: <span class="type">Stu?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> result = aStu?.point +- <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>) <span class="comment">// result类型是 Point?</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">//nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当可选链都不为nil, 执行了 static func +- (left: Point, right: Point) -&gt; Point方法</span></span><br><span class="line"><span class="keyword">var</span> otherStu: <span class="type">Stu?</span> = <span class="type">Stu</span>(point: <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>))</span><br><span class="line"><span class="keyword">var</span> otherresult = otherStu?.point +- <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>) <span class="comment">// result类型是 Point?</span></span><br><span class="line"><span class="built_in">print</span>(otherresult) <span class="comment">// +- Optional(Point(x: 15, y: -5)) </span></span><br></pre></td></tr></table></figure>

<p>当<code>assignment = true</code>时，例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> +-: <span class="type">PlusMinusPrecedence</span></span><br><span class="line">precedencegroup <span class="type">PlusMinusPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">none</span></span><br><span class="line">    higherThan: <span class="type">AdditionPrecedence</span></span><br><span class="line">    lowerThan: <span class="type">MultiplicationPrecedence</span></span><br><span class="line">    assignment: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x: <span class="type">Int</span>,y: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Point, <span class="keyword">right</span>: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;+-&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: <span class="keyword">left</span>.x + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>.y - <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// ?? ： 空和运算符, 给nil的值一个默认值 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> +- <span class="params">(<span class="keyword">left</span>: Point?, <span class="keyword">right</span>: Point)</span></span> -&gt; <span class="type">Point</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;+-?&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Point</span>(x: <span class="keyword">left</span>?.x ?? <span class="number">0</span> + <span class="keyword">right</span>.x, y: <span class="keyword">left</span>?.y ?? <span class="number">0</span> - <span class="keyword">right</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point: <span class="type">Point</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可选链中不管有没有nil,都会执行 +- 操作，获得的类型是Point(与函数返回值类型相同)</span></span><br><span class="line"><span class="comment">//执行的方法：static func +- (left: Point?, right: Point) -&gt; Point</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aStu: <span class="type">Stu?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">var</span> result = aStu?.point +- <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>) <span class="comment">// result类型是 Point</span></span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">// +-? Point(x: 10, y: -10)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherStu: <span class="type">Stu?</span> = <span class="type">Stu</span>(point: <span class="type">Point</span>(x: <span class="number">5</span>, y: <span class="number">5</span>))</span><br><span class="line"><span class="keyword">var</span> otherresult = otherStu?.point +- <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>) <span class="comment">// otherresult类型是 Point</span></span><br><span class="line"><span class="built_in">print</span>(otherresult) <span class="comment">// +- Point(x: 5, y: 5)</span></span><br></pre></td></tr></table></figure>



</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dev.Gao</p>
  <div class="site-description" itemprop="description">人类的本能是胆怯，但人类的本质是不甘心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dev.Gao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
