<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:type" content="website">
<meta property="og:title" content="Dev.Gao的学习笔记">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Dev.Gao的学习笔记">
<meta property="og:description" content="人类的本能是胆怯，但人类的本质是不甘心">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Dev.Gao">
<meta property="article:tag" content="iOS,Android,Java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Dev.Gao的学习笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Dev.Gao的学习笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/08/isa%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/08/isa%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">isa详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-08 16:38:10" itemprop="dateCreated datePublished" datetime="2017-04-08T16:38:10+08:00">2017-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>isa</code>指针是Runtime中非常重要的一个结构体，也是非常常用的一个数据结构。</p>
<p>在<strong>arm64</strong>架构之前，<code>isa</code>就是一个普通的指针，存储着<code>Class</code>,<code>Meta-Class</code>对象的内存地址。</p>
<p>从<strong>arm64</strong>架构开始，对<code>isa</code>进行了优化，变成了一个共用体(<code>union</code>)结构，还使用位域来存储更多的信息。</p>
<h3 id="isa的结构"><a href="#isa的结构" class="headerlink" title="isa的结构"></a>isa的结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">  Class cls;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><strong>nonpointer</strong>：</p>
<ul>
<li>0，代表普通指针，存储着Class、Meta-Class对象的内存地址</li>
<li>1，代表优化过，使用位域存储更多的信息</li>
</ul>
</li>
<li><p><strong>has_assoc</strong>：</p>
<ul>
<li>是否<strong>设置过</strong>关联对象，如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>has_cxx_dtor</strong>：</p>
<ul>
<li>是否有C++的析构函数(.cxx_destruct),如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>shiftcls</strong>：</p>
<ul>
<li>存储着Class、Meta-Class对象的内存地址信息</li>
</ul>
</li>
<li><p><strong>magic</strong></p>
<ul>
<li>用于调试时分辨对象是否未完成初始化</li>
</ul>
</li>
<li><p><strong>weakly_referenced</strong>：</p>
<ul>
<li>是否又被弱引用指向过，如果没有，释放时会更快</li>
</ul>
</li>
<li><p><strong>deallocating</strong></p>
<ul>
<li>对象是否正在释放</li>
</ul>
</li>
<li><p><strong>extra_rc</strong></p>
<ul>
<li>里面存储的值是<strong>引用计数器 - 1</strong></li>
</ul>
</li>
<li><p><strong>has_sidetable_rc</strong></p>
<ul>
<li>引用计数是否过大无法存储在isa中</li>
<li>如果为1，那么引用计数会存储在一个叫SideTable的类的属性中。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E4%BD%8D%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E7%94%A8%E4%BD%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/04/%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E4%BD%8D%E5%9F%9F%E4%BB%A5%E5%8F%8A%E5%85%B1%E7%94%A8%E4%BD%93/" class="post-title-link" itemprop="url">位运算、位域以及共用体</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-04-04 16:38:10" itemprop="dateCreated datePublished" datetime="2017-04-04T16:38:10+08:00">2017-04-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OC在底层<code>isa</code>的实现上使用了位运算，位域以及共用体。我们先提前看一下这些技术的用法。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>OC中基本数据类型所占的字节数：</p>
<table>
<thead>
<tr>
<th align="center">C</th>
<th align="center">ObjC</th>
<th align="center">32位</th>
<th align="center">64位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">BOOL(64位)</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">int8_t、BOOL(32位)</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">Boolean</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">int16_t</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">unsigned short</td>
<td align="center">unichar</td>
<td align="center">2</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">int32_t、NSInteger(32位)、boolean_t(32位)</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">boolean_t(64位)、NSUInteger(32位)</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">NSInteger(64位)</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">unsigned long</td>
<td align="center">NSUInteger(64位)</td>
<td align="center">4</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">int64_t</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">CGFloat(32位)</td>
<td align="center">4</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">CGFloat(64位)</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
</tbody></table>
<ul>
<li>BOOL在32位机器被定义为char、在64位机器被定义为bool</li>
<li>boolean_t在32位机器被定义为unsigned int、在64位机器被定义为int</li>
<li>NSInteger在32位机器被定义为int、在64位机器被定义为long</li>
<li>NSUInteger在32位机器被定义为unsigned int、在64位机器被定义为unsigned long</li>
<li>CGFloat在32位机器被定义为float、在64位机器被定义为double</li>
<li>由于C语言只会将bool的非0值置为1，因此，BOOL的使用过程中应注意在32位机器上并非只有1和0两种可能取值，取值范围是-128~127</li>
</ul>
<h2 id="需求提出"><a href="#需求提出" class="headerlink" title="需求提出"></a>需求提出</h2><p>假设有如下场景（Model）：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>,<span class="keyword">getter</span>=isTall) <span class="built_in">BOOL</span> tall;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>,<span class="keyword">getter</span>=isRich) <span class="built_in">BOOL</span> rich;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>,<span class="keyword">getter</span>=isHandsome) <span class="built_in">BOOL</span> handsome;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLPerson</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>GLPerson中，有三个BOOL类型的成员属性。一个BOOL属性占一个字节。那么是否可以用其他方式来存储这三个值呢。</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>所谓位运算，就是对一个比特（Bit）位进行操作。比特（Bit）是一个电子元器件，8个比特构成一个字节（Byte），它已经是粒度最小的可操作单元了。</p>
<p>OC中可以使用C语言中的六种位运算：</p>
<p>| 运算法 |  <code>&amp;</code>   |  <code>|</code>   |   <code>^</code>    | <code>~</code>  | <code>&lt;&lt;</code> | <code>&gt;&gt;</code> |<br>| :—-: | :—-: | :—-: | :——: | :–: | :–: | :–: |<br>|  说明  | 按位与 | 按位或 | 按位异或 | 取反 | 左移 | 右移 |</p>
<h3 id="按位与运算-amp"><a href="#按位与运算-amp" class="headerlink" title="按位与运算(&amp;)"></a>按位与运算(&amp;)</h3><p>一个比特位只有0和1两个取值，均为1才为1，否则为0</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&amp;<span class="number">1</span> = <span class="number">1</span>;  <span class="number">1</span>&amp;<span class="number">0</span> = <span class="number">0</span>;  <span class="number">0</span>&amp;<span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="按位或运算"><a href="#按位或运算" class="headerlink" title="按位或运算(|)"></a>按位或运算(|)</h3><p>两个二进制位有1时，就为1。两个都为0时结果才为0;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>|<span class="number">1</span> = <span class="number">1</span>; <span class="number">1</span>|<span class="number">0</span> = <span class="number">1</span>; <span class="number">0</span>|<span class="number">0</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="按位异或运算"><a href="#按位异或运算" class="headerlink" title="按位异或运算(^)"></a>按位异或运算(^)</h3><p>参与<code>^</code>运算两个二进制位不同时，结果为 1，相同时结果为 0.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>^<span class="number">1</span>=<span class="number">1</span>; <span class="number">0</span>^<span class="number">0</span>=<span class="number">0</span>; <span class="number">1</span>^<span class="number">1</span>=<span class="number">0</span>。</span><br></pre></td></tr></table></figure>

<h3 id="取反运算"><a href="#取反运算" class="headerlink" title="取反运算(~)"></a>取反运算(~)</h3><p>取反运算符<code>~</code>为单目运算符，右结合性，作用是对参与运算的二进制位取反。例如<code>~1</code>为0，<code>~0</code>为1。</p>
<h3 id="左移运算-lt-lt"><a href="#左移运算-lt-lt" class="headerlink" title="左移运算( &lt;&lt; )"></a>左移运算( &lt;&lt; )</h3><p>左移运算符<code>&lt;&lt;</code>用来把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。</p>
<p>如果数据较小，被丢弃的高位不包含 1，那么左移 n 位相当于乘以 2 的 n 次方。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>&lt;&lt;<span class="number">3</span>的结果为 <span class="number">72</span>。</span><br><span class="line"></span><br><span class="line">&lt;&lt; <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">1001</span>  （<span class="number">9</span> 在内存中的存储）</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0100</span> <span class="number">1000</span>  （<span class="number">72</span> 在内存中的存储）</span><br></pre></td></tr></table></figure>

<h3 id="右移运算-gt-gt"><a href="#右移运算-gt-gt" class="headerlink" title="右移运算( &gt;&gt; )"></a>右移运算( &gt;&gt; )</h3><p>右移运算符<code>&gt;&gt;</code>用来把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span>&gt;&gt;<span class="number">3</span>的结果为 <span class="number">1</span>。</span><br><span class="line">&gt;&gt; <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">1001</span>  （<span class="number">9</span> 在内存中的存储）</span><br><span class="line">-----------------------------------------------------------------------------------</span><br><span class="line">   <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0001</span>  （<span class="number">1</span> 在内存中的存储）</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">block底层学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-03-21 16:38:10" itemprop="dateCreated datePublished" datetime="2017-03-21T16:38:10+08:00">2017-03-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="关于block常见的面试题"><a href="#关于block常见的面试题" class="headerlink" title="关于block常见的面试题"></a>关于block常见的面试题</h2><ul>
<li><p>block的原理是怎样的？本质是什么？</p>
<p>block就是一个封装函数以及函数调用环境的OC对象</p>
</li>
<li><p>__block的作用是什么？有什么使用注意点？</p>
<p>__block可以解决block内部无法修改auto变量值的问题，因为编译器会将<code>__block</code>变量包装成一个对象。</p>
<p>注意内存管理。</p>
</li>
<li><p>block的属性修饰词为什么是copy？使用block有哪些使用注意？</p>
<p>方便对block进行内存管理<br>注意点：循环引用,以及循环引用的解决方式</p>
</li>
<li><p>block在修改NSMutableArray，需不需要添加__block？</p>
<p>不需要，<code>[NSMuatableArray addObject:]</code>方法并不改变指针。</p>
</li>
</ul>
<h2 id="block的基本使用"><a href="#block的基本使用" class="headerlink" title="block的基本使用"></a>block的基本使用</h2><p><code>block</code>在iOS中是比较常用的，常见的定义和使用的方法有这几种：</p>
<p style="background-color:#ffffff; margin:0pt"><span style="color:#007400; font-family:menlo; font-size:12pt">// 这样就是一个block，但是这个block不会执行</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">^{</span></p><p style="background-color:#ffffff; margin:0pt; text-indent:36pt"><span style="color:#2e0d6e; font-family:menlo; font-size:12pt">NSLog</span><span style="font-family:menlo; font-size:12pt">(</span><span style="color:#c41a16; font-family:menlo; font-size:12pt">@"This is a block"</span><span style="font-family:menlo; font-size:12pt">);</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">};</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">&nbsp;</span></p><p style="background-color:#ffffff; margin:0pt"><span style="color:#007400; font-family:menlo; font-size:12pt">//在后面添加(),就可以执行</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">^{</span></p><p style="background-color:#ffffff; margin:0pt; text-indent:36pt"><span style="color:#2e0d6e; font-family:menlo; font-size:12pt">NSLog</span><span style="font-family:menlo; font-size:12pt">(</span><span style="color:#c41a16; font-family:menlo; font-size:12pt">@"This is an another block"</span><span style="font-family:menlo; font-size:12pt">);</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">}(); </span><span style="color:#007400; font-family:menlo; font-size:12pt">// This is an another block</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">&nbsp;</span><span style="font-family:menlo; font-size:12pt">&nbsp;</span><span style="font-family:menlo; font-size:12pt"> </span><span style="font-family:menlo; font-size:12pt">&nbsp;</span><span style="font-family:menlo; font-size:12pt"> </span><span style="font-family:menlo; font-size:12pt">&nbsp;</span><span style="font-family:menlo; font-size:12pt"> </span><span style="font-family:menlo; font-size:12pt">&nbsp;</span></p><p style="background-color:#ffffff; margin:0pt"><span style="color:#007400; font-family:menlo; font-size:12pt">//也可以使用变量保存起来</span></p><p style="background-color:#ffffff; margin:0pt"><span style="color:#aa0d91; font-family:menlo; font-size:12pt">void</span><span style="font-family:menlo; font-size:12pt"> (^block)(</span><span style="color:#5c2699; font-family:menlo; font-size:12pt">NSString</span><span style="font-family:menlo; font-size:12pt"> *) = ^(</span><span style="color:#5c2699; font-family:menlo; font-size:12pt">NSString</span><span style="font-family:menlo; font-size:12pt"> *tag){</span></p><p style="background-color:#ffffff; margin:0pt; text-indent:36pt"><span style="color:#2e0d6e; font-family:menlo; font-size:12pt">NSLog</span><span style="font-family:menlo; font-size:12pt">(</span><span style="color:#c41a16; font-family:menlo; font-size:12pt">@"This is other block ~~,%@"</span><span style="font-family:menlo; font-size:12pt">,tag);</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">};</span></p><p style="background-color:#ffffff; margin:0pt"><span style="font-family:menlo; font-size:12pt">block(</span><span style="color:#c41a16; font-family:menlo; font-size:12pt">@"abc"</span><span style="font-family:menlo; font-size:12pt">);</span><span style="color:#007400; font-family:menlo; font-size:12pt">//This is other block ~~,abc</span></p>

<h2 id="block的本质"><a href="#block的本质" class="headerlink" title="block的本质"></a>block的本质</h2><p>以如下最简单的一个block为例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用重写命令重写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</span><br></pre></td></tr></table></figure>

<p>可以在CPP代码中发现对block的处理：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// block_impl 结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa; <span class="comment">//isa指针</span></span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//block的内部函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//block生成的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock; <span class="comment">//block的类型</span></span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp; <span class="comment">//block的入口函数（封装block内部逻辑的函数）</span></span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装block内部逻辑的函数(NSLog(@&quot;Hello world&quot;))</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_main_fa2d78_mi_0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> struct __main_block_desc_0 &#123;</span><br><span class="line">  <span class="keyword">size_t</span> reserved; <span class="comment">//保留位</span></span><br><span class="line">  <span class="keyword">size_t</span> Block_size; <span class="comment">//__main_block_impl_0 所占内存的大小</span></span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line">          </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">                            </span><br><span class="line">        <span class="comment">//定义block函数</span></span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                                  &amp;__main_block_desc_0_DATA));</span><br><span class="line">        <span class="comment">//执行block(调用block的内部的入口函数)</span></span><br><span class="line">        (__block_impl *)block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码整理一下为：</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" class="" title="This is an example image">

<p>所以Xcode对这个block处理的大体逻辑是：</p>
<ol>
<li>创建一个函数<strong>_main_block_func_0</strong>,这个函数的作用就是将我们<strong>block</strong>中要执行的代码封装到函数内部，方便调用。</li>
<li>创建一个结构体<strong>_main_block_desc_0</strong>,这个结构体中主要包含<strong>_main_block_impl_0</strong>这个结构体占用的存储空间大小等信息。</li>
<li>将<strong>1</strong>中创建的<strong>_main_block_func_0</strong>这个函数的地址，和2中创建的<strong>_main_block_desc_0</strong>这个结构体的地址传给<strong>_main_block_impl_0</strong>的构造函数。</li>
<li>利用<strong>_main_block_func_0</strong>初始化<strong>_main_block_impl_0</strong>结构体的第一个成员变量impl的成员变量FuncPtr。这样<strong>_main_bck_impl_0</strong>这个结构体也就得到了block中那个代码块的地址。</li>
<li>利用<strong>_mian_block_desc_0_DATA</strong>去初始化<strong>_mian_block_impl_0</strong>的第二个成员变量Desc。</li>
<li>执行时，直接调用<strong>_main_block_impl_0</strong>中FuncPtr即可。</li>
</ol>
<p>当然这只是最简单的一种，实际情况要复杂很多，但底层的结构都大同小异。譬如对如下如下代码进行C++重写:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;    </span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">int</span>,<span class="keyword">int</span>) = ^(<span class="keyword">int</span> a,<span class="keyword">int</span> b) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello, World! - %d - %d&quot;</span>,a,b);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        block(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写后的代码结构体**<code>__block_impl</code><strong>和</strong><code>__main_block_desc_0</code><strong>以及</strong><code>__main_block_impl_0</code>**并没有变化，变化的只有block内部逻辑的封装函数：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself, <span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_main_d4ca7a_mi_0,a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及<code>main</code>函数中的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">int</span>,<span class="keyword">int</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                                     &amp;__main_block_desc_0_DATA));</span><br><span class="line"></span><br><span class="line">        ((__block_impl *)block)-&gt;FuncPtr(block, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>为了保证block内部能够正常访问外部的变量，block有个变量捕获机制。</p>
<h3 id="捕获auto变量"><a href="#捕获auto变量" class="headerlink" title="捕获auto变量"></a>捕获auto变量</h3><p>auto变量是声明在函数内部的变量，比如<code>int a = 0</code>;这句代码声明在函数内部，那<code>a</code>就是<code>auto变量</code>，等价于<code>auto int a = 0</code>;<code>auto变量</code>时分配在栈区，当超出作用域时，其占用的内存会被系统自动销毁并生成。</p>
<p>下面看一段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">20</span>;</span><br><span class="line">block(); <span class="comment">//age is 10</span></span><br></pre></td></tr></table></figure>

<p>自动变量a的值明明已经变为了20，为什么输出结果还是10呢？把这段代码转化为C++的源码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age; <span class="comment">//这里多了一个age的成员</span></span><br><span class="line">    <span class="comment">//构造函数也多了age的参数</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="comment">//获取block中内部的age成员的值</span></span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; </span><br><span class="line">   NSLog((NSString*)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_main_be8a00_mi_0,age);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//这里将age=10，传入了构造函数中，block内部的age = 10</span></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">        <span class="comment">//执行时，block内部使用了之前传入的age = 10的值。</span></span><br><span class="line">           block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>从上述可以看到，block内部逻辑访问了auto变量，会在最终生成的底层结构体中，生成该成员变量，并且在创建初始化时将auto变量以构造函数参数的形式拷贝到block结构体内部。后续在内部逻辑执行时，只需访问block内部的该成员即可。外部的auto变量变化时，不会影响到block内部的该成员变量的值。</p>
<h3 id="捕获static变量"><a href="#捕获static变量" class="headerlink" title="捕获static变量"></a>捕获static变量</h3><p>当block访问外部变量的类型由<code>auto</code>类型变为<code>局部static</code>类型，如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">auto <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d, weight is %d&quot;</span>,age,weight);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line">age = <span class="number">30</span>;</span><br><span class="line">weight = <span class="number">40</span>;</span><br><span class="line">        </span><br><span class="line">block(); <span class="comment">//age is 10, weight is 40</span></span><br></pre></td></tr></table></figure>

<p><code>static</code>类型的局部变量在外部的修改会影响block内部访问的值。</p>
<p>重写为C++后可以看到几个关键的地方：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age; <span class="comment">//这里是值的形式</span></span><br><span class="line">  <span class="keyword">int</span> *weight; <span class="comment">//这里是地址的性质</span></span><br><span class="line">    <span class="comment">//构造函数中，需要传入age的值以及weight的地址值</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> *_weight, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age), weight(_weight) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="comment">//获取了block内部的age的值</span></span><br><span class="line">    <span class="keyword">int</span> age = __cself-&gt;age;</span><br><span class="line">    <span class="comment">//获取了block内部的weight的指针</span></span><br><span class="line">    <span class="keyword">int</span> *weight = __cself-&gt;weight;</span><br><span class="line">    <span class="comment">//使用weight时，用*weight来取值</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_main_72fe5f_mi_0,age,(*weight));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> weight = <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = &amp;__main_block_impl_0(__main_block_func_0,</span><br><span class="line">                                                  &amp;__main_block_desc_0_DATA,</span><br><span class="line">                                                  age,  <span class="comment">//传入了age的值</span></span><br><span class="line">                                                  &amp;weight)); <span class="comment">//传入了weight的地址</span></span><br><span class="line"></span><br><span class="line">        age = <span class="number">30</span>;</span><br><span class="line">        weight = <span class="number">40</span>;</span><br><span class="line">        block-&gt;FuncPtr(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p>与<code>auto</code>变量不同，block不会像<code>auto变量</code>进行值传递存储在自身结构体内，而是使用地址传递，保存地址。即使<code>static</code>变量的值发生了改变，block中也会通过地址访问到最新的值。</p>
<h3 id="捕获全局变量"><a href="#捕获全局变量" class="headerlink" title="捕获全局变量"></a>捕获全局变量</h3><p>以上两种情况都是局部变量的情况，如果是全局变量，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> age_ = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> weight_ = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d - %d&quot;</span>,age_,weight_);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        age_ = <span class="number">15</span>;</span><br><span class="line">        weight_ = <span class="number">25</span>;</span><br><span class="line">        </span><br><span class="line">        block();<span class="comment">//15 - 25</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写为C++后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="comment">//age_ 和 weight_ 都是直接访问</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_main_20967f_mi_0,age_,weight_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>__mian_block_impl_0</code>并没有增加成员变量，可见对于block内部访问全局变量的情况，并没有进行捕获，而是采用直接访问的形式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E5%8F%98%E9%87%8F%E6%8D%95%E8%8E%B7.png" class="" title="This is an example image">

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ol>
<li><p>为什么对于不同类型的变量，block的处理方式不同呢？</p>
<p>这是由变量的生命周期决定的。对于auto变量，当作用域结束时，会被系统自动回收，而block很可能是在超出auto变量作用域的时候去执行，如果之前没有捕获auto变量，那么后面执行的时候，auto变量已经被回收了，得不到正确的值。对于static局部变量，它的生命周期不会因为作用域结束而结束，所以block只需要捕获这个变量的地址，在执行的时候通过这个地址去获取变量的值，这样可以获得变量的最新的值。而对于全局变量，在任何位置都可以直接读取变量的值。</p>
</li>
<li><p>为什么对于auto变量block捕获的是数值而 对于static局部变量捕获的是地址？</p>
<p>还是由变量的生命周期决定的，对于auto变量，当作用域结束时，会被系统自动回收，地址就会变成空的，造成坏地址访问。对于static局部变量，它的生命周期不会因为作用域结束而结束，所以block只需要捕获这个变量的地址，在执行的时候通过这个地址去获取变量的值。</p>
</li>
<li><p>static局部变量生命周期什么时候结束？</p>
<p>在局部变量的说明前再加上static说明符就构成静态局部变量。例如：static int a,b; static float array[5]={1,2,3,4,5}；</p>
<p>静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。</p>
</li>
</ol>
<h3 id="捕获self变量"><a href="#捕获self变量" class="headerlink" title="捕获self变量"></a>捕获self变量</h3><p> 对于如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestObj</span></span></span><br><span class="line">- (<span class="keyword">void</span>) test &#123;</span><br><span class="line">    <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;--%@&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>重写为C++后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">TestObj__test_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">TestObj__test_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  TestObj *self; </span><br><span class="line">  __TestObj__test_block_impl_0(<span class="keyword">void</span> *fp, struct __TestObj__test_block_desc_0 *desc, TestObj *_self, <span class="keyword">int</span> flags=<span class="number">0</span>) : self(_self) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __TestObj__test_block_func_0(struct __TestObj__test_block_impl_0 *__cself) &#123;</span><br><span class="line">  TestObj *self = __cself-&gt;self; <span class="comment">// bound by copy</span></span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mx_tg911gc51gdgzk_mgp7nh9yw0000gn_T_TestObj_e375f3_mi_0,self);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//self作为参数传入</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_TestObj_test(TestObj * self, SEL _cmd) &#123;</span><br><span class="line">    <span class="keyword">void</span>(*block)(<span class="keyword">void</span>) = &amp;__TestObj__test_block_impl_0(__TestObj__test_block_func_0,</span><br><span class="line">                                                       &amp;__TestObj__test_block_desc_0_DATA,</span><br><span class="line">                                                       self,</span><br><span class="line">                                                       <span class="number">570425344</span>));</span><br><span class="line">    block-&gt;FuncPtr(block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到，self确实是作为成员变量被捕获了。</strong></p>
<h2 id="block的类型"><a href="#block的类型" class="headerlink" title="block的类型"></a>block的类型</h2><p>block有3种类型，可以通过调用class方法或者isa指针查看具体类型，最终都是继承自NSBlock类型。</p>
<ul>
<li>**__NSGlobalBlock__ ** (_NSConcreteGlobalBlock)</li>
<li>**__NSStackBlock__ ** (_NSConcreteStackBlock)</li>
<li>**__NSMallocBlock__ ** (_NSConcreteMallocBlock)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>(^block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Hello&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block:%@&quot;</span>,[block <span class="keyword">class</span>]); <span class="comment">//__NSGlobalBlock__</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span>(^block1)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age:%d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//MRC环境下输出:__NSStackBlock__</span></span><br><span class="line"><span class="comment">//ARC环境下输出:__NSMallocBlock__</span></span><br><span class="line"><span class="comment">//原因是ARC环境下，编译器默对栈上的block进行copy操作。</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block1:%@&quot;</span>,[block1 <span class="keyword">class</span>]); <span class="comment">//__NSStackBlock__</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;block2:%@&quot;</span>,[[block1 <span class="keyword">copy</span>] <span class="keyword">class</span>]);<span class="comment">//__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>

<p>这三种类型的Block对象的存储区域如图：</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E5%8C%BA%E5%9F%9F.png" class="" title="This is an example image">

<p>数据段中的<code>__NSGlobalBlock__</code>直到程序结束才会被回收，不过我们很少使用到<code>__NSGlobalBlock__</code>类型的block，因为这样使用block并没有什么意义。</p>
<p><code>__NSStackBlock__</code>类型的block存放在栈中，我们知道栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放，而在相同的作用域中定义block并且调用block似乎也多此一举。</p>
<p><code>__NSMallocBlock__</code>是在平时编码过程中最常使用到的。存放在堆中需要我们自己进行内存管理。</p>
<p><strong>Block类型的解释说明</strong></p>
<p><strong>截获了自动变量的Block是NSStackBlock类型，没有截获自动变量的Block则是NSGlobalStack类型,NSStackBlock类型的Block进行copy操作之后其类型变成了NSMallocBlock类型。</strong></p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A1%A8%E6%A0%BC.png" class="" title="This is an example image">

<p>每一种类型的block调用copy后的结果如下所示：</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E7%B1%BB%E5%9E%8B%E6%89%A7%E8%A1%8Ccopy%E6%93%8D%E4%BD%9C%E7%9A%84%E8%A1%A8%E6%A0%BC.png" class="" title="This is an example image">

<h2 id="block的copy操作"><a href="#block的copy操作" class="headerlink" title="block的copy操作"></a>block的copy操作</h2><p>在<strong>ARC</strong>环境下，编译器会根据情况自动将栈上的block复制到堆上。比如以下几种情况：</p>
<ul>
<li><p>block作为函数返回值时。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^TestBlock)(<span class="keyword">void</span>);</span><br><span class="line">TestBlock aFunction() &#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ^() &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;the age is %d&quot;</span>,age);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[aFunction() <span class="keyword">class</span>]); <span class="comment">//__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将block赋值给<code>__strong</code>指针时。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有赋值给__strong指针</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[^(<span class="keyword">void</span>)&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125; <span class="keyword">class</span>]); <span class="comment">//__NSStackBlock__</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//赋值给__strong指针</span></span><br><span class="line">TestBlock testBlock = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[testBlock <span class="keyword">class</span>]);<span class="comment">//__NSMallocBlock__</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>block作为Cocoa API中方法名含有<code>usingBlock</code>的方法参数时。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[];</span><br><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123; &#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p>block作为GCD API的方法参数时。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; &#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="对象类型的auto变量"><a href="#对象类型的auto变量" class="headerlink" title="对象类型的auto变量"></a>对象类型的auto变量</h2><p>变量捕获一节中，我们主要讨论了捕获基础类型的变量。但是开发中经常面临的是对象类型的auto变量。我们讨论以下几种场景：</p>
<p>现有Model对象以及<code>block</code>对象：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先我们来看这么一段代码案例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">      <span class="comment">//临时作用域开始  </span></span><br><span class="line">      &#123;</span><br><span class="line">          Person *p = [[Person alloc] init];</span><br><span class="line">      &#125;<span class="comment">//临时作用域结束</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;-----&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在临时作用域里面的<code>person</code>对象只要出了作用域就会被释放，这一点是很好理解的。</p>
<p>上面的代码加入<code>block</code>，调整如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^Block)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Block block;</span><br><span class="line">        &#123;</span><br><span class="line">            Person *p = [[Person alloc] init];</span><br><span class="line">            p.age = <span class="number">10</span>;</span><br><span class="line">              <span class="comment">//ARC环境下，使用强指针指向block时，会对block进行copy操作</span></span><br><span class="line">            block = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;-----%d&quot;</span>,p.age);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">//运行到此处，p并没有被释放</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果告诉我们，出了临时作用域，<code>p</code>对象没有被释放。</p>
<p>这里有两个注意点：</p>
<p>由于现在是<strong>ARC</strong>环境，<code>Block block</code>属于强指针，因此在将<strong>block</strong>对象赋值给<code>block</code>指针的时候，编译器会自动对<strong>block</strong>对象执行<code>copy</code>操作，因此赋值完成后，<code>block</code>指向的是一个堆空间上的<strong>block</strong>对象副本。(同block的copy操作)</p>
<p>通过终端命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp</code>，拿到编译后的.cpp文件。整理简化后：</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E8%AE%BF%E9%97%AEstrong%E6%8C%87%E9%92%88.png" class="" title="...">

<p>以上是 *<em>【ARC环境下，堆上block访问强指针Person <em>p】</em></em>所对应的运行结果以及底层实现。</p>
<p>我们发现于之前捕获一个基本类型的<code>auto</code>变量所不同的是，当<strong>block</strong>捕捉对象类型的<code>auto</code>变量的时候，<code>__main_block_desc_0</code>结构体里面多了两个彩蛋</p>
<ul>
<li>函数指针<code>copy</code>，也就是<code>__main_block_copy_0()</code>，内部调用了<code>_Block_object_assign()</code></li>
<li>函数指针<code>dispose</code>，也就是<code>__main_block_dispose_0()</code>，内部调用了<code>_Block_object_dispose()</code></li>
</ul>
<p>这里还需要注意的是，<strong>ARC</strong> 下<code>Person *person</code>被认为是强指针，等价于<code>_strong Person *person</code>，而弱指针需要显式地表示为<code>__weak Person *person</code>。通过终端命令<code>xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-9.0.0 main.m -o main.cpp</code>，可以看到block的内捕获到的<code>Person</code>指针如下:<br>修改后：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^Block)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Block block;</span><br><span class="line">        &#123;</span><br><span class="line">            Person *p = [[Person alloc] init];</span><br><span class="line">            p.age = <span class="number">10</span>;</span><br><span class="line">            __<span class="keyword">weak</span> <span class="keyword">typeof</span>(p) weakP = p;</span><br><span class="line">            block = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;-----%d&quot;</span>,weakP.age);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这该语句执行之前，p就释放了</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写后：</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E8%AE%BF%E9%97%AEweak%E6%8C%87%E9%92%88.png" class="" title="...">

<p>可以看出此时的block使用的<code>__weak</code>指针，并没有对<code>p</code>进行捕获。</p>
<p>所以可以总结出几点规律：</p>
<ul>
<li><p>当<code>block</code>内部访问了对象类型的<code>auto</code>变量时，</p>
<ul>
<li>如果<code>block</code>是在栈上，将不会对<code>auto</code>变量产生强引用。</li>
<li>如果<code>block</code>被拷贝到堆上<ul>
<li>会调用<code>block</code>的<code>copy</code>函数</li>
<li><code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数，该函数会根据<code>aotu</code>变量的修饰符(<code>__strong,__weak,__unsafe_unretained</code>)做出相应的操作，形成强引用或弱引用</li>
</ul>
</li>
<li>如果<code>block</code>从堆上移除<ul>
<li>会调用<code>block</code>内部的<code>dispose</code>函数</li>
<li><code>dispose</code>函数内部会调用<code>_Block_object_dispose</code>函数</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>auto</code>变量(<code>release</code>)</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">调用时机</th>
</tr>
</thead>
<tbody><tr>
<td align="center">copy函数</td>
<td align="center">栈上的Block复制到堆时</td>
</tr>
<tr>
<td align="center">dispose函数</td>
<td align="center">堆上的Block被弃用时</td>
</tr>
</tbody></table>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><h3 id="修改变量"><a href="#修改变量" class="headerlink" title="修改变量"></a>修改变量</h3><p><code>block</code>内部修改外部变量的值通常有这几种。</p>
<ul>
<li><p><code>static</code>修饰的变量，在<code>block</code>内可以修改变量的值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^GLBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        GLBlock glBlock = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);<span class="comment">//age is 20</span></span><br><span class="line">        &#125;;</span><br><span class="line">            </span><br><span class="line">        glBlock();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;real age is %d&quot;</span>,age);<span class="comment">//real age is 20</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理是<code>block</code>捕获局部<code>static</code>变量，将<code>static</code>变量的地址保存在<code>GLBlock</code>底层的结构体中。</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F_static.png" class="" title="...">
</li>
<li><p>使用全局变量，block不会使用全局变量，而是直接使用，所以可以直接改值。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^GLBlock)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        GLBlock glBlock = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);<span class="comment">//age is 20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        glBlock();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;real age is %d&quot;</span>,age);<span class="comment">//real age is 20</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/block%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F_gobal.png" class="" title="...">
</li>
<li><p>使用<code>__block</code>修饰符修饰变量。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^GLBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        GLBlock glBlock = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">            age = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,age);<span class="comment">//age is 20</span></span><br><span class="line">        &#125;;</span><br><span class="line">        glBlock();</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;real age is %d&quot;</span>,age);<span class="comment">//real age is 20</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么<code>__block</code>是如何做到的呢？</p>
</li>
</ul>
<h3 id="block的本质-1"><a href="#block的本质-1" class="headerlink" title="__block的本质"></a>__block的本质</h3><p>将使用<code>__block</code>修饰符修改变量的代码重写为C++后。</p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/--block%E9%87%8D%E5%86%99%E4%BB%A3%E7%A0%81.png" class="" title="...">

<p>可以看到<code>main</code>函数中，<code>__block int age = 10;</code>，age被包装成了<code>__Block_byref_age_0</code>结构体。而<code>__Block_byref_age_0</code>中包含<code>isa</code>指针，即<strong>编译器会将__block变量包装成一个对象。</strong></p>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/--block%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1.png" class="" title="...">

<p>这样<code>age = 10;</code>实际上保存在堆上。<code>glBlock</code>修改<code>age</code>的时，也是从<code>__main_block_impl_0-&gt;age-&gt;__forwarding-&gt;a</code>中获取。</p>
<p>不过在外部使用<code>age</code>时，还是使用的<code>int a</code>，即<code>__Block_byref_age_0-&gt;forwarding-&gt;age</code>。这样使用者无需知道底层实现，也不会在使用上感知出差异，隐藏了真正的内部实现。</p>
<h3 id="block的内存管理"><a href="#block的内存管理" class="headerlink" title="__block的内存管理"></a>__block的内存管理</h3><ul>
<li>当block在栈上时，并不会对<code>__block</code>变量产生强引用</li>
<li>当block被<code>copy</code>到堆上时：<ol>
<li>会调用block内部的copy函数;</li>
<li><code>copy</code>函数内部会调用<code>_Block_object_assign</code>函数；</li>
<li><code>_Block_object_assign</code>函数会对<code>__block</code>变量形成强引用(<code>retain</code>)。</li>
</ol>
</li>
</ul>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/--block-block%E7%9A%84copy%E6%93%8D%E4%BD%9C.png" class="" title="...">

<ul>
<li>当block从堆中移除时：<ol>
<li>会调用block内部的<code>dispose</code>函数；</li>
<li><code>dispose</code>函数内部会调用<code>__Block_object_dispose</code>函数；</li>
<li><code>_Block_object_dispose</code>函数会自动释放引用的<code>__block</code>变量(<code>release</code>)；</li>
</ol>
</li>
</ul>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/--block-block%E7%9A%84release%E6%93%8D%E4%BD%9C.png" class="" title="...">

<h4 id="block包装对象中，-forwarding指针的理解"><a href="#block包装对象中，-forwarding指针的理解" class="headerlink" title="__block包装对象中，__forwarding指针的理解"></a>__block包装对象中，__forwarding指针的理解</h4><p>__block包装的对象，其结构体中都包含一个指向自身的<code>__forwarding</code>指针。如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_person_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> GLPerson *__<span class="keyword">strong</span> person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当将栈上的<code>__block</code>变量copy到堆上时，栈上变量的<code>__forwarding</code>指针指向堆中变量。而堆中变量<code>__forwarding</code>指针也指向堆中的自己。这样，无论是通过栈上的还是堆上变量，只要通过<code>__forwarding</code>指针就可以访问到堆上的变量。</p>
<h3 id="block修饰对象类型。"><a href="#block修饰对象类型。" class="headerlink" title="__block修饰对象类型。"></a>__block修饰对象类型。</h3><p>如果使用<code>__block</code>修饰对象类型。底层也会产生一个包装对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__block GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译后的代码--------------------</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_person_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> GLPerson *__strong person; <span class="comment">//这里用什么修饰符，取决于person的修饰符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当<code>__block</code>变量在上栈上时，不会对指向的对象产生强引用。</p>
</li>
<li><p>当<code>__block</code>变量被copy到堆：</p>
<ol>
<li>会调用<code>__block</code>变量内部的copy函数；</li>
<li>copy函数内部会调用<code>_Block_object_assign</code>函数；</li>
<li><code>_Block_object_assign</code>函数会根据所指向对象的修饰符（<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>）做出相应的操作，形成强引用（<code>retain</code>）或者弱引用（<code>注意：这里仅限于ARC时会retain，MRC时不会retain,即：MRC环境下，始终是弱引用</code>）。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__block __weak GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_person_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</span><br><span class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</span><br><span class="line"> GLPerson *__weak person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------------------------------------------------</span></span><br><span class="line"> __block __unsafe_unretained GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_person_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_person_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> GLPerson *__unsafe_unretained person;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当<code>__block</code>变量从堆上移除：</p>
<ol>
<li>会调用<code>__block</code>变量内部的<code>dispose函数</code></li>
<li><code>dispose函数</code>内部会调用<code>_Block_object_dispose函数</code></li>
<li><code>_Block_object_dispose函数</code>会自动释放指向的对象（release）</li>
</ol>
</li>
</ul>
<h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>循环引用会导致对象无法释放，如下一段代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^GLBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) GLBlock block;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLPerson</span></span></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Person dealloc&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        GLPerson *person = [[GLPerson alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>,person.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行到<code>NSLog(@&quot;------&quot;);</code>时，<code>person</code>是没有释放的。</p>
<p>其原因在于：<code>person</code>引用了<code>block</code>，而<code>block</code>又引用了<code>person</code>构成循环引用，导致<code>person</code>无法释放。</p>
<h3 id="ARC环境下解除循环引用"><a href="#ARC环境下解除循环引用" class="headerlink" title="ARC环境下解除循环引用"></a>ARC环境下解除循环引用</h3><ul>
<li><p>使用<code>__weak</code>和<code>__unsafe_unretained</code>修饰符可以解决循环引用的问题。</p>
<ul>
<li><code>__weak</code>会使block内部将指针变为弱指针，block对person对象为弱指针的话，也就不会出现互相引用而导致不会被释放了。</li>
<li>__unsafe_unretain<code>从字面意思就可以理解，也不是强引用，不会引起引用计数+1。</code></li>
<li><code>__weak</code>和<code>__unsafe_unretained</code>的区别。<ul>
<li><code>__weak</code>不会产生强引用，指向的对象销毁时，会自动将指针置为nil，因此一般通过<code>__weak</code>来解决问题。</li>
<li><code>__unsafe_unretained</code>不会引起强引用，指向的对象销毁时，指针存储的地址值不变，当再次通过指针获取对象时，访问的时坏内存，所以是不安全的。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用<code>__block</code>也可以解决循环引用的问题。</p>
<p>当使用<code>__block</code>修饰时生成结构体<code>__Block_byref_person_0</code>其内部的<code>person</code>对象引用着外面的<code>person</code>实例。结构体内部<code>person对象</code>置为<code>nil</code>也就断开了结构体对<code>person</code>的强引用。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __block Person *person = [[Person alloc] init];</span><br><span class="line">        person.age = <span class="number">10</span>;</span><br><span class="line">        person.block = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,person.age);</span><br><span class="line">            person = <span class="literal">nil</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        person.block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;-------&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<img src="/2017/03/21/block%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/--block%E8%A7%A3%E9%99%A4%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" class="">

<p> <strong>这样做有一个弊端：必须执行block，并且在block内部将person对象置为nil。</strong></p>
<h3 id="MRC环境下解除循环引用"><a href="#MRC环境下解除循环引用" class="headerlink" title="MRC环境下解除循环引用"></a>MRC环境下解除循环引用</h3><ul>
<li><p>使用<code>__unsafe_unretained</code>解决。</p>
<p>在MRC环境下不支持使用<code>__weak</code>，使用原理同ARC环境下相同。</p>
</li>
<li><p>使用<code>__block</code>解决。</p>
<p>因为上文<code>__block</code>内存管理中提到过，MRC环境下，尽管调用了copy操作，<code>__block</code>结构体不会对person产生强引用，依然是弱引用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__block <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.block = ^ &#123;</span><br><span class="line">    printf(<span class="string">&quot;%p&quot;</span>,weakSelf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="strong-和-weak"><a href="#strong-和-weak" class="headerlink" title="__strong 和 __weak"></a>__strong 和 __weak</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">person.block = ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) myself = weakSelf;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;age is %d&quot;</span>, myself-&gt;_age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有时候为了避免block内部的对象在调用时被销毁，所以在block内部重新使用__strong修饰self变量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/28/%E5%B7%A7%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/28/%E5%B7%A7%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">巧用关联对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-28 16:38:10" itemprop="dateCreated datePublished" datetime="2017-02-28T16:38:10+08:00">2017-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/02/28/%E5%B7%A7%E7%94%A8%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Category底层原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-21 16:38:10" itemprop="dateCreated datePublished" datetime="2017-02-21T16:38:10+08:00">2017-02-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>OC是一门动态语言，所有的工作会尽可能在运行时才去决定完成，而非编译时。Category作为OC的一种特性，是开发中很常用的一种特性。</p>
<h2 id="Category与Class-Extension"><a href="#Category与Class-Extension" class="headerlink" title="Category与Class Extension"></a>Category与Class Extension</h2><p>不同于Class Extension，Category是在运行时，才会将数据合并到类信息中，而Class Extension在编译的时候，它的数据就已经包含在类信息中了。</p>
<h2 id="Category的底层结构"><a href="#Category的底层结构" class="headerlink" title="Category的底层结构"></a>Category的底层结构</h2><p>根据objc源码可以在<code>objc-runtime-new.h</code>文件中找到<code>Category</code>的底层数据结构：<strong>category_t</strong>。并且我们对一个已有的Category重写为C++, ,发现<code>Category</code>底层被转换为<strong>_category_t</strong>这种类型的结构。</p>
<img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Category%E7%9A%84%E7%BB%93%E6%9E%84.png" class="">

<h2 id="Category的加载过程"><a href="#Category的加载过程" class="headerlink" title="Category的加载过程"></a>Category的加载过程</h2><img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Category%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" class="">

<ul>
<li><p>_objc_init ：objc的入口函数，包含了环境变量，线程的处理，C++静态函数，Runtime，缓存条件的初始化和回调机制的启动。</p>
</li>
<li><p>map_images : 在dyld已将images加载入内存中时，回调该函数。</p>
</li>
<li><p>map_images_nolock ： 会在map_images中调用。</p>
</li>
<li><p>_read_images : 是map_images_nolock的核心函数，内部做了如下处理，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/290568369761">参考</a></p>
<ul>
<li><p>加载所有类到类的<code>gdb_objc_realized_classes</code>表中。</p>
</li>
<li><p>对所有类做重映射。</p>
</li>
<li><p>将所有<code>SEL</code>都注册到<code>namedSelectors</code>表中。</p>
</li>
<li><p>修复函数指针遗留。</p>
</li>
<li><p>将所有<code>Protocol</code>都添加到<code>protocol_map</code>表中。</p>
</li>
<li><p>对所有<code>Protocol</code>做重映射。</p>
</li>
<li><p>初始化所有非懒加载的类，进行<code>rw、ro</code>等操作。</p>
</li>
<li><p>遍历已标记的懒加载的类，并做初始化操作。</p>
</li>
<li><p>处理所有<code>Category</code>，包括<code>Class</code>和<code>Meta Class</code>。</p>
</li>
<li><p>初始化所有<code>未初始化</code>的类。</p>
</li>
</ul>
</li>
<li><p>_load_categories_nolock : 加载分类</p>
</li>
<li><p>remapClass : 重映射类。</p>
</li>
<li><p>attachCategories : 遍历分类数组，将分类的信息添加到类上</p>
</li>
<li><p>attachLists : 方法数组，属性数组，协议数组均会调用该方法，将分类相应的数据进行拼接。内部逻辑为：</p>
<ul>
<li>将原有数组扩容到 原有数组长度+分类中数组的长度</li>
<li>将类中（方法、属性、协议）数组原有数据移动到数组尾端。</li>
<li>将分类中（方法、属性、协议）数组添加到类中相应数组的首部。</li>
</ul>
</li>
</ul>
<h3 id="memmove与memcpy"><a href="#memmove与memcpy" class="headerlink" title="memmove与memcpy"></a>memmove与memcpy</h3><p>在attchList函数中，新数组拼接到原有数组上时，用到了<strong>memmove</strong>与<strong>memcpy</strong>函数。<strong>这俩函数作用是一样的，唯一的区别是，当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。</strong>而源码中：<strong>memmove</strong>操作的是原数组内移动，需要保证结果正确。<strong>memcpy</strong>是新数组拷贝到旧数组，所以不会发生内存重叠的问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数组中原有的数据放到数组末尾。数组内操作，需保证拷贝结果不会因内存重叠发生错误。</span></span><br><span class="line">memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line"><span class="comment">//将新数组添加到开头；两个数组之间操作，不会发生内存重叠的问题。</span></span><br><span class="line"><span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="调用原有实现"><a href="#调用原有实现" class="headerlink" title="调用原有实现"></a>调用原有实现</h3><p>从Category的加载流程中可以看到，在类或元类的方法数组，属性数组，协议数组中，分类的实现排在了原有的实现，这就意味着：<strong>假如分类中有和类中同名的方法，会优先调用分类的中的方法。</strong>那么如果想调用原有的方法实现，那么就需要倒序遍历方法数组，找到方法后执行。</p>
<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 在 GLObject 中定义一个start方法</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLObject</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;GLObject start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GLObject</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="comment">/// 覆盖原有类中的start实现</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Test start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 调用原有start实现</span></span><br><span class="line">- (<span class="keyword">void</span>) oldStart &#123;</span><br><span class="line">    Class clazz = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount;</span><br><span class="line">    <span class="comment">//获取方法类表</span></span><br><span class="line">    Method *methodList = class_copyMethodList(clazz, &amp;methodCount);</span><br><span class="line">    <span class="comment">//倒序遍历方法数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = methodCount; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        <span class="comment">//通过SEL来对比</span></span><br><span class="line">        SEL methodSel = method_getName(method);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(methodSel) isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(start))]) &#123;</span><br><span class="line">            <span class="comment">//获取方法实现</span></span><br><span class="line">            IMP last_start_imp = method_getImplementation(method);</span><br><span class="line">            <span class="keyword">typedef</span> <span class="keyword">void</span> (*fn)(<span class="keyword">id</span>,SEL);</span><br><span class="line">            <span class="comment">//调用</span></span><br><span class="line">            fn f = (fn)last_start_imp;</span><br><span class="line">            f(<span class="keyword">self</span>,methodSel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        GLObject *obj = [[GLObject alloc] init];</span><br><span class="line">        [obj start]; <span class="comment">//Test start</span></span><br><span class="line">        [obj oldStart]; <span class="comment">//GLObject start</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Category的总结"><a href="#Category的总结" class="headerlink" title="Category的总结"></a>Category的总结</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>Category编译之后的底层数据结构是<strong>struct category_t</strong>，里面存储着分类的对象方法，类方法、属性、协议信息。在程序运行的时候，Runtime会将Category的数据合并到类信息中（类对象、元类对象中）。</p>
<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><ul>
<li>如果Category中和本类中有重名的方法，在将Category的数据合并到类信息中（类对象、元类对象中）时，Category的方法会排在本类方法前面。调用时，就会调用Category的方法。</li>
<li>如果多个Category中都含有同名的方法，那么后编译的Category，方法会排在方法数组前面。调用时，也会调用最后编译的Category中的方法。</li>
</ul>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="+load方法"></a>+load方法</h2><p>iOS开发中，<strong>load函数</strong>的使用频次不算太高，一般的应用场景包括：</p>
<p>1、hook方法的时候 </p>
<p>2、涉及到组件化开发中不同组件间通信，在load中注册相关协议等等；</p>
<p>load的加载是在pre-main阶段（即main函数之前，<strong>load_images函数中</strong>），关于这点大家是有共识的，所以load方法中的逻辑要尽可能的简单，不要让其影响到APP的启动速度。</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Category_load%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B_%E5%B9%95%E5%B8%83.png" class="">

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/Category_load%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81_%E5%B9%95%E5%B8%83.png" class="">

<h3 id="load-总结"><a href="#load-总结" class="headerlink" title="+load 总结"></a>+load 总结</h3><ul>
<li><strong>+load</strong>方法会在Runtime加载类、分类的时候调用</li>
<li>每个<strong>类</strong>、<strong>分类</strong>的<strong>+load</strong>，在程序运行过程中只调用一次。</li>
<li>调用顺序<ul>
<li>1、先调用类的<strong>+load</strong><ul>
<li>按照编译的先后顺序调用(先编译，先调用)</li>
<li>调用子类的<strong>+load</strong>之前会先调用父类的<strong>+load</strong></li>
</ul>
</li>
<li>2、再调用分类的<strong>+load</strong><ul>
<li>按照编译的先后顺序调用(先编译，先调用)</li>
</ul>
</li>
</ul>
</li>
<li><strong>+load方法</strong>是使用函数地址直接调用的，并非<strong>objc_msgSend</strong>。</li>
</ul>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="+initialize方法"></a>+initialize方法</h2><p><strong>+initialize</strong>方法会在类第一次接收到消息时调用。关于这个方法，Apple的文档中是这样描述的：</p>
<blockquote>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Initializes the <span class="keyword">class</span> before it receives its first message.</span><br><span class="line"></span><br><span class="line">在这个类接收第一条消息之前调用。</span><br><span class="line"></span><br><span class="line">Discussion</span><br><span class="line"></span><br><span class="line">The runtime sends initialize to each <span class="keyword">class</span> <span class="keyword">in</span> a program exactly one time just before the <span class="keyword">class</span>, or any <span class="keyword">class</span> that inherits from it, is sent its first message from within the program. (Thus the method may never be invoked <span class="keyword">if</span> the <span class="keyword">class</span> is not used.) The runtime sends the initialize message to classes <span class="keyword">in</span> a thread-safe manner. Superclasses receive <span class="keyword">this</span> message before their subclasses.</span><br><span class="line"></span><br><span class="line">Runtime在一个程序中每一个类的一个程序中发送一个初始化一次，或是从它继承的任何类中，都是在程序中发送第一条消息。（因此，当该类不使用时，该方法可能永远不会被调用。）运行时发送一个线程安全的方式初始化消息。父类的调用一定在子类之前。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="调用流程-1"><a href="#调用流程-1" class="headerlink" title="调用流程"></a>调用流程</h3><img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/initialize%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B_%E5%B9%95%E5%B8%83.png" class="">

<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><img src="/2017/02/21/Category%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/+initialize%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90_%E5%B9%95%E5%B8%83.png" class="">

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul>
<li><strong>+initialize</strong>方法会在类第一次接收到消息时调用</li>
<li>调用顺序：<ul>
<li>先调用父类的+initialize，再调用子类的+initialize</li>
<li>(先初始化父类，再初始化子类，每个类只会初始化一次)</li>
</ul>
</li>
<li><code>+initialize</code> 和 <code>+ load</code> 的很大区别 是：<code>+initialize</code>是通过<code>objc_msgSend</code>进行调用的，所以有以下特点：<ul>
<li>如果子类中没有实现 <code>+ initialize</code>，会调用父类本身的 <code>+initialize</code> (所以父类的 <code>+initialize</code> 方法可能会被调用多次)</li>
<li>如果分类实现了 <code>+initialize</code>，就覆盖类本身的 <code>+initialize</code>调用</li>
</ul>
</li>
</ul>
<p>一个比较经典的例子：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SuperObject initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperObject</span> (<span class="title">Runnale</span>)</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperObject</span> (<span class="title">Runnale</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>) initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SuperObject (Runnale) initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperObject</span> (<span class="title">Start</span>) //编译顺序在 <span class="title">SuperObject</span> (<span class="title">Runnale</span>)之后</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperObject</span> (<span class="title">Start</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>) initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;SuperObject (Start) initialize&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubObject1</span> : <span class="title">SuperObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubObject1</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubObject2</span> : <span class="title">SuperObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubObject2</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//输出：</span></span><br><span class="line">        <span class="comment">//SuperObject (Start) initialize</span></span><br><span class="line">        <span class="comment">//SuperObject (Start) initialize</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为：调用子类的+initialize 方法之前 调用了 父类的+initialize</span></span><br><span class="line">        <span class="comment">// 而SuperObject的分类中实现了+initialize（最后编译的是SuperObject (Start)）</span></span><br><span class="line">        <span class="comment">// 又因为 SubObject1 没有实现,所以调用了父类的+initialize，即[SuperObject(Start) initialize]</span></span><br><span class="line">        <span class="comment">// 所以调用了两次 [SuperObject(Start) initialize]</span></span><br><span class="line">        [SubObject1 alloc];</span><br><span class="line">        <span class="comment">//输出：</span></span><br><span class="line">        <span class="comment">//因为SubObject2没有实现,所以调用了父类的+initialize，即[SuperObject(Start) initialize]</span></span><br><span class="line">        [SubObject2 alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/" class="post-title-link" itemprop="url">KVO&KVC探究手记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-11 16:38:10" itemprop="dateCreated datePublished" datetime="2017-02-11T16:38:10+08:00">2017-02-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>KVO和KVC在OC中都是很常用的技术，也是技术面试中考察的标配。经常会被问起KVO和KVC的底层是如何实现的呢，如何手动触发KVO呢等等。今天就用这篇博客来记录一下对KVO和KVC的学习以及底层的原理。</p>
<h2 id="KVO探究"><a href="#KVO探究" class="headerlink" title="KVO探究"></a>KVO探究</h2><p> KVO全称是Key-Value Observing, 翻译过来就是**”键值监听”**，可以用来监听某个对象属性值的改变。</p>
<p>我们先来写一段简单的代码对比一下添加KVO和未添加KVO的对比。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个Person类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GLPerson</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///KVO触发的场景</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) GLPerson *person1;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>,<span class="keyword">nonatomic</span>) GLPerson *person2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">        <span class="comment">//1. 初始化两个对象</span></span><br><span class="line">    <span class="keyword">self</span>.person1 = [[GLPerson alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">self</span>.person2 = [[GLPerson alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">2</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//2. 获取这个对象的地址</span></span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;self.person1:%p&quot;</span>,<span class="keyword">self</span>.person1);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;self.person2:%p&quot;</span>,<span class="keyword">self</span>.person2);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//person1添加KVO</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person1.age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.person2.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@ : %@&quot;</span>,object,change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们触发<code>touchesBegan</code>方法时，控制台上已经有了如下信息：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO%E4%BE%8B%E5%AD%90.png" class="">

<p>可以看出，虽然<code>person1</code>和<code>person2</code>的<code>age</code>值都发生了改变，但的确只有<code>person1</code>触发了KVO。同样都是<code>GLPerson</code>，<code>setAge:</code>的实现也肯定是一样的，为什么一个可以触发，一个不能触发呢。那是不是<code>person1</code>的<code>setAge：</code>和<code>person2</code>的的<code>setAge:</code>的确不一样呢。我们来验证一下，获取一下<code>person1</code>和<code>person2</code>的<code>setAge：</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印person1和person2的地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;self.person1:%p&quot;</span>,<span class="keyword">self</span>.person1);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;self.person2:%p&quot;</span>,<span class="keyword">self</span>.person2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印person1和person2中 setAge:的函数地址</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">                   [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//person1添加KVO</span></span><br><span class="line"><span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">[<span class="keyword">self</span>.person1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;age&quot;</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p %p&quot;</span>,[<span class="keyword">self</span>.person1 methodForSelector:<span class="keyword">@selector</span>(setAge:)],</span><br><span class="line">                             [<span class="keyword">self</span>.person2 methodForSelector:<span class="keyword">@selector</span>(setAge:)]);</span><br></pre></td></tr></table></figure>

<p>控制台信息输出：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO_method.png" class="">

<p>可以看出，<strong>没有添加KVO之前，两个对象的<code>setAge:</code>的实现是一样的。添加KVO之后，<code>setAge:</code>方法被指向了另外的地址。</strong></p>
<p>使用LLDB打印这个地址的方法实现：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO_method_point.png" class="">

<p>可以看出，添加KVO之后，set方法的实现被指向了<code>_NSSetIntValueAndNotify</code>。我们知道，类的实例方法是存储在<code>Class</code>对象中的，如果set方法的实现是在Class对象被修改的，那么会影响所有的实例对象的调用。这显然是不对的。可以推断出，添加KVO之后的实例对象的class对象被修改了，即<strong>修改了isa的指向</strong>。</p>
<p>我们验证一下：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO_isa.png" class="">

<p>可以看出：添加KVO之后，实例对象的isa指向了一个名为<strong>NSKVONotifying_GLPerson</strong>的Class对象。可以猜想到，KVO的实现是实例对象动态的改变了<code>isa</code>的指向。我们来进一步的看一下这个类更为详细的信息，利用Runtime获取一下这个类的成员属性，方法，父类等信息。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class clazz = object_getClass(<span class="keyword">self</span>.person1);</span><br><span class="line"><span class="comment">///遍历方法</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">Method  *methods = class_copyMethodList(clazz, &amp;methodCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">    <span class="comment">///获得方法</span></span><br><span class="line">    Method method = methods[i];</span><br><span class="line">    <span class="comment">///获取方法名</span></span><br><span class="line">    <span class="built_in">NSString</span> *methodName = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;方法名:%@&quot;</span>,methodName);</span><br><span class="line">&#125;</span><br><span class="line">free(methods);</span><br><span class="line"></span><br><span class="line"><span class="comment">///遍历属性</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ivarCount = <span class="number">0</span>;</span><br><span class="line">Ivar *ivars = class_copyIvarList(clazz, &amp;ivarCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ivarCount; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ivarName = ivar_getName(ivar);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *ivarType = ivar_getTypeEncoding(ivar);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;属性类型：%s，属性名称：%s&quot;</span>,ivarType,ivarName);</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印父类</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;父类：%@&quot;</span>,[clazz superclass]);</span><br></pre></td></tr></table></figure>

<p>我们得到如下信息。</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO_class_info.png" class="">

<p>到此KVO是如何实现的基本上就明了了。就以<code>GLPerson</code>为例:</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/unuse_kvo.png" class="">

<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/use_kvo.png" class="">

<h3 id="NSSet-ValueAndNotify"><a href="#NSSet-ValueAndNotify" class="headerlink" title="_NSSet*ValueAndNotify"></a>_NSSet*ValueAndNotify</h3><p>我们从上面的例子中看出，<code>NSKVONotifying_GLPerson</code>的<code>setAge:</code>的实现最终指向了<code>_NSSetIntValueAndNotify</code>。其实这类函数在Foundation框架中还有很多：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/ValueAndNotify.png" class="">

<p>对于<code>_NSSet*ValueAndNotify</code>的内部实现基本上可以表示为：</p>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVO%E6%B5%81%E7%A8%8B.png" class="">

<h2 id="KVO总结"><a href="#KVO总结" class="headerlink" title="KVO总结"></a>KVO总结</h2><ul>
<li><p>KVO的实现原理(KVO的本质)</p>
<ul>
<li>利用RuntimeAPI动态生成一个子类，并且让<code>instance</code>对象的isa指向这个全新的子类。</li>
<li>这个子类将添加KVO属性的<code>setter</code>方法的实现指向了Foundation框架的<code>_NSSetXXXValueAndNotify</code>函数。</li>
<li>当修改<code>instance</code>对象的属性的时候，调用了<code>_NSSetXXXValueAndNotify</code>函数，这个函数内部会调用：<ul>
<li><code>willChangeValueForKey:</code></li>
<li>父类原来的<code>setter</code></li>
<li><code>didChangeValueForKey:</code>，这个方法内部还会触发监听器(Observer)的监听方法(observeValueForKeyPath:ofObject:change:context:)</li>
</ul>
</li>
</ul>
</li>
<li><p>如何手动触发KVO？</p>
<p>手动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code></p>
</li>
<li><p>直接修改成员变量会不会触发KVO？</p>
<p>不会。</p>
</li>
</ul>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>KVC全称是<strong>Key-Value Coding</strong>,翻译过来就是<strong>键值编码</strong>。可以通过一个key来访问某个属性。</p>
<p>常见的API：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">///设值</span></span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setValue:(<span class="keyword">id</span>)value forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br><span class="line"><span class="comment">///取值</span></span><br><span class="line">- (<span class="keyword">id</span>)valueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">id</span>)valueForKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>

<h3 id="设值的原理"><a href="#设值的原理" class="headerlink" title="设值的原理"></a>设值的原理</h3><p>调用<code>setValue:forKey:</code>方法其原理是：</p>
<ul>
<li>调用<code>setValue:forKey:</code>方法，会按照<code>setKey:</code>、<code>_setKey:</code>的顺序查找方法，找到了传递参数，调用方法。</li>
<li>如果没有找到，获取类属性<code>accessInstanceVariablesDirectly</code>的值（BOOL，表示是否可以直接实例对象成员属性值，默认为YES）。如果为NO，则调用<code>setValue:forUndfineKey:</code>，这个方法默认会抛出<code>NSUnknownKeyException</code>异常。如果不想抛出异常，则需要重写该方法。</li>
<li>如果<code>accessInstanceVariablesDirectly</code>为YES，则会按照<strong>_key,_isKey,key,isKey</strong>顺序查找成员变量。如果找到了直接赋值，没有找到也会调用<code>setValue:forUndfineKey:</code></li>
</ul>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVC%E8%AE%BE%E5%80%BC%E6%B5%81%E7%A8%8B.png" class="">

<h3 id="取值的原理"><a href="#取值的原理" class="headerlink" title="取值的原理"></a>取值的原理</h3><p>调用<code>valueForKey:</code>方法其原理是：</p>
<ul>
<li>调用<code>valueForKey:</code>方法，会按照**<code>getKey</code>、<code>key</code>、<code>isKey</code>、<code>_key</code>**顺序查找方法。如果找到了则调用方法。</li>
<li>如果没有找到，获取类属性<code>accessInstanceVariablesDirectly</code>的值（BOOL，表示是否可以直接实例对象成员属性值，默认为YES）。如果为NO，则调用<code>ValueforUndfineKey:</code>，这个方法默认会抛出<code>NSUnknownKeyException</code>异常。如果不想抛出异常，则需要重写该方法。</li>
<li>如果返回YES，则会按照<strong>_key、_isKey、key、isKey</strong>顺序查找成员变量。找到成员变量直接取值。没有找到也会调用<code>valueForUndefinedKey</code></li>
</ul>
<img src="/2017/02/11/KVO-KVC%E6%8E%A2%E7%A9%B6%E6%89%8B%E8%AE%B0/KVC%E5%8F%96%E5%80%BC%E6%B5%81%E7%A8%8B.png" class="">

<h3 id="KVC触发KVO"><a href="#KVC触发KVO" class="headerlink" title="KVC触发KVO"></a>KVC触发KVO</h3><p>了解了KVC取值和设值的原理，如果没有相关的setter方法，则直接访问成员变量。在探究KVO的时候我们还知道，没有setter方法直接修改成员变量是不能触发KVO的。不过有一点值得注意，<strong>如果通过KVC去设置，不管有没有setter方法都会触发KVO。可想而知，即使没有setter方法时，KVC直接修改成员变量值的同时，内部也是主动调用<code>willChangeValueForKey:</code>和<code>didChangeValueForKey:</code>两个方法。</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/01/%E7%BB%86%E8%AF%B4isa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/01/%E7%BB%86%E8%AF%B4isa/" class="post-title-link" itemprop="url">细说isa</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-02-01 16:38:10" itemprop="dateCreated datePublished" datetime="2017-02-01T16:38:10+08:00">2017-02-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前几篇文章中的探索，我们知道对象在内存中，最终会被重写为结构体。实例对象的成员值也会保存在这些结构体中。当时方法并不在实例对象中。由于OC的消息转发机制，在一个实例对象，或者类对象调用方法时，<code>isa</code>就起到了连接实例对象和类对象以及元类对象的作用。</p>
<h2 id="isa的创建流程"><a href="#isa的创建流程" class="headerlink" title="isa的创建流程"></a>isa的创建流程</h2><p>通过追踪<code>objc</code>源码，整理出下图的调用流程。ISA是由<code>objc::initIsa()</code>中创建的。</p>
<img src="/2017/02/01/%E7%BB%86%E8%AF%B4isa/isa%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png" class="">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> nonpointer, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    ASSERT(!isTaggedPointer()); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!nonpointer) &#123;</span><br><span class="line">        isa = <span class="keyword">isa_t</span>((<span class="keyword">uintptr_t</span>)cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ASSERT(!DisableNonpointerIsa);</span><br><span class="line">        ASSERT(!cls-&gt;instancesRequireRawIsa());</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">isa_t</span> <span class="title">newisa</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">        ASSERT(cls-&gt;classArrayIndex() &gt; <span class="number">0</span>);</span><br><span class="line">        newisa.bits = ISA_INDEX_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.indexcls = (<span class="keyword">uintptr_t</span>)cls-&gt;classArrayIndex();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        newisa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        <span class="comment">// isa.magic is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        <span class="comment">// isa.nonpointer is part of ISA_MAGIC_VALUE</span></span><br><span class="line">        newisa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        newisa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// This write must be performed in a single store in some cases</span></span><br><span class="line">        <span class="comment">// (for example when realizing a class because other threads</span></span><br><span class="line">        <span class="comment">// may simultaneously try to use the class).</span></span><br><span class="line">        <span class="comment">// fixme use atomics here to guarantee single-store and to</span></span><br><span class="line">        <span class="comment">// guarantee memory order w.r.t. the class index table</span></span><br><span class="line">        <span class="comment">// ...but not too atomic because we don&#x27;t want to hurt instantiation</span></span><br><span class="line">        isa = newisa;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出isa的为<code>isa_t</code>类型，并不是<code>Class</code>类型。</p>
<p>在这一初始化过程中：</p>
<ul>
<li>newisa.bits = ISA_MAGIC_VALUE；首先使用ISA_MAGIC_VALUE将bits进行初始化，主要有两个作用：<ul>
<li>将nonpointer标记为1，证明开启了isa优化；</li>
<li>初始化magic位,用于标记该对象已经初始化.</li>
</ul>
</li>
<li>newisa.has_cxx_dtor = hasCxxDtor;初始化对象标记是否有C++或者OC析构函数，如果存在在对象释放时需要消耗更多时间来对对象进行析构；</li>
<li>newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3；将对象指向的类或者类的元类指针赋值给位域shiftcls，因为前三位被nonpointer，has_assoc和has_cxx_dtor被占据，所以需要将真实的指针左移三位进行复制保存.</li>
</ul>
<h2 id="isa-t"><a href="#isa-t" class="headerlink" title="isa_t"></a>isa_t</h2><p>在早期的32bit版本中isa就是一个单一的指针,用于存储当前对象的类或者类的元类. 但是在64bit为操作系统上，用一个8字节指针的长度只存储一个对象地址显然是浪费的(操作系统只有一部分地址是可用于存储对象地址的空间)，所以apple对这个isa指针进行了优化。将其定义为一个公用体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        ISA_BITFIELD;  <span class="comment">// defined in isa.h</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们知道共用体所有的成员变量都公用一个内存空间，一个共用体所占的内存空间就是其成员变量中所占内存空间最大的那个。</p>
<p>作为过渡也为了兼容早期的实现版本，这个结构中保存了变量Class class的实现，同时增加了uintptr_t(unsigned long)类型的变量bits,但由于使用的是联合体(公用体,共用变量空间),所以该结构只占用一个指针的空间.当使用bits变量进行存储时,利用<strong>位域结构</strong>将变量的各个位进行拆分赋予不同的含义,充分利用了内存空间.</p>
<p>利用位域使得变量内不仅仅保存了指针值，同时还保存了很多有用的信息.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">  Class cls;</span><br><span class="line">  <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以主流的arm64为例，主要包含了：</p>
<ul>
<li>nonpointer：占用1bit,标识是否开启isa优化.如果是一个指针值该位为0,则表示当前结构的值只是一个指针没有保存其他信息;如果为1,则表示当前结构不是指针,而是一个包含了其他信息的位域结构；</li>
<li>has_assoc:当前对象是否使用objc_setAssociatedObject动态绑定了额外的属性;</li>
<li>has_cxx_dtor: 是否含有C++或者OC的析构函数,不包含析构函数时对象释放速度会更快;</li>
<li>shiftcls:   <strong>这个值相当于早期实现中的isa指针，是真实的指针值，在arm64处理器上只占据33位,可见其实在内存中可以用来存储对象指针的空间是很有限的；</strong></li>
<li>magic：用于判断对象是否已经完成了初始化，在 arm64 中 0x16 是调试器判断当前对象是真的对象还是没有初始化的空间(在 x86_64 中该值为 0x3b);</li>
<li>weakly_referenced:是否是弱引用对象;</li>
<li>deallocating:对象是否正在执行析构函数（是否在释放内存）;</li>
<li>has_sidetable_rc:判断是否需要用sidetable去处理引用计数;</li>
<li>extra_rc：存储该对象的引用计数值减一后的结果. 当对象的引用计数使用extra_rc足以存储时has_sidetable_rc=0；当对象的引用计数使用extra_rc不能存储时has_sidetable_rc=1.可见对象的引用计数主要存储在两个地方：如果isa中extra_rc足以存储则存储在isa的位域中；如果isa位域不足以存储，就会使用sidetable去存储.</li>
</ul>
<h3 id="ISA-MASK"><a href="#ISA-MASK" class="headerlink" title="ISA_MASK"></a>ISA_MASK</h3><p>在iOS 64bit的操作系统中，为了屏蔽外界对于isa指针的直接获取对外部隐藏了真实的isa指针的值,而是需要使ISA_MASK进行与操作来获取到真实的isa.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Class </span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer()); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">if</span> (isa.nonpointer) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> slot = isa.indexcls;</span><br><span class="line">        <span class="keyword">return</span> classForIndex((<span class="keyword">unsigned</span>)slot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Class)isa.bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> (Class)(isa.bits &amp; ISA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以如果想要通过获取到对象真实的isa指针指向需要与ISA_MASK进行与操作</strong>。</p>
<h3 id="ISA-MAGIC-MASK"><a href="#ISA-MAGIC-MASK" class="headerlink" title="ISA_MAGIC_MASK"></a>ISA_MAGIC_MASK</h3><p><strong>从isa_t位域的定义中可以知道,magic变量占据了6bit的空间，使用ISA_MAGIC_MASK就可以快速地从isa_t中获取到magic值.</strong></p>
<blockquote>
<p>在__arm64__中，位域magic占据了从37位(1(nonpointer)+1(has_assoc)+1(has_cxx_dtor)+33(shiftcls) )开始的6bit空间，而ISA_MAGIC_MASK=0x000003f000000001ULL，除第37-42位和最低位外所有位均为0;在__x86_64__中，位域magic占据了从47位(1(nonpointer)+1(has_assoc)+1(has_cxx_dtor)+44(shiftcls))开始的6bit空间，而ISA_MAGIC_MASK=0x001f800000000001ULL，除第44-49位和最低位外其余位均为0.所以使用isa.bits &amp; ISA_MAGIC_MASK,可以快速判断出是否开启nonpointer优化和magic的值.</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> MAGIC_MASK      36</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">elif</span> __x86_64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> MAGIC_MASK      47</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">error</span> unknown architecture for packed isa</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">void</span> *ptr = (__bridge <span class="keyword">void</span> *)obj;</span><br><span class="line">ptr = *(<span class="keyword">void</span> **)ptr;</span><br><span class="line">uintptr_t magic = (uintptr_t)(<span class="keyword">void</span> *)((uintptr_t)ptr &amp; ISA_MAGIC_MASK);</span><br><span class="line"><span class="keyword">if</span> (magic &amp; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;magic == %lu&quot;</span>, magic &gt;&gt; MAGIC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="isa的连接作用"><a href="#isa的连接作用" class="headerlink" title="isa的连接作用"></a>isa的连接作用</h2><p>讲了<code>isa</code>的创建过程，那么isa的作用是什么呢？isa相当于一个桥梁，连接着实例对象、类对象，元类对象。</p>
<img src="/2017/02/01/%E7%BB%86%E8%AF%B4isa/isa_bridge.png" class="">

<ul>
<li><p><code>instance</code>对象的isa指向<code>class</code>。</p>
<p>当调用<strong>对象方法</strong>时，通过instance的isa找到class，最后找到对象方法的实现进行调用。</p>
</li>
<li><p><code>class</code>对象的isa指向<code>meta-class</code></p>
<p>当调用<strong>类方法</strong>时，通过<code>class</code>的isa找到<code>meta-class</code>,最后找到类方法的实现进行调用。</p>
</li>
</ul>
<h2 id="isa走位原理图"><a href="#isa走位原理图" class="headerlink" title="isa走位原理图"></a>isa走位原理图</h2><p>在实际开发中，通常会存在继承关系，这些继承关系中isa的走位关系可以引用苹果官方文档中的一个图：</p>
<img src="/2017/02/01/%E7%BB%86%E8%AF%B4isa/isa_%E8%B5%B0%E4%BD%8D%E5%8E%9F%E7%90%86%E5%9B%BE.png" class="">

<p>从图中我们可以看出：</p>
<ul>
<li>instance的isa指向class</li>
<li>class的isa直线meta-class</li>
<li>meta-class的isa指向基类的meta-class</li>
<li>class的superclass指向父类的class，如果没有父类（NSObject），superclass指针为nil。</li>
<li>metaclass的superclass指向父类的meta-class，<strong>基类的meta-class的superclass指向基类的class。</strong></li>
<li>instance调用对象方法的轨迹：<ul>
<li>实例对象的isa找到class，方法不存在，就通过superclass一层一层在父类中的方法。</li>
</ul>
</li>
<li>class调用类方法的轨迹：<ul>
<li>类对象的isa找meta-class，就通过superclass一层一层在找父类中的方法。</li>
</ul>
</li>
</ul>
<p>这里面比较有意思的一条就是：<strong>基类的meta-class的superclass指向基类的class</strong>。难道说如果调用某个类对象调用类方法，如果一直没有找到，最终会在基类的实例方法中找吗？我们验证一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// MARK: 在NSObject中添加实例方法 test</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>) test;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;-[NSObject test] %p&quot;</span>,<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">void</span>) test;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,[Person <span class="keyword">class</span>]);<span class="comment">//0x100008148</span></span><br><span class="line">        [Person test]; <span class="comment">//-[NSObject test] 0x100008148</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>果然是这样！！Amazing。</p>
<h2 id="窥探Class的结构"><a href="#窥探Class的结构" class="headerlink" title="窥探Class的结构"></a>窥探Class的结构</h2><p>说了这么多关于isa指向的问题。有一点应该可以注意到，类对象的类型、元类对象的类型是<code>Class</code>类型的，那么<code>Class</code>的结构是怎样的呢？</p>
<p>我们来看一下源码中是如何定义的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>可以看出<code>Class</code>实际上是一个指向<code>struct objc_class</code>的指针，接着我们看<code>struct objc_class</code>的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我们直接取一部分我们关注的</span></span><br><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">    class_rw_t *data() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bits.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>objc_class</code>继承自<code>objc_object</code>，同样我们来看一下他是如何定义的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，objc_class里面也是有一个<code>isa_t</code>类型的isa，我们在前面讨论了<code>isa_t</code>的结构和作用，<code>isa_t</code>可以提取出Class类型isa。我们可以将<code>objc_class</code>大概的结构表示为：</p>
<img src="/2017/02/01/%E7%BB%86%E8%AF%B4isa/Class%E7%9A%84%E7%BB%93%E6%9E%84.png" class="">

<p>图中设计到两个结构体<code>class_rw_t</code>、<code>class_ro_t</code>。从字面我们也可以看出</p>
<ul>
<li><code>class_rw_t</code>：存储的是<strong>可读可写的class信息</strong>。</li>
<li><code>class_ro_t</code>：只读，存储<code>class</code>的具体信息。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">OC对象的分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-20 16:38:10" itemprop="dateCreated datePublished" datetime="2017-01-20T16:38:10+08:00">2017-01-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>前几天，针对一道面试题分析了一下OC对象的本质。如果有兴趣可以去看一下。全篇其实讲的就是<strong>实例对象</strong>。</p>
<p><code>objc</code>的对象主要可以分为3种：</p>
<ul>
<li>instance对象(实例对象)</li>
<li>class对象(类对象)</li>
<li>meta-class对象(元类对象)</li>
</ul>
<p>本文只分析这几种对象，涉及到的<code>isa</code>方面的会另开一篇博客专门分析。</p>
<h2 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h2><ul>
<li>instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象。</li>
<li>instance对象在内存中存储的信息包括：<ul>
<li><code>isa</code>指针</li>
<li>其他成员变量</li>
</ul>
</li>
</ul>
<img src="/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/instance_obj.png" class="" title="This is an example image">

<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><ul>
<li><p>我们可以通过很多方法来获取一个类对象：</p>
<ul>
<li>实例对象调用<code>-class</code>方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class obj_class = [obj1 <span class="keyword">class</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>类调用<code>+class</code>方法：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class obj_class2 = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Runtime API：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class obj_class3 = object_getClass(obj1);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>这些方法获取的都是同一个对象，每个类在内存有且只有一个<code>class</code>对象。</strong></p>
<ul>
<li>class对象在内存中储存信息主要包括：<ul>
<li><code>isa</code>指针</li>
<li><code>superclass</code>指针</li>
<li>类型的属性信息(<code>@property</code>)，类的实例方法信息(instance method)</li>
<li>类的协议信息(<code>protocal</code>)，类的成员变量(<code>ivar</code>)</li>
</ul>
</li>
</ul>
<img src="/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/class_obj.png" class="" title="This is an example image">

<h2 id="meta-class"><a href="#meta-class" class="headerlink" title="meta-class"></a>meta-class</h2><p>meta-class被称为元类对象。每个类的内存中有且只有一个meta-class对象。</p>
<p>meta-class对象中存储的信息主要包括：</p>
<ul>
<li>isa指针</li>
<li>superclass指针</li>
<li>类的类方法信息(class method)</li>
</ul>
<img src="/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/meta-class_obj.png" class="" title="This is an example image">

<p>meta-class也是<code>Class</code>类型的，所以meta-class对象和Class对象的内存结构都是一样的。存储的信息不同就是说相关的成员变量为<code>nil</code>而已。</p>
<img src="/2017/01/20/OC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%86%E7%B1%BB/class%E5%AF%B9%E8%B1%A1%E5%92%8CmetaClass.png" class="" title="This is an example image">

<h3 id="相关的API"><a href="#相关的API" class="headerlink" title="相关的API"></a>相关的API</h3><ul>
<li><p>获取：</p>
<p><code>object_getClass(id obj)</code>函数同样也可以用来获取meta-class。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Class对象</span></span><br><span class="line">Class cls = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,cls);<span class="comment">//0x7fff93c6f118</span></span><br><span class="line"><span class="comment">//获取metaClass对象</span></span><br><span class="line">Class metaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,metaClass);<span class="comment">//0x7fff93c6f0f0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种方式只能获取Class对象，获取不到metaClass对象</span></span><br><span class="line">Class <span class="keyword">class</span> = [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%p&quot;</span>,<span class="keyword">class</span>);<span class="comment">//0x7fff93c6f118</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断：</p>
<p>可以通过<code>Runtime API</code>中<code>class_isMetaClass()</code>判断</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Class cls = [<span class="built_in">NSObject</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,class_isMetaClass(cls));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">Class metaClass = object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,class_isMetaClass(metaClass)); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Object-getClass"><a href="#Object-getClass" class="headerlink" title="Object_getClass"></a>Object_getClass</h2><p>在获取class对象和元类对象中，我们都使用了<code>object_getClass(id obj)</code>这个API。</p>
<p> 总结一下：</p>
 <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="comment">//传入instance对象返回class对象</span></span><br><span class="line">Class cls = object_getClass(obj);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,class_isMetaClass(cls));<span class="comment">//0</span></span><br><span class="line"><span class="comment">//传入class对象返回meta-class对象</span></span><br><span class="line">Class metaCls = object_getClass(cls);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>,class_isMetaClass(metaCls));<span class="comment">//1</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/16/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/16/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/" class="post-title-link" itemprop="url">从一道面试看OC对象本质</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-16 16:38:10" itemprop="dateCreated datePublished" datetime="2017-01-16T16:38:10+08:00">2017-01-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先上一道面试题：</p>
<blockquote>
<p>一个NSObject对象占用多少内存？</p>
</blockquote>
<p>想要弄清这个问题，那么我们如果知道了一个NSObject对象在内存中是如何布局的，就知道了这个对象占用了多少内存。</p>
<p>想必小伙伴们都知道，OC作为C语言的超集，它的面向对象的能力是以<code>C/C++</code>来实现的。Xcode也是支持将OC转成C++代码的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件</span><br></pre></td></tr></table></figure>

<h2 id="OC对象的底层实现"><a href="#OC对象的底层实现" class="headerlink" title="OC对象的底层实现"></a>OC对象的底层实现</h2><p>了解了如何将OC代码重写为C++代码，我们首先看一下在<code>NSObject.h</code>中是如何定义<code>NSObjcet</code>的呢？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NSObject.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从框架的头文件中可以看到，<code>NSObject</code>只有一个<code>isa</code>的成员变量。我们将如下代码重写为C++然后观察一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心的话可以发现的这样一段代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> &#123;</span></span><br><span class="line">    Class isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从结构体的名称就可以看出，<code>NSObject</code>在底层被重写为一个结构体。只有一个成员变量<code>isa</code>。而<code>NSObjcet</code>作为OC中所有类的基类，我们可以得出一条结论：<strong>OC对象在底层是用结构体来实现的。</strong></p>
<p>我们还可以追溯<code>Class</code>的定义:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>

<p>所以<code>Class</code>类型，是一个指向<code>objc_class</code>结构体的指针。同时我们知道，一个指针在64位系统上占用8个字节，32位系统上占用4个字节。所以我们可以推断出，<strong>只有一个成员变量的结构体<code>NSObject_IMPL</code>所占的内存大小就是<code>isa</code>所占的内存空间空间大小。</strong>即64位环境下：一个NSObject对象占8个字节。</p>
<p>但实际上不是，实际上是16个字节。</p>
<h2 id="通过API来获取对象大小"><a href="#通过API来获取对象大小" class="headerlink" title="通过API来获取对象大小"></a>通过API来获取对象大小</h2><p>先介绍两个用来获取对象大小的函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过类型来获取该类型实例对象所占的内存大小</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line">size_t class_getInstanceSize(Class _Nullable cls);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过一个指针来获取该指针指向内存的大小</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;malloc/malloc.h&gt;</span></span></span><br><span class="line">size_t malloc_size(<span class="keyword">const</span> <span class="keyword">void</span> *ptr);</span><br></pre></td></tr></table></figure>

<p>我们通过这两个函数来获取一下<code>NSObject</code>的实例对象所占内存的大小：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// &gt;&gt;8</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, class_getInstanceSize([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line">        <span class="comment">// &gt;&gt;16</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)obj));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么系统到底为这个<code>obj</code>对象分配了多少内存呢？我们从<code>NSObject</code>的<code>alloc</code>着手分析一下。</p>
<p>在源码中，我们可以看到<code>alloc</code>的实现：调用了<code>_obj_rootAllic()</code>，</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NSObject.mm</span></span><br><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续搜索<code>_obj_rootAllic()</code>，其实现为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NSObject.mm</span></span><br><span class="line"><span class="keyword">id</span> _objc_rootAlloc(Class cls) &#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续搜索<code>callAlloc</code>函数，其实现为：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NSObject.mm</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="keyword">return</span> _objc_rootAllocWithZone(cls, <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">struct</span> _NSZone *))objc_msgSend)(cls, <span class="keyword">@selector</span>(allocWithZone:), <span class="literal">nil</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(cls, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>搜索<code>_objc_rootAllocWithZone</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NSObject.mm</span></span><br><span class="line"><span class="keyword">id</span> _objc_rootAllocWithZone(Class cls, malloc_zone_t *zone __unused)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索<code>_class_creatInstanceFromZone</code>的实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> _class_createInstancesFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                               <span class="keyword">id</span> *results, <span class="keyword">unsigned</span> num_requested)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> num_allocated;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line"></span><br><span class="line">    num_allocated = </span><br><span class="line">        malloc_zone_batch_malloc((malloc_zone_t *)(zone ? zone : malloc_default_zone()), </span><br><span class="line">                                 size, (<span class="keyword">void</span>**)results, num_requested);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_allocated; i++) &#123;</span><br><span class="line">        bzero(results[i], size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct each object, and delete any that fail construction.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> ctor = cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; num_allocated; i++) &#123;</span><br><span class="line">        <span class="keyword">id</span> obj = results[i];</span><br><span class="line">        obj-&gt;initIsa(cls);    <span class="comment">// fixme allow nonpointer</span></span><br><span class="line">        <span class="keyword">if</span> (ctor) &#123;</span><br><span class="line">            obj = object_cxxConstructFromClass(obj, cls,</span><br><span class="line">                                               OBJECT_CONSTRUCT_FREE_ONFAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">            results[i-shift] = obj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> num_allocated - shift;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到，到<code>_class_creatInstanceFromZone</code>中:</p>
<p><code>size_t size = cls-&gt;instanceSize(extraBytes);</code>，而<code>instanceSize</code>中：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.fastInstanceSize(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 如果size最小为16，所以<code>NSObject</code>的实例对象占用16个字节是源代码中影响规定的，而实际上，一个<code>NSObject</code>只用了8个字节(64位)。</p>
<p>整体的调用流程为：</p>
<img src="/2017/01/16/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/alloc%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.jpg" class="" title="This is an example image">

<h2 id="API结果的含义"><a href="#API结果的含义" class="headerlink" title="API结果的含义"></a>API结果的含义</h2><p>根据我们前面一系列的探索，我们最终得知，一个<code>NSObject</code>对象系统分配了16个字节。</p>
<p>前面我们使用的两个函数，也应该知道了获取的真正含义：</p>
<ul>
<li><code>malloc_size()</code>：创建一个实例对象，实际上分配了多少内存。</li>
<li><code>class_getInstanceSize()</code>:创建一个实例对象，至少需要多少内存(结果等同于<code>sizeof()</code>运算符)</li>
</ul>
<blockquote>
<p><code>sizeof()</code>的注意点：</p>
<p><code>sizeof</code>是一个运算符，并不是一个函数。传入一个类型，返回该类型的所占用的内存。在编译的时候就编译为常数。</p>
<p>假如传入一个指针连变量，则返回这个指针变量所占的内存大小。至于这个指针指向内存的大小，则需要<code>malloc_size()</code>。</p>
</blockquote>
<h2 id="NSObject的子类"><a href="#NSObject的子类" class="headerlink" title="NSObject的子类"></a>NSObject的子类</h2><p>通过前边我们了解了<code>NSObject</code>的底层实现，以及实例对象所占内存的大小。那么对于<code>NSObject</code>的子类情况又是如何呢?</p>
<p>我们先自定义一个<code>Student</code>类</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu-&gt;_no = <span class="number">4</span>;</span><br><span class="line">stu-&gt;_age = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>我们将其重写为C++,可以看到<code>Student</code>在底层的实现为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_IMPL</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span>    <span class="comment">//父类的结构体</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到底层的结构体，第一个成员为父类的结构体，其余依次为自身成员属性。</p>
<p>在代码中显示声明结构体<code>Student_IMPL</code>，也可以将<code>Student</code>对象转换为<code>Student_IMPL</code>结构体：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu-&gt;_no = <span class="number">4</span>;</span><br><span class="line">stu-&gt;_age = <span class="number">5</span>;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">struct</span> Student_IMPL *stu2 = (__bridge  <span class="keyword">struct</span> Student_IMPL *)stu;<span class="comment">//OC转C，需要使用__bridge</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%d,%d&quot;</span>,stu2-&gt;_no,stu2-&gt;_age);<span class="comment">//4,5</span></span><br></pre></td></tr></table></figure>

<p><strong>那么<code>Student</code>的实例对象占用多少内存呢？</strong></p>
<p>我们打一个断点，来获取代码中<code>stu</code>的内存地址：<code>0x100713890</code>。通过Xcode Debug -&gt; Debug Workflow -&gt; View Memory来查看实时内存。我们大概的可以推断出<code>Student</code>也占16个字节。</p>
<img src="/2017/01/16/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/WX20201221-231232.png" class="" title="This is an example image">

<p>从<code>Student</code>在底层转换实现的结构体可以看出，<code>Student_IMPL</code>结构体一共有三个成员变量，其中<code>NSObject_IVARS</code>分配了16个字节，但是只是用了8个字节，还有八个字节，正好可以存放两个<code>int</code>型变量。</p>
<img src="/2017/01/16/%E4%BB%8E%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%9C%8BOC%E5%AF%B9%E8%B1%A1%E6%9C%AC%E8%B4%A8/WX20201221-232722.png" class="" title="This is an example image">

<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &gt;&gt;16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)stu));</span><br><span class="line"><span class="comment">// &gt;&gt;16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,class_getInstanceSize([Student <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure>

<h3 id="再多一个成员"><a href="#再多一个成员" class="headerlink" title="再多一个成员"></a>再多一个成员</h3><p>当然如果<code>Student</code>的再多一个<code>int</code>成员变量：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line">stu-&gt;_no = <span class="number">4</span>;</span><br><span class="line">stu-&gt;_age = <span class="number">5</span>;</span><br><span class="line">stu-&gt;_height = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt;&gt;32</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)stu));</span><br><span class="line"><span class="comment">// &gt;&gt;24</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,class_getInstanceSize([Student <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// &gt;&gt; 24</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%zd&quot;</span>,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Student_IMPL));</span><br></pre></td></tr></table></figure>

<p>我们可以看到系统分配的空间为32个字节，实例所占的内存空间而是24个字节。这就涉及到了iOS系统底部内存优化和内存对齐的问题。通过跟踪<code>alloc</code>函数，程序最终调用了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size); <span class="comment">// size即24</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看出，这个对象至少需要24个字节。当向系统申请24个字节内存的时候，系统分配了32个字节。通过在<code>libmalloc</code>开源代码中，了解到iOS系统分配内存都是16的倍数(推测是加快内存分配速度和访问速度)。所以系统向其分配了32个字节。</strong></p>
<h2 id="更为复杂的场景"><a href="#更为复杂的场景" class="headerlink" title="更为复杂的场景"></a>更为复杂的场景</h2><p>现在我们假设有这样的场景：</p>
<p>现在有两个类: <code>Student</code>和<code>Person</code>。其中他们的继承关系为：<code>Student</code> -&gt; <code>Person</code> -&gt; <code>NSObject</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Student</span> : <span class="title">Person</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _no;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>那么Person实例对象，Student的实例对象分别占用多少内存呢？</strong>。答案都是16个字节。</p>
<p>我们知道，<code>Person</code>和<code>Student</code>对象在底层都是这样实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span> <span class="comment">//8个字节</span></span><br><span class="line">    <span class="keyword">int</span> _age; <span class="comment">//4个字节</span></span><br><span class="line">&#125;; <span class="comment">//16个字节：结构体的大小必须是最大成员大小的倍数（内存对齐）。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student_IMPL</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> <span class="title">Person_IVARS</span>;</span><span class="comment">//16个字节，但是空余4个字节</span></span><br><span class="line">    <span class="keyword">int</span> _no; <span class="comment">//4个字节，因为前边正好有4个空余的字节，正好用来存放_no。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们来证实一下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line"><span class="comment">// &gt;&gt;16，这里从上面的分析来看应该返回12，但是这个函数是返回对齐后的内存大小。</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Person:%zd&quot;</span>,class_getInstanceSize([Person <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// &gt;&gt;16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;p:%zd&quot;</span>,malloc_size((__bridge  <span class="keyword">const</span> <span class="keyword">void</span> *)p));</span><br><span class="line">        </span><br><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"><span class="comment">// &gt;&gt;16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;Student:%zd&quot;</span>,class_getInstanceSize([Student <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// &gt;&gt;16</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;stu:%zd&quot;</span>,malloc_size((__bridge  <span class="keyword">const</span> <span class="keyword">void</span> *)stu));</span><br></pre></td></tr></table></figure>

<h2 id="property-成员"><a href="#property-成员" class="headerlink" title="@property 成员"></a>@property 成员</h2><p>对于<code>@property</code>修饰的成员变量，编译器自动生成成员变量：<code>_</code> + 变量名；并且生成<code>setter</code>&amp;<code>getter</code>方法。</p>
<p>OC实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">assign</span>) <span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>底层实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person_IMPL</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">NSObject_IMPL</span> <span class="title">NSObject_IVARS</span>;</span></span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _I_Person_height(Person * self, SEL _cmd) &#123; </span><br><span class="line">  <span class="keyword">return</span> (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Person$_height)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Person_setHeight_(Person * self, SEL _cmd, <span class="keyword">int</span> height) &#123; </span><br><span class="line">  (*(<span class="keyword">int</span> *)((<span class="keyword">char</span> *)self + OBJC_IVAR_$_Person$_height)) = height; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dev.Gao">
      <meta itemprop="description" content="人类的本能是胆怯，但人类的本质是不甘心">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Dev.Gao的学习笔记">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/01/01/Objective-C%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" class="post-title-link" itemprop="url">Objective-C编码规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-01-01 16:38:10" itemprop="dateCreated datePublished" datetime="2017-01-01T16:38:10+08:00">2017-01-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/Objective-C/" itemprop="url" rel="index"><span itemprop="name">Objective-C</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇编码风格指南概括了raywenderlich.com的编码规范，可能有些删减或修改。</p>
<ul>
<li>原文作者 : <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.raywenderlich.com">raywenderlich.com Team</a></li>
<li>译文出自 : <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/samlaudev/Objective-C-Coding-Style#error-handling">raywenderlich.com Objective-C编码规范</a></li>
<li>译者 : <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/samlaudev">Sam Lau</a></li>
</ul>
<p>在多人开发同一个app时，如果每个人的Objective-C编码风格都不一样，这样不易于保持代码<strong>一致性</strong>和<strong>难以Code Review</strong>。所以我在网上搜索到 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/raywenderlich/objective-c-style-guide#language">The official raywenderlich.com Objective-C style guide</a>这篇关于Objective-C编码风格的文章，觉得可以作为这个项目的Objective-C的编码标准，所以就翻译这篇文章。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们制定Objective-C编码规范的原因是我们能够在我们的书，教程和初学者工具包的代码保持优雅和一致。即使我们有很多不同的作者来完成不同的书籍。</p>
<p>这里编码规范有可能与你看到的其他Objective-C编码规范不同，因为它主要是为了打印和web的易读性。</p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>这编码规范的创建是由很多来自raywenderlich.com团队成员在Nicholas Waynik的带领下共同完成的。团队成员有：<a target="_blank" rel="noopener" href="https://github.com/moayes">Soheil Moayedi Azarpour</a>, <a target="_blank" rel="noopener" href="https://github.com/ricardo-rendoncepeda">Ricardo Rendon Cepeda</a>, <a target="_blank" rel="noopener" href="https://github.com/tdahbura">Tony Dahbura</a>, <a target="_blank" rel="noopener" href="https://github.com/ColinEberhardt">Colin Eberhardt</a>, <a target="_blank" rel="noopener" href="https://github.com/mattjgalloway">Matt Galloway</a>, <a target="_blank" rel="noopener" href="https://github.com/gregheo">Greg Heo</a>, <a target="_blank" rel="noopener" href="https://github.com/hollance">Matthijs Hollemans</a>, <a target="_blank" rel="noopener" href="https://github.com/elephantronic">Christopher LaPollo</a>, <a target="_blank" rel="noopener" href="https://github.com/casademora">Saul Mora</a>, <a target="_blank" rel="noopener" href="https://github.com/macandyp">Andy Pereira</a>, <a target="_blank" rel="noopener" href="https://github.com/micpringle">Mic Pringle</a>, <a target="_blank" rel="noopener" href="https://github.com/pietrorea">Pietro Rea</a>, <a target="_blank" rel="noopener" href="https://github.com/funkyboy">Cesare Rocchi</a>, <a target="_blank" rel="noopener" href="https://github.com/icanzilb">Marin Todorov</a>, <a target="_blank" rel="noopener" href="https://github.com/ndubbs">Nicholas Waynik</a>和<a target="_blank" rel="noopener" href="https://github.com/raywenderlich">Ray Wenderlich</a></p>
<p>我们也非常感谢<a target="_blank" rel="noopener" href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a> 和<a target="_blank" rel="noopener" href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils’</a>Objective-C编码规范的作者。这两个编码规范为本指南的创建提供很好的起点。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这里有些关于编码风格Apple官方文档，如果有些东西没有提及，可以在以下文档来查找更多细节：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html">The Objective-C Programming Language</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CocoaFundamentals/Introduction/Introduction.html">Cocoa Fundamentals Guide</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html">Coding Guidelines for Cocoa</a></li>
<li><a target="_blank" rel="noopener" href="http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html">iOS App Programming Guide</a></li>
</ul>
<h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>应该使用US英语.</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColor = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *myColour = [<span class="built_in">UIColor</span> whiteColor];</span><br></pre></td></tr></table></figure>

<h2 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h2><p>在函数分组和protocol/delegate实现中使用<code>#pragma mark -</code>来分类方法，要遵循以下一般结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Lifecycle</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Custom Accessors</span></span><br><span class="line">- (<span class="keyword">void</span>)setCustomProperty:(<span class="keyword">id</span>)value &#123;&#125;</span><br><span class="line">- (<span class="keyword">id</span>)customProperty &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - IBActions/Event Response</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)submitData:(<span class="keyword">id</span>)sender &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)someButtonDidPressed:(<span class="built_in">UIButton</span>*)button</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Protocol conformance</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UITextFieldDelegate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UITableViewDataSource</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Public</span></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Private</span></span><br><span class="line">- (<span class="keyword">void</span>)privateMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSCopying</span></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - NSObject</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><ul>
<li>缩进使用<strong>4</strong>个空格，确保在Xcode偏好设置来设置。(raywenderlich.com使用<strong>2</strong>个空格)</li>
<li>方法大括号和其他大括号(<code>if</code>/<code>else</code>/<code>switch</code>/<code>while</code> 等.)总是在同一行语句打开但在新行中关闭。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy) &#123;</span><br><span class="line">    <span class="comment">//Do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user.isHappy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//Do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//Do something else</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在方法之间应该有且只有一行，这样有利于在视觉上更清晰和更易于组织。在方法内的空白应该分离功能，但通常都抽离出来成为一个新方法。</li>
<li>优先使用auto-synthesis。但如果有必要，<code>@synthesize</code> 和 <code>@dynamic</code>应该在实现中每个都声明新的一行。</li>
<li>应该避免以冒号对齐的方式来调用方法。因为有时方法签名可能有3个以上的冒号和冒号对齐会使代码更加易读。请<strong>不要</strong>这样做，尽管冒号对齐的方法包含代码块，因为Xcode的对齐方式令它难以辨认。</li>
</ul>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// blocks are easily readable</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span> animations:^&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// colon-aligning makes the block indentation hard to read</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">1.0</span></span><br><span class="line">                 animations:^&#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                     <span class="comment">// something</span></span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>

<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>当需要注释时，注释应该用来解释这段特殊代码<strong>为什么</strong>要这样做。任何被使用的注释都必须保持最新或被删除。</p>
<p>一般都避免使用块注释，因为代码尽可能做到自解释，只有当断断续续或几行代码时才需要注释。<em>例外：这不应用在生成文档的注释</em></p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>Apple命名规则尽可能坚持，特别是与这些相关的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">memory management rules</a> (<a target="_blank" rel="noopener" href="http://stackoverflow.com/a/2865194/340508">NARC</a>)。</p>
<p>长的，描述性的方法和变量命名是好的。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *settingsButton;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> *setBut;</span><br></pre></td></tr></table></figure>

<p>三个字符前缀应该经常用在类和常量命名，但在Core Data的实体名中应被忽略。对于官方的raywenderlich.com书、初学者工具包或教程，前缀’RWT’应该被使用。</p>
<p>常量应该使用驼峰式命名规则，所有的单词首字母大写和加上与类名有关的前缀。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> RWTTutorialViewControllerNavigationFadeAnimationDuration = <span class="number">0.3</span>;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> fadetime = <span class="number">1.7</span>;</span><br></pre></td></tr></table></figure>

<p>属性也是使用驼峰式，但首单词的首字母小写。对属性使用auto-synthesis，而不是手动编写@ synthesize语句，除非你有一个好的理由。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *descriptiveVariableName;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> varnm;</span><br></pre></td></tr></table></figure>

<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>当使用属性时，实例变量应该使用<code>self.</code>来访问和改变。这就意味着所有属性将会视觉效果不同，因为它们前面都有<code>self.</code>。</p>
<p>但有一个特例：在初始化方法里，实例变量(例如，_variableName)应该直接被使用来避免getters/setters潜在的副作用。</p>
<p>局部变量不应该包含下划线。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>在方法签名中，应该在方法类型(-/+ 符号)之后有一个空格。在方法各个段之间应该也有一个空格(符合Apple的风格)。在参数之前应该包含一个具有描述性的关键字来描述参数。</p>
<p>“and”这个词的用法应该保留。它不应该用于多个参数来说明，就像<code>initWithWidth:height</code>以下这个例子：</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setExampleText:(<span class="built_in">NSString</span> *)text image:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector to:(<span class="keyword">id</span>)anObject forAllCells:(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)viewWithTag:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width height:(<span class="built_in">CGFloat</span>)height;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)setT:(<span class="built_in">NSString</span> *)text i:(<span class="built_in">UIImage</span> *)image;</span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector :(<span class="keyword">id</span>)anObject :(<span class="built_in">BOOL</span>)flag;</span><br><span class="line">- (<span class="keyword">id</span>)taggedView:(<span class="built_in">NSInteger</span>)tag;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;  <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>



<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量尽量以描述性的方式来命名。单个字符的变量命名应该尽量避免，除了在<code>for()</code>循环。</p>
<p>星号表示变量是指针。例如， <code>NSString *text</code> 既不是 <code>NSString* text</code> 也不是 <code>NSString * text</code>，除了一些特殊情况下常量。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/samlaudev/Objective-C-Coding-Style#private-properties">私有变量</a> 应该尽可能代替实例变量的使用。尽管使用实例变量是一种有效的方式，但更偏向于使用属性来保持代码一致性。</p>
<p>通过使用’back’属性(_variable，变量名前面有下划线)直接访问实例变量应该尽量避免，除了在初始化方法(<code>init</code>, <code>initWithCoder:</code>, 等…)，<code>dealloc</code> 方法和自定义的setters和getters。想了解关于如何在初始化方法和dealloc直接使用Accessor方法的更多信息，查看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW6">这里</a></p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTTutorial</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="built_in">NSString</span> *tutorialName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性特性"><a href="#属性特性" class="headerlink" title="属性特性"></a>属性特性</h2><p>所有属性特性应该显式地列出来，有助于新手阅读代码。属性特性的顺序应该是storage、atomicity，与在Interface Builder连接UI元素时自动生成代码一致。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIView</span> *containerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>

<p>NSString应该使用<code>copy</code> 而不是 <code>strong</code>的属性特性。</p>
<p>为什么？即使你声明一个<code>NSString</code>的属性，有人可能传入一个<code>NSMutableString</code>的实例，然后在你没有注意的情况下修改它。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *tutorialName;</span><br></pre></td></tr></table></figure>

<h2 id="点符号语法"><a href="#点符号语法" class="headerlink" title="点符号语法"></a>点符号语法</h2><p>点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用getter或setter方法，属性仍然被访问或修改。想了解更多，阅读<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/EncapsulatingData/EncapsulatingData.html">这里</a></p>
<p>点语法应该<strong>总是</strong>被用来访问和修改属性，因为它使代码更加简洁。[]符号更偏向于用在其他例子。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = [<span class="keyword">self</span>.array count];</span><br><span class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor];</span><br><span class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> arrayCount = <span class="keyword">self</span>.array.count;</span><br><span class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]];</span><br><span class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</span><br></pre></td></tr></table></figure>

<h2 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h2><p><code>NSString</code>, <code>NSDictionary</code>, <code>NSArray</code>, 和 <code>NSNumber</code>的字面值应该在创建这些类的不可变实例时被使用。请特别注意<code>nil</code>值不能传入<code>NSArray</code>和<code>NSDictionary</code>字面值，因为这样会导致crash。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = @[<span class="string">@&quot;Brian&quot;</span>, <span class="string">@&quot;Matt&quot;</span>, <span class="string">@&quot;Chris&quot;</span>, <span class="string">@&quot;Alex&quot;</span>, <span class="string">@&quot;Steve&quot;</span>, <span class="string">@&quot;Paul&quot;</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = @&#123;<span class="string">@&quot;iPhone&quot;</span>: <span class="string">@&quot;Kate&quot;</span>, <span class="string">@&quot;iPad&quot;</span>: <span class="string">@&quot;Kamal&quot;</span>, <span class="string">@&quot;Mobile Web&quot;</span>: <span class="string">@&quot;Bill&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = @YES;</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = @<span class="number">10018</span>;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@&quot;Brian&quot;</span>, <span class="string">@&quot;Matt&quot;</span>, <span class="string">@&quot;Chris&quot;</span>, <span class="string">@&quot;Alex&quot;</span>, <span class="string">@&quot;Steve&quot;</span>, <span class="string">@&quot;Paul&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@&quot;Kate&quot;</span>, <span class="string">@&quot;iPhone&quot;</span>, <span class="string">@&quot;Kamal&quot;</span>, <span class="string">@&quot;iPad&quot;</span>, <span class="string">@&quot;Bill&quot;</span>, <span class="string">@&quot;Mobile Web&quot;</span>, <span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];</span><br><span class="line"><span class="built_in">NSNumber</span> *buildingStreetNumber = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</span><br></pre></td></tr></table></figure>



<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用<code>static</code>来声明而不是使用<code>#define</code>，除非显式地使用宏。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@&quot;RayWenderlich.com&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CompanyName @<span class="meta-string">&quot;RayWenderlich.com&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> thumbnailHeight 2</span></span><br></pre></td></tr></table></figure>

<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>当使用<code>enum</code>时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏<code>NS_ENUM()</code>来帮助和鼓励你使用固定的基本类型。</p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain,</span><br><span class="line">  RWTLeftMenuTopItemShows,</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你也可以显式地赋值(展示旧的k-style常量定义)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTGlobalConstants) &#123;</span><br><span class="line">  RWTPinSizeMin = <span class="number">1</span>,</span><br><span class="line">  RWTPinSizeMax = <span class="number">5</span>,</span><br><span class="line">  RWTPinCountMin = <span class="number">100</span>,</span><br><span class="line">  RWTPinCountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>旧的k-style常量定义应该<strong>避免</strong>除非编写Core Foundation C的代码。</p>
<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> GlobalConstants &#123;</span><br><span class="line">  kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">  kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Case语句"><a href="#Case语句" class="headerlink" title="Case语句"></a>Case语句</h2><p>大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Multi-line example using braces</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有很多次，当相同代码被多个cases使用时，一个fall-through应该被使用。一个fall-through就是在case最后移除’break’语句，这样就能够允许执行流程跳转到下一个case值。为了代码更加清晰，一个fall-through需要注释一下。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">// ** fall-through! **</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">// code executed for values 1 and 2</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当在switch使用枚举类型时，’default’是不需要的。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (menuType) &#123;</span><br><span class="line">  <span class="keyword">case</span> RWTLeftMenuTopItemMain:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> RWTLeftMenuTopItemShows:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> RWTLeftMenuTopItemSchedule:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明，命名分类(比如<code>RWTPrivate </code>或<code>private</code>)应该从不使用除非是扩展其他类。匿名分类应该通过使用+Private.h文件的命名规则暴露给测试。</p>
<p><strong>例如:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTDetailViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) GADBannerView *googleAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ADBannerView *iAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWebView</span> *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>Objective-C使用<code>YES</code>和<code>NO</code>。因为<code>true</code>和<code>false</code>应该只在CoreFoundation，C或C++代码使用。既然<code>nil</code>解析成<code>NO</code>，所以没有必要在条件语句比较。不要拿某样东西直接与<code>YES</code>比较，因为<code>YES</code>被定义为1和一个<code>BOOL</code>能被设置为8位。</p>
<p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (![anotherObject boolValue]) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ([anotherObject boolValue] == <span class="literal">NO</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">YES</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">true</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure>

<p>如果<code>BOOL</code>属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure>

<p>文字和例子从这里引用<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingIvarsAndTypes.html#//apple_ref/doc/uid/20001284-BAJGIIJE">Cocoa Naming Guidelines</a></p>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句主体为了防止出错应该使用大括号包围，即使条件语句主体能够不用大括号编写(如，只用一行代码)。这些错误包括添加第二行代码和期望它成为if语句；还有，<a target="_blank" rel="noopener" href="http://programmers.stackexchange.com/a/16530">even more dangerous defect</a>可能发生在if语句里面一行代码被注释了，然后下一行代码不知不觉地成为if语句的一部分。除此之外，这种风格与其他条件语句的风格保持一致，所以更加容易阅读。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) &#123;</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error)</span><br><span class="line">  <span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</span><br></pre></td></tr></table></figure>

<h3 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h3><p>当需要提高代码的清晰性和简洁性时，三元操作符<code>?:</code>才会使用。单个条件求值常常需要它。多个条件求值时，如果使用<code>if</code>语句或重构成实例变量时，代码会更加易读。一般来说，最好使用三元操作符是在根据条件来赋值的情况下。</p>
<p>Non-boolean的变量与某东西比较，加上括号()会提高可读性。如果被比较的变量是boolean类型，那么就不需要括号。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSInteger</span> value = <span class="number">5</span>;</span><br><span class="line">result = (value != <span class="number">0</span>) ? x : y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> isHorizontal = <span class="literal">YES</span>;</span><br><span class="line">result = isHorizontal ? x : y;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; a &gt; b ? x &#x3D; c &gt; d ? c : d : y;</span><br></pre></td></tr></table></figure>

<h2 id="Init方法"><a href="#Init方法" class="headerlink" title="Init方法"></a>Init方法</h2><p>Init方法应该遵循Apple生成代码模板的命名规则。返回类型应该使用<code>instancetype</code>而不是<code>id</code></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看关于instancetype的文章<a target="_blank" rel="noopener" href="https://github.com/samlaudev/Objective-C-Coding-Style#class-constructor-methods">Class Constructor Methods</a></p>
<h2 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h2><p>当类构造方法被使用时，它应该返回类型是<code>instancetype </code>而不是<code>id</code>。这样确保编译器正确地推断结果类型。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Airplane</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)airplaneWithType:(RWTAirplaneType)type;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>关于更多instancetype信息，请查看<a target="_blank" rel="noopener" href="http://nshipster.com/instancetype/">NSHipster.com</a></p>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><p>当访问<code>CGRect</code>里的<code>x</code>, <code>y</code>, <code>width</code>, 或 <code>height</code>时，应该使用<a target="_blank" rel="noopener" href="http://developer.apple.com/library/ios/#documentation/graphicsimaging/reference/CGGeometry/Reference/reference.html"><code>CGGeometry</code>函数</a>而不是直接通过结构体来访问。引用Apple的<code>CGGeometry </code>:</p>
<blockquote>
<p>在这个参考文档中所有的函数，接受CGRect结构体作为输入，在计算它们结果时隐式地标准化这些rectangles。因此，你的应用程序应该避免直接访问和修改保存在CGRect数据结构中的数据。相反，使用这些函数来操纵rectangles和获取它们的特性。</p>
</blockquote>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame);</span><br><span class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame);</span><br><span class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;</span><br><span class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;</span><br><span class="line"><span class="built_in">CGFloat</span> width = frame.size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> height = frame.size.height;</span><br><span class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</span><br></pre></td></tr></table></figure>



<h2 id="黄金路径"><a href="#黄金路径" class="headerlink" title="黄金路径"></a>黄金路径</h2><p>当使用条件语句编码时，左手边的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> (![someOther boolValue]) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Do something important</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)someMethod &#123;</span><br><span class="line">  <span class="keyword">if</span> ([someOther boolValue]) &#123;</span><br><span class="line">    <span class="comment">//Do something important</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当方法通过引用来返回一个错误参数，判断返回值而不是错误变量。</p>
<p><strong>应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> trySomethingWithError:&amp;error]) &#123;</span><br><span class="line">  <span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不应该:</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">[<span class="keyword">self</span> trySomethingWithError:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line">  <span class="comment">// Handle Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在成功的情况下，有些Apple的APIs记录垃圾值(garbage values)到错误参数(如果non-NULL)，那么判断错误值会导致false负值和crash。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例对象应该使用线程安全模式来创建共享实例。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会防止<a target="_blank" rel="noopener" href="http://cocoasamurai.blogspot.com/2011/04/singletons-your-doing-them-wrong.html">possible and sometimes prolific crashes</a>.</p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>换行符是一个很重要的主题，因为它的风格指南主要为了打印和网上的可读性。</p>
<p>例如:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>

<p>一行很长的代码应该分成两行代码，下一行用两个空格隔开。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.productsRequest = [[<span class="built_in">SKProductsRequest</span> alloc] </span><br><span class="line">  initWithProductIdentifiers:productIdentifiers];</span><br></pre></td></tr></table></figure>

<h2 id="Xcode工程"><a href="#Xcode工程" class="headerlink" title="Xcode工程"></a>Xcode工程</h2><p>物理文件应该与Xcode工程文件保持同步来避免文件扩张。任何Xcode分组的创建应该在文件系统的文件体现。代码不仅是根据<strong>类型</strong>来分组，而且还可以根据<strong>功能</strong>来分组，这样代码更加清晰。</p>
<p>尽可能在target的Build Settings打开”Treat Warnings as Errors，和启用以下<a target="_blank" rel="noopener" href="http://boredzo.org/blog/archives/2009-11-07/warnings">additional warnings</a>。如果你需要忽略特殊的警告，使用 <a target="_blank" rel="noopener" href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">Clang’s pragma feature</a>。</p>
<h2 id="其他Objective-C编码规范"><a href="#其他Objective-C编码规范" class="headerlink" title="其他Objective-C编码规范"></a>其他Objective-C编码规范</h2><p>如果我们的编码规范不符合你的口味，可以查看其他的编码规范：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/RobotsAndPencils/objective-c-style-guide">Robots &amp; Pencils</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/NYTimes/objective-c-style-guide">New York Times</a></li>
<li><a target="_blank" rel="noopener" href="http://google-styleguide.googlecode.com/svn/trunk/objcguide.xml">Google</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/github/objective-c-conventions">GitHub</a></li>
<li><a target="_blank" rel="noopener" href="https://trac.adium.im/wiki/CodingStyle">Adium</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/soffes/812796">Sam Soffes</a></li>
<li><a target="_blank" rel="noopener" href="http://cocoadevcentral.com/articles/000082.php">CocoaDevCentral</a></li>
<li><a target="_blank" rel="noopener" href="http://lukeredpath.co.uk/blog/my-objective-c-style-guide.html">Luke Redpath</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cimgf.com/zds-code-style-guide/">Marcus Zarra</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dev.Gao</p>
  <div class="site-description" itemprop="description">人类的本能是胆怯，但人类的本质是不甘心</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dev.Gao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
